------------------  AbstractController.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 2, 2015

@author: Paloschi
'''

from numpy.distutils.environment import __metaclass__
from abc import ABCMeta, abstractmethod
import threading
from PyQt4 import QtCore, QtGui
import ConfigParser
from types import NoneType
from Visao.Box_Progress_Bar import Ui_DlgProgressBar
from PyQt4.Qt import QString
import time
from Visao import DlgNovaSerieTemporal

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

class StoppableThread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self, funcao):
        super(StoppableThread, self).__init__(target=funcao)
        self._stop = threading.Event()

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.isSet()

class Controller(object):
    '''
    Essa classe é um controlador abstrato, criado para padronizar os controladores.
    '''
    
    __metaclass__ = ABCMeta # define a classe como abstrata
    function = None
    thread = None

    def __init__(self, userInterface):
        '''
        Este contrutor é padrão para os controladores, ele recebe uma user interface que permite o controle
        as classes controladoras finais não deverão ter construtores
        '''
        self.config = ConfigParser.RawConfigParser()
        self.config.read('workspace.properties')
        self.ui = userInterface # seta interface para que seja visivel aos outros m�todos

    def print_text(self, text):
        self.progress_bar.print_text(text)
        
    def console(self, text):
        self.progress_bar.print_text(text)
        
    def action_ok(self):
        """
            Esse método cria uma thread pra executar a função
        """
        if self.valida_form() :
         
            self.thread = StoppableThread(self.executa)

            self.progress_bar = Ui_DlgProgressBar(self.ui)
            self.progress_bar.setupUi(self.progress_bar)    
            self.progress_bar.show()
            
            self.thread.start()
            
            while(self.function==None) : 
                time.sleep(0.005)
                              
            self.function.print_text = self.progress_bar.print_text
            self.function.console = self.progress_bar.print_text                  
            
            self.progress_bar.iniciar(self, self.thread)
            
    def action_cancel(self):
            if self.thread != NoneType :
                if self.thread != None :
                    if self.thread.stopped() == False :
                        self.message(u"Atividade ainda em execução \n feche o aplicativo para parar")
            self.ui.close()
    
    @abstractmethod
    def valida_form(self):
        '''
        Esse método tem que existir nas classes controladoras
        aqui serão feitas todas as validações do form    
        '''
   
    @abstractmethod
    def executa(self):
        '''
        Esse método temque existir nas classes controladoras
        aqui serão executadas as funções quando for apertado OK na tela
        '''
    
    """
        Aqui a baixo estão alguns recursos para facilitar a vida dos controladores
    """
    
    def findPath(self, textToWrite, type="none"):
        if type == "folder" :
            fname = QtGui.QFileDialog.getExistingDirectory()
        else :
            fname = QtGui.QFileDialog.getOpenFileName()
        if fname!="" :
            textToWrite.setText (fname)
    
    def getSerieTemporal(self, serieTemporal=None):
        
        dlgSerieTemporal = DlgNovaSerieTemporal.Ui_Dialog(self.ui)
        dlgSerieTemporal.setupUi(dlgSerieTemporal) 
        dlgSerieTemporal.setWindowModality(QtCore.Qt.WindowModal)   
        
        dlgSerieTemporal.setForm(serieTemporal)
        
        dlgSerieTemporal.exec_()
         
        serie_temporal = dlgSerieTemporal.SerieTemporal
        return serie_temporal       
        
    def message(self, text):
        text = QString(text)
        QtGui.QMessageBox.about(self.ui, "Ops...", text)
        
    def funcao_cancelada(self):
        if threading.currentThread().stopped():
                self.progress_bar.finalizar()
                return True
        return False
    
    def confirmar(self, text, title):
        quit_msg = text
        reply = QtGui.QMessageBox.question(self.ui, title, 
                     quit_msg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            return True
        else:
            return False
    
    def finalizar(self):
        self.function.progresso = 100
        self.thread.stop()
        time.sleep(0.2)
        self.progress_bar.finalizar()

------------------  AbstractData.py  ------------------
'''
Created on Jul 14, 2015

@author: Paloschi
'''
from abc import ABCMeta


FILE_DATA = 1
SERIAL_FILE_DATA = 2
TABLE_DATA = 3
FUNCTION_DATA = 4

class ABData(object):
    '''
    classdocs
    '''
    import logging as log
    
    name = None
    file_name = None
    data = None
    __data_type = None
    __metaclass__ = ABCMeta
    
    def __init__(self, data_type):
        self.__data_type = data_type
        
    @property    
    def data_type(self):
        return self.__data_type
    
    @data_type.setter
    def data_type(self, param):
        pass

------------------  AbstractFunction.py  ------------------
# -*- coding: utf-8 -*-

'''
Created on May 11, 2015
@author: Paloschi
'''

from Modelo.beans.AbstractData import ABData, FUNCTION_DATA
from abc import ABCMeta, abstractmethod
from numpy.distutils.environment import __metaclass__
import numpy

import logging as log


class Function(ABData):
    
    '''
    Essa classe representa o padrão das operações e todas as operações devem herda-la
    ela descreve como deve ser as estruturas dentro da função para o correto funcionamento do software
    '''
    
    __metaclass__ = ABCMeta # Essa classe é abstrata, não pode ser instanciada
    
    descriptionIN = None # Descrição dos parametros de entrada das funções   
    descriptionOUT = None # descrição dos parametros de saída das funções
    paramentrosIN_carregados = dict() # parametros de entrada carrecados
    progresso = float(1)
    console = None
    
    @abstractmethod # esse parametro deve ser implementado na classe filha
    def __setParamIN__(self):
        '''
            Esse método e o próximo (__setParamOut__) devem ser implementados conforme a operação
            estes meta-dados são importantes para o funcionamento mais automático possivel do software
        '''
        #self.descriptionIN["nome_atributo"] = {"Required":True, "Type":FILE_DATA, "Description":"um arquivo qualquer requerido"}
        pass
    
    @abstractmethod  # esse parametro deve ser implementado na classe filha 
    def __setParamOUT__(self):
        #self.descriptionOUT["parametro1"] = "Descrição do primeiro parametro de saída"
        #self.descriptionOUT["parametro2"] = "Descrição do segundo parametro de saída"    
        pass
    

    def __init__(self, param=None):
        '''
        Constructor padrão cuida da inicialização do objeto
        '''
        super(Function, self).__init__(FUNCTION_DATA) # seta o tipo do objeto
        
        self.descriptionIN = dict()
        self.descriptionOUT = dict()
        
        self.__setParamIN__() # inicializa descrição de entrada
        self.__setParamOUT__() # inicializa descrição de saída
        

    def __LoadParams__(self, params):
        '''
        O for a serguir carrega os elementos necessários para funcionamento da função
        
        Por enquanto não é recusivo com tabelas
        '''
        log.debug("---------------") 
        log.debug(self.descriptionIN)
        log.debug(params)
        log.debug("---------------")
         
        for key in self.descriptionIN.keys():
            
            if key not in params.keys() or params[key] is None:
                if self.descriptionIN[key]["Required"] :
                    raise Exception((u"Parametro " + key + u" é requerido na função " + self.__class__.__name__))   
                else :
                    self.paramentrosIN_carregados[key] = None
            elif self.descriptionIN[key]["Type"] == FUNCTION_DATA:         
                self.paramentrosIN_carregados[key] = params[key].data    
            else:
                self.paramentrosIN_carregados[key] = params[key]      
            
            if self.paramentrosIN_carregados[key]!=None and self.descriptionIN[key]["Type"]!=None:
                if self.paramentrosIN_carregados[key].data_type != None:
                    if self.paramentrosIN_carregados[key].data_type != self.descriptionIN[key]["Type"]:
                        raise Exception("Parametro incompativel: " + key)   
            
    @property    
    def data(self):
        #if (self.data_name!=None) : print ("Iniciando Operação: " + self.data_name)
        resultado = self.__execOperation__()
        #if (self.data_name!=None) : print ("Operação " + self.data_name + " concluída!")
        return resultado
        
    @data.setter
    def data(self, params):
        self.__LoadParams__(params)
        
    @abstractmethod # esse parametro deve ser implementado na classe filha   
    def __execOperation__(self):
        pass
    
    def executar(self, parametros):
        print "aque1"
        while self.console is None : pass
        print "aque2"
        self.data = parametros
        return self.data
    
    def setProgresso (self, indice, total):
        self.progresso = (indice / float(total) * 100)
        
    def compactar(self, imagem_):
        
        minimo = numpy.min(imagem_)
        maximo = numpy.max(imagem_) 
            
        if minimo >= 0 :
            #if maximo <= 255:
            #    imagem_ = numpy.array(imagem_).astype("uint8")
            if maximo <= 65535:
                imagem_ = numpy.array(imagem_).astype("uint16")
            elif maximo <= 4294967295:
                imagem_ = numpy.array(imagem_).astype("uint32")
        else :
            if minimo >= -128 and maximo <=127 : 
                imagem_ = numpy.array(imagem_).astype("int8")
            elif minimo >= -32768 and maximo <= 32767 : 
                imagem_ = numpy.array(imagem_).astype("int16")
        
        return imagem_

    def procura_img_por_data(self, serie, data):
        img = None
        for i in range(len(serie)):
            data_i = serie.getDate_time(file=serie[i])
            if data_i == data:
                img = serie[i]
                break  
        return img
        

------------------  AnoDia2Numero.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on 31/05/2016

@author: Paloschi

Esse método converterá o formato "AnoDia" (2015045) para um numero começando em uma data informada
'''

import numpy as np
from Modelo.beans import TABLE_DATA, FILE_DATA, RasterFile
from numpy.core.numeric import array
import datetime
import gdal
progress = gdal.TermProgress_nocb   

def Ds_DC_to_date(data):
        n = len(str(data))
        year = int(str(data)[0:4])    
        days = int(str(data)[4:n])
        date = datetime.datetime(year, 1, 1) + datetime.timedelta(days - 1)
        return date

def converter (dia_inicial, imagem):
    
    print "dia inicial: " + str(dia_inicial)
    
    ano_inicial = dia_inicial.year
    
    n_linhas = len(imagem)
    n_colunas = len(imagem[0])
    
    imagem_convertida = np.zeros((n_linhas, n_colunas))     
    imagem_convertida = array(imagem_convertida).astype(dtype="uint16")    
    
    print "iniciando conversão"
    
    progress(0.0)
    
    
    for i in range(0, n_linhas):
        #for ii in range(0, n_colunas):
            #try:
                #data_pixel = Ds_DC_to_date(imagem[i][ii])
                #delta_tempo = (data_pixel - dia_inicial).days
                #imagem_convertida[i][ii] = delta_tempo
                
                #n = len(str(data_pixel))
                #ano_pixel = int(str(data_pixel)[0:4])
                #dia_pixel = int(str(data_pixel)[4:n])
                
                #imagem_convertida[i][ii] = (dia_pixel - dia_inicial) + (ano_pixel - ano_inicial * 365)
                
            #except :
                #pass      
        
        ano_pixel = int(str(data_pixel)[0:4])
        imagem_convertida[i] = imagem[i]
        
        progress(i/float(n_linhas-1))
    print "Conversão terminada, retornando imagem"
    
    return imagem_convertida
 

------------------  Bands_analisis.py  ------------------
# -*- coding: utf-8 -*-

'''
Created on 08/01/2016

@author: Paloschi
'''

from Modelo.beans import RasterFile
import sys

root = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\"
path = root + "ya_invertido_soma.tif"
import numpy as np

raster = RasterFile(file_full_path = path)
data_raster = raster.loadRasterData(True)

nodata = raster.metadata["nodata"]

print nodata

print ""


sys.stdout.write( "media" + "\t") 
sys.stdout.write( "minimo" + "\t") 
sys.stdout.write( "maximo" + "\t") 
sys.stdout.write( "coeficiente de variação" + "\t") 
print("")
    
for band in data_raster:
    mean = list()
    for x in band:
        for y in x:
            if (not np.ma.is_masked(y) and y != 0):
                mean.append(y)
    
    if len(mean)== 0:
        mean = 0
    media = np.mean(mean)
    sys.stdout.write( str(media) + "\t")
    sys.stdout.write( str(np.min(mean)) + "\t")
    sys.stdout.write( str(np.max(mean)) + "\t")
    sd = np.nanstd(mean) 
    if media!= 0:
        cv = sd / (media) * 100
    else :
        cv = 0
    
    sys.stdout.write( str(sd) + "\t")
    print ""
    

for band in data_raster:
    mean = list()
    for x in band:
        for y in x:
            if (not np.ma.is_masked(y)):
                mean.append(y)
    
                      

------------------  Box_Progress_Bar.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Box_Progress_Bar.ui'
#
# Created: Tue Oct 13 04:35:05 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
import time
from PyQt4.Qt import QDialog
import time
#from matplotlib.textpath import text_to_path

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_DlgProgressBar(QDialog):
    
    
    text_to_append = ""
    funcao_finalizada = False
    
    def print_text(self, text):
        while self.text_to_append != "" : pass
        self.text_to_append = text
        
    
    def iniciar(self, controller, thread_executando):
        self.thread_executando = thread_executando
        print "iniciando"
        self._active = True
        while True:
            time.sleep(0.05)
            if self.text_to_append != "" : 
                self.console.appendPlainText(self.text_to_append)
                self.text_to_append = ""
            value = controller.function.progresso
            self.progressBar.setValue(value)
            #print value
            QtGui.qApp.processEvents()
            if (not self._active):
                self.funcao_terminada()
                break
            if self.funcao_finalizada : self.funcao_terminada()

        QtGui.qApp.processEvents()
        
    def cancelar(self):
        if self.confirmar_cancelamento() :
            self.console.appendPlainText("cancelando..")
            self.thread_executando.stop() 
            QtGui.qApp.processEvents()
            while not self.funcao_finalizada : pass
            self.console.appendPlainText(U"Função cancelada!")
            self.btnCancelar.setEnabled(False)
            self.btnOk.setEnabled(True)            
            self._active = False
            self.progressBar.setValue(100)

        
    def confirmar_cancelamento(self):
        quit_msg = "Deseja realmente cancelar o processo?"
        reply = QtGui.QMessageBox.question(self, 'Cancelamento', 
                     quit_msg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
        if reply == QtGui.QMessageBox.Yes:
            return True
        else:
            return False
        
    def setupUi(self, DlgProgressBar):
        DlgProgressBar.setObjectName(_fromUtf8("DlgProgressBar"))
        DlgProgressBar.resize(388, 247)
        self.verticalLayout = QtGui.QVBoxLayout(DlgProgressBar)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        
        self.label = QtGui.QLabel(DlgProgressBar)
        self.label.setObjectName(_fromUtf8("label"))
        self.verticalLayout.addWidget(self.label)
        
        self.console = QtGui.QPlainTextEdit(DlgProgressBar)
        self.console.setReadOnly(True)
        self.console.setPlainText(_fromUtf8(""))
        self.console.setObjectName(_fromUtf8("console"))
        self.verticalLayout.addWidget(self.console)
        
        self.progressBar = QtGui.QProgressBar(DlgProgressBar)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName(_fromUtf8("progressBar"))
        self.verticalLayout.addWidget(self.progressBar)
        
        self.btnCancelar = QtGui.QPushButton(DlgProgressBar)
        self.btnCancelar.setObjectName(_fromUtf8("btnCancelar"))
        self.verticalLayout.addWidget(self.btnCancelar)
        
        self.btnOk = QtGui.QPushButton(DlgProgressBar)
        self.btnOk.setEnabled(False)
        self.btnOk.setObjectName(_fromUtf8("btnOk"))
        self.verticalLayout.addWidget(self.btnOk)

        self.retranslateUi(DlgProgressBar)
        QtCore.QMetaObject.connectSlotsByName(DlgProgressBar)

    def retranslateUi(self, DlgProgressBar):
        DlgProgressBar.setWindowTitle(_translate("DlgProgressBar", "CyMP - Execução da função", None))
        self.label.setText(_translate("DlgProgressBar", "Status:", None))
        self.btnCancelar.setText(_translate("DlgProgressBar", "Cancelar", None))
        self.btnOk.setText(_translate("DlgProgressBar", "OK", None))
        
        self.btnCancelar.clicked.connect(self.cancelar)
        self.btnOk.clicked.connect(self.reject)

    def finalizar(self):
        self.funcao_finalizada = True
        
        
    def funcao_terminada(self):
        self.funcao_finalizada = True
        self.btnCancelar.setEnabled(False)
        self.btnOk.setEnabled(True)            
        self._active = False
        self.progressBar.setValue(100)

------------------  CollorMapCreator.py  ------------------
'''
Created on 19/01/2016

@author: Paloschi
'''
import sys
from numpy import double

minimo = 25;
maximo = 51;

vermelho_default = 255
verde_default = 255
azul_default = 0

vermelho = True
verde = False
azul = False

vermelho_crescente = False
verde_crescente = True
azul_crescente = True

delta = maximo - minimo

for x in range(minimo, maximo):
    
    color_value = int((double(x - minimo) / (maximo - minimo)) * 255)
    #sys.stdout.write("-") 
    sys.stdout.write(str(x) + " ") 
    if vermelho: sys.stdout.write(str(color_value if vermelho_crescente else 255 - color_value) + " ")
    else : sys.stdout.write(str(vermelho_default)+" ")
    if verde: sys.stdout.write(str(color_value if verde_crescente else 255 - color_value) + " ")
    else : sys.stdout.write(str(verde_default)+" ")
    if azul: sys.stdout.write(str(color_value if azul_crescente else 255 - color_value) + " ")
    else : sys.stdout.write(str(azul_default)+" ")
    print ""
    
    if x == 3000 : input('pausa pro cafe')
    

------------------  ComparadorDatasSemeaduraColheita.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Apr 8, 2015

@author: Paloschi
'''
from Modelo.beans.AbstractData import SERIAL_FILE_DATA, FILE_DATA
from numpy.core.numeric import array
import gdal
from Modelo.Funcoes import AbstractFunction
progress = gdal.TermProgress_nocb   
import matplotlib.pyplot as plt   

class ComparadorSemeaduraColheita(AbstractFunction.Function):
    '''
        ESSA FUNCAO NAO TA PRONTA
    '''

    def __setParamIN__(self): # Arrumar descrições
        #self.descriptionIN["nome_atributo"] = {"Required":True, "Type":FILE_DATA, "Description":"um arquivo qualquer requerido"}
        
        self.descriptionIN["images_colheita_estimada"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para procurar as datas"}
        self.descriptionIN["imagem_semeadura_estimada"] = "parametro para avanco de semeadura (Default: 0)"
        self.descriptionIN["imagem_colheita_produtor"] = "parametro para avanco de colheita (Default: 0)"
        self.descriptionIN["imagem_semeadura_produtor"] = "intervalo para procura da data nas imagens ex.: 3-24"
     
    def __setParamOUT__(self):
        self.descriptionOUT["txt_comparacao"] = "imagem com as datas de semeadura" 
        
    def __execOperation__(self):
        
        images_super = self.brutedata["images"]
        avanco_semeadura = self.paramentrosIN_carregados["avanco_semeadura"]
        avanco_colheita = self.paramentrosIN_carregados["avanco_colheita"]
        
        intervalo_semeadura = self.paramentrosIN_carregados["intervalo_semeadura"]
        intervalo_pico = self.paramentrosIN_carregados["intervalo_pico"]
        intervalo_colheita = self.paramentrosIN_carregados["intervalo_colheita"]
        
        intervalo_semeadura = intervalo_semeadura.split("-")
        intervalo_pico = intervalo_pico.split("-")
        intervalo_colheita = intervalo_colheita.split("-")
        
        images = images_super.loadData()
        
        n_linhas = len(images[0])
        n_colunas = len(images[0][0])
        nullValue = images[0][0][0]
        
        imagem_referencia = [[0 for x in range(n_colunas)] for x in range(n_linhas)]  
        
        imagem_semeadura = array(imagem_referencia)#.astype(dtype="int16")
        imagem_colheita = array(imagem_referencia)#.astype(dtype="int16")
        imagem_pico = array(imagem_referencia)#.astype(dtype="int16")
        
        progress( 0.0)
        
        for i_linhas in range(0, n_linhas):
            progress(i_linhas/float(n_linhas))
            #if i_linhas/float(n_linhas) > 0.15 : break
            for i_coluna in range(0, n_colunas):
                
                line = list()

                if nullValue == images[1][i_linhas][i_coluna] :
                    imagem_semeadura[i_linhas][i_coluna] = 0
                    
                else:              
                    for img in images:
                        line.append(img[i_linhas][i_coluna])
                    
                    pico = self.findPeakHelper(line, int(intervalo_pico[0]), int(intervalo_pico[1])) # 3 - 23
                    
                    imagem_pico[i_linhas][i_coluna] = pico
                      
                    low1 = self.findLowPeakHelper(line, int(intervalo_semeadura[0]), int(intervalo_semeadura[1])) # 6 - 23
                    low2 = self.findLowPeakHelper(line, int(intervalo_colheita[0]), int(intervalo_colheita[1])) # 11 - 34
                    
                    plt.plot([low1, low2], [line[low1], line[low2]], "ro")
                    
                    plt.plot([pico], [line[pico]], "yo")
                    
                    dSemeadura1 = pico - low1  
                    dColheita1 = low2 - pico
                    
                    acrecimoSemeadura1 = dSemeadura1 - avanco_semeadura
                    acrecimoColheita1 = dColheita1 - avanco_colheita
                    
                    cenaSemeadura1 = low1 + acrecimoSemeadura1
                    imagem_semeadura[i_linhas][i_coluna] = cenaSemeadura1
            
                    cenaColheita1 = low2 + acrecimoColheita1
                    imagem_colheita[i_linhas][i_coluna] = cenaColheita1
                    
                    plt.plot(line)
                    
                    #valorSemeadura1 = self.valorPixelLinha(cenaSemeadura1, line)
                    #valorColheita1 = self.valorPixelLinha(cenaColheita1, line)
                      
        plt.show()
        
        saida = Dados.TableData()
        
        imagem_semeadura = Dados.SimFileDatata=imagem_semeadura)
        imagem_semeadura.data_metadata = images_super[0].data_metadata
        imagem_semeadura.data_name = "semeadura"
        
        imagem_colheita = Dados.SimFileDatata=imagem_colheita)
        imagem_colheita.data_metadata = images_super[0].data_metadata
        imagem_colheita.data_name = "colheita"
        
        imagem_pico = Dados.SimFileDatata=imagem_pico)
        imagem_pico.data_metadata = images_super[0].data_metadata
        imagem_pico.data_name = "pico"
        
        saida["imagem_semeadura"] = imagem_semeadura
        saida["imagem_colheita"] = imagem_colheita
        saida["imagem_pico"] = imagem_pico
        
        return saida
    
    def findPeakHelper(self,num,start,end):
        mid = (start+end)/2
        if mid>start and mid < end:
            if(num[mid-1]<num[mid] and num[mid]>num[mid+1]):
                return mid
            if(num[mid-1]>num[mid]):
                return self.findPeakHelper(num,start,mid)
            else:
                return self.findPeakHelper(num,mid,end)
        else:
            if num[mid]>num[mid+1]:
                return mid
            else:return mid+1

    def findLowPeakHelper(self,num,start,end):
        mid = (start+end)/2
        if mid>start and mid < end:
            if(num[mid-1]>num[mid] and num[mid]<num[mid+1]):
                return mid
            if(num[mid-1]<num[mid]):
                return self.findLowPeakHelper(num,start,mid)
            else:
                return self.findLowPeakHelper(num,mid,end)
        else:
            if num[mid]>num[mid+1]:
                return mid
            else:return mid+1

    def valorPixelLinha(self, cena, vetor):
        if (cena - int(cena) > 0):
            #if (vetor[int(cena)+1] - vetor[int(cena)]) > 0:
                valor = vetor[int(cena)] + ((vetor[int(cena)+1] - vetor[int(cena)]) * (cena - int(cena)))
            #else:
             #   valor = vetor[int(cena)] + ((vetor[int(cena)] - vetor[int(cena)+1]) * (cena - int(cena)))
                
        elif (cena - int(cena) < 0):  
            #if  (vetor[int(cena)] - vetor[int(cena)-1]) > 0:
                valor = vetor[int(cena)] + ((vetor[int(cena)] - vetor[int(cena)-1]) * (cena - int(cena)))
            #else:
            #    valor = vetor[int(cena)] + ((vetor[int(cena)-1] - vetor[int(cena)]) * (cena - int(cena)))
        else:
            valor = vetor[int(cena)]
        return valor

    
line = ComparadorSemeaduraColheita()

root_ = "C:\\Users\\Paloschi\\Desktop\\data\\AjusteModeloDSDC\\3.EVI_Flat_Propriedades_SavitsGolay\\"
images = Dados.ListData()

images.loadListByRoot(root_, "tif")

parametrosIN = Dados.TableData()

parametrosIN["images"] = images
parametrosIN["avanco_semeadura"] = Dados.SimFileDatata=0)
parametrosIN["avanco_colheita"] = Dados.SimFileDatata=0)
parametrosIN["intervalo_pico"] = Dados.SimFileDatata="8-22")
parametrosIN["intervalo_semeadura"] = Dados.SimFileDatata="0-14")
parametrosIN["intervalo_colheita"] = Dados.SimFileDatata="14-27")

line.data = parametrosIN
imagens = line.data

semeadura = imagens["imagem_semeadura"]
colheita = imagens["imagem_colheita"]
pico = imagens["imagem_pico"]

semeadura.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\AjusteModeloDSDC\\4.ImagensLowEpico\\", ext=".tif")
colheita.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\AjusteModeloDSDC\\4.ImagensLowEpico\\", ext=".tif")
pico.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\AjusteModeloDSDC\\4.ImagensLowEpico\\", ext=".tif")






------------------  ConDecendial2Diario.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 09/11/2015

@author: Rennan
'''
from Controle import AbstractController
from Modelo.Funcoes.RasterTools import Decendial2Diario
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles

class Controller(AbstractController.Controller):
    '''
    classdocs
    '''
    
    serie_entrada_decendial = None
    serie_saida_diaria = None
    
    def setSerieEntrada(self):
        imagens = self.getSerieTemporal(self.serie_entrada_decendial)
        if imagens is not None:
            self.serie_entrada_decendial = imagens
            self.ui.chDiario.setCheckState(True)
    
    def setSerieSaida(self):
        imagens = self.getSerieTemporal(self.serie_saida_diaria)
        if imagens is not None:
            self.serie_saida_diaria = imagens
            self.ui.chDecendial.setCheckState(True)

    def executa(self):
        
        #self.serie_entrada_decendial = SerialTemporalFiles()
        #self.serie_entrada_decendial.root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\7-Cortado_tamanho_Modis\\PPP"
        #self.serie_entrada_decendial.prefixo = "rain_"
        #self.serie_entrada_decendial.date_mask = "%Y%m%d"
        #self.serie_entrada_decendial.mutiply_factor = 0.01

        #self.serie_saida_diaria = SerialTemporalFiles()
        #self.serie_saida_diaria.root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\8-Diario\\PPP"
        #self.serie_saida_diaria.prefixo = "rain_"
        #self.serie_saida_diaria.date_mask = "%Y%m%d"
        #self.serie_saida_diaria.mutiply_factor = 1
                
        self.function = Decendial2Diario.Funcao()
        
        param = TableData()
        param["In"] = self.serie_entrada_decendial
        param["Out_config"] = self.serie_saida_diaria
        param["Operation"] = str(self.ui.cbOperacao.currentText())
        
        print "executar"
        resultado = self.function.executar(param)
        
        if self.funcao_cancelada():
            print "controller cancelando"
            self.console(u"Função interrompida.")
            self.finalizar()
        else :
            self.console(u"Função terminada")
            self.finalizar()
        
        return resultado
        
 
    def valida_form(self):
        
        return True
        
        if self.serie_entrada_decendial is None:
            return False
        if self.serie_saida_diaria is None:
            return False
        
        return True    
    
    
    def parametros_teste(self):
        root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\7.1-MultiplicadasPelaMascaraSoja11-12\\evpt"
        self.serie_entrada_decendial = SerialTemporalFiles()
        self.serie_entrada_decendial.root_path = root_path
        self.serie_entrada_decendial.prefixo = "evpt_"
        self.serie_entrada_decendial.mutiply_factor = 1
        self.serie_entrada_decendial.date_mask = "%Y%m%d"
        
        root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\8-Diario\\EVPT\\novo"
        self.serie_saida_diaria = SerialTemporalFiles()
        self.serie_saida_diaria.root_path = root_path
        self.serie_saida_diaria.prefixo = "evpt_diario_"
        self.serie_saida_diaria.mutiply_factor = 100

        self.serie_saida_diaria.date_mask = "%Y-%m-%d"
        
 

------------------  ConDistribuidorDeIndice.py  ------------------
# -*- coding: utf-8 -*-

'''
Created on 19/10/2015

@author: Rennan
'''
from Controle.AbstractController import Controller
from Modelo.Funcoes.BalancoHidrico import Distribuidor_IC_2
from Modelo.beans import TableData, RasterFile
from PyQt4 import QtCore, QtGui
import os
import threading


try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Controller(Controller):
    
    def addEstagio(self):
        numero_de_linhas = self.ui.tableWidget.rowCount()
        ultimo_dia = str(self.ui.tableWidget.item(numero_de_linhas-1, 1).text())
        dia_inicial = str(self.ui.tableWidget.item(numero_de_linhas-1, 0).text())
        valor = str(self.ui.tableWidget.item(numero_de_linhas-1, 2).text())
        
        ultimo_dia_int = 0
        
        try :
            ultimo_dia_int = int(ultimo_dia)
            float(valor)
        except:
            self.message(u"Preencha corretamente o Estádio anterior")
            return
            
        if(ultimo_dia_int<=int(dia_inicial)):
            self.message(u"O dia final do Estádio anterior precisa ser maior que o inicial")
            return
        else:
            i_nova_linha = numero_de_linhas
            self.ui.tableWidget.setRowCount(i_nova_linha + 1)
            
            item = QtGui.QTableWidgetItem()
            self.ui.tableWidget.setVerticalHeaderItem(i_nova_linha, item)
            
            item = self.ui.tableWidget.verticalHeaderItem(i_nova_linha)
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            item.setText(_translate("Dialog", ("Estádio " + str(i_nova_linha+1)), None))
            
            item = QtGui.QTableWidgetItem()
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.ui.tableWidget.setItem(i_nova_linha, 0, item)
            
            item = self.ui.tableWidget.item(i_nova_linha, 0)
            item.setText(_translate("Dialog", str(ultimo_dia), None)) 
            
            item = QtGui.QTableWidgetItem()
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.ui.tableWidget.setItem(i_nova_linha, 1, item)     

            item = QtGui.QTableWidgetItem()
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.ui.tableWidget.setItem(i_nova_linha, 2, item)   
            
            item = self.ui.tableWidget.item(i_nova_linha-1, 1)
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)

            item = self.ui.tableWidget.item(i_nova_linha-1, 2)
            item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            
    def remEstagio(self):
        numero_de_linhas = self.ui.tableWidget.rowCount()
        if numero_de_linhas > 1 :
            self.ui.tableWidget.setRowCount(numero_de_linhas - 1)
            
            item = self.ui.tableWidget.item(numero_de_linhas -2, 1)
            item.setFlags(QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
            
            item = self.ui.tableWidget.item(numero_de_linhas -2, 2)
            item.setFlags(QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled) 
            
            
    def findImgColheita(self):
        self.findPath(self.ui.txImgColheita)
    
    def findImgSemeadura(self):
        self.findPath(self.ui.txImgSemeadura)
    
    def findOutFolder(self):
        self.findPath(self.ui.txOutFolder, "folder")
    
    def changeDefaultIndices(self):
        self.ui.tableWidget.setRowCount(1)
        
        op_selected = str(self.ui.comboBox.currentText())
        
        if (op_selected=="Kc FAO - Soja"):
        
            self.ui.tableWidget.item(0, 1).setText("10") 
            self.ui.tableWidget.item(0, 2).setText("0.4") 
            
            self.addEstagio()
            self.ui.tableWidget.item(1, 1).setText("50") 
            self.ui.tableWidget.item(1, 2).setText("0.8")      
    
            self.addEstagio()
            self.ui.tableWidget.item(2, 1).setText("85") 
            self.ui.tableWidget.item(2, 2).setText("1.15") 
    
            self.addEstagio()
            self.ui.tableWidget.item(3, 1).setText("125") 
            self.ui.tableWidget.item(3, 2).setText("0.8") 
    
            self.addEstagio()
            self.ui.tableWidget.item(4, 1).setText("140") 
            self.ui.tableWidget.item(4, 2).setText("0.5")  
        
        else :
            
            self.ui.tableWidget.item(0, 1).setText("10") 
            self.ui.tableWidget.item(0, 2).setText("0.1") 
            
            self.addEstagio()
            self.ui.tableWidget.item(1, 1).setText("50") 
            self.ui.tableWidget.item(1, 2).setText("0.25")      
    
            self.addEstagio()
            self.ui.tableWidget.item(2, 1).setText("140") 
            self.ui.tableWidget.item(2, 2).setText("0.6") 
            
    def valida_form(self):
        if not os.path.exists(self.ui.txImgSemeadura.text()):
            self.message(u"Imagem de semeadura não encontrada")
            return False        
        if not os.path.exists(self.ui.txImgColheita.text()):
            self.message(u"Imagem de colheita não encontrada")
            return False
        if not os.path.exists(self.ui.txOutFolder.text()):
            self.message(u"Pasta de saída não encontrada") 
            return False
            
        numero_de_linhas = self.ui.tableWidget.rowCount()
        ultimo_dia = str(self.ui.tableWidget.item(numero_de_linhas-1, 1).text())
        dia_inicial = str(self.ui.tableWidget.item(numero_de_linhas-1, 0).text())   
        valor = str(self.ui.tableWidget.item(numero_de_linhas-1, 2).text())
        
        ultimo_dia_int = 0
        try :
            ultimo_dia_int = int(ultimo_dia)
            float(valor) # testa se é possivel converter o ultimo valor pra float
        except:
            self.message(u"Preencha corretamente o último período")
            return False
            
        if(ultimo_dia_int<=int(dia_inicial)):
            self.message(_translate("O dia final do Estádio anterior precisa ser maior que o inicial"))
            return False
            
            #self.message(_translate("MainWindow","Verifique na pasta de saída se as imagens estão sendo criadas, "+
                    #     "as imagens poderão demorar até 10 minutos para aparecerem (com 5 milhões de pixels por imagem).", None))
        return True

                 
    def executa(self):
        
        self.print_text(u"Configurando função")
        
        #self.progress_bar.btnCancelar.setEnabled(False)
        #self.progress_bar.progressBar.setMaximum(0)
        
        self.function = Distribuidor_IC_2.DistribuidorKC_() #função utilizada por este contrlolador
        
        self.function.console = self.console
        self.function.print_text = self.print_text
        
       # print ("Controller -------------------------------")
        
        '''
            Organizando tabela de kc em tabela para passar para a funcao
        '''
        numero_de_linhas = self.ui.tableWidget.rowCount()
        Kc = TableData()
        
        #print("numero de linhas", numero_de_linhas)
        
        for i in range(0, numero_de_linhas-1):
            dia_inicio = str(self.ui.tableWidget.item(i, 0).text())
            dia_fim = str(self.ui.tableWidget.item(i, 1).text())
            valor =  float(str(self.ui.tableWidget.item(i, 2).text()))
            key = dia_inicio+"-"+dia_fim
            Kc[key] = valor
            #print (key)
            #print (valor)
        

        #print ("Controller -------------------------------")
        '''
            Montando objetos raster referentes as imagens de semeadura e colheita para passar para a funcao
        '''
        semeadura = RasterFile(file_full_path = str(self.ui.txImgSemeadura.text()))
        colheita = RasterFile(file_full_path = str(self.ui.txImgColheita.text()))
        OutFolder = str(self.ui.txOutFolder.text())
        multply_factor = self.ui.txMultiplyFactor.value()
        
        '''
            Montando tabela com os parametros para a funcao
        '''
        paramIN = TableData()
        paramIN["Kc"] = Kc
        paramIN["semeadura"] = semeadura
        paramIN["colheita"] = colheita
        paramIN["path_out"] = OutFolder
        paramIN["multply_factor"] = multply_factor
        
        '''
            Executa a função
        '''
        self.print_text(u"Distribuindo índice")
        resultado = self.function.executar(paramIN)
        '''
            Verifica o que aconteceu com o processo
        '''
        if self.funcao_cancelada() : return None
        elif resultado == None :
            self.print_text(u"erro deconhecido, função interrompida")
            threading.currentThread().stop()
            self.finalizar()
        else : 
            self.print_text(u"função concluída")
            self.progress_bar.progressBar.setMaximum(100)
            threading.currentThread().stop()
            self.finalizar()
        
        
        

------------------  ConDr.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 11/11/2015

@author: Rennan
'''
from Controle import AbstractController
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles
from Modelo.Funcoes.BalancoHidrico.BHFAO.Dr import Dr
import os.path as path
from Modelo.beans import RasterData

class Controller(AbstractController.Controller):
    
    serie_ETc = None
    serie_PPP = None
    serie_TAW = None
    serie_Dr = None

    def findImgCAD(self):
        self.findPath(self.ui.txImgCAD)

    def setSeriePPP(self):
        imagens = self.getSerieTemporal(self.serie_PPP)
        if imagens is not None:
            self.serie_PPP = imagens
            self.ui.chPPP.setCheckState(True)

    def setSerie_ETc(self):
        imagens = self.getSerieTemporal(self.serie_ETc)
        if imagens is not None:
            self.serie_ETc = imagens
            self.ui.chEtc.setCheckState(True)

    def setSerie_TAW(self):
        imagens = self.getSerieTemporal(self.serie_TAW)
        if imagens is not None:
            self.serie_TAW = imagens
            self.ui.chTAW.setCheckState(True)

    def setSerie_Dr(self):
        imagens = self.getSerieTemporal(self.serie_Dr)
        if imagens is not None:
            self.serie_Dr = imagens
            self.ui.chDr.setCheckState(True)
    
    def executa(self):
        self.function = Dr()
        
        parametros = TableData()
        parametros["Etc"] = self.serie_ETc
        parametros["PPP"] = self.serie_PPP
        parametros["TAW"] = self.serie_TAW
        parametros["Dr"] = self.serie_Dr
        parametros["CAD"] = RasterData.RasterFile(file_full_path=str(self.ui.txImgCAD.text()))
        
        resultado = self.function.executar(parametros)
        
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            self.finalizar()

    def valida_form(self):
        if self.serie_ETc == None :
            self.message(u"Série de imagens de ETc não configurada.")
            return False
        elif self.serie_PPP == None:
            self.message(u"Série de imagens de PPP não configurada.")
            return False
        elif self.serie_TAW == None:
            self.message(u"Série de imagens de TAW não configurada.")
            return False
        elif self.serie_Dr == None:
            self.message(u"Série de imagens de Dr não configurada.")
            return False
        elif not path.exists(str(self.ui.txImgCAD.text())):
            self.message(u"Imagem CAD não encontrada.")
            return False
        return True

    def parametros_teste(self):
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\3-ETc"
        self.serie_ETc = SerialTemporalFiles()
        self.serie_ETc.root_path = root_path
        self.serie_ETc.prefixo = "etc_"
        self.serie_ETc.date_mask = "%Y-%m-%d"     
        self.serie_ETc.mutiply_factor = 0.01
        
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\1-ECMWF\\Precipitacao"
        self.serie_PPP = SerialTemporalFiles()
        self.serie_PPP.root_path = root_path
        self.serie_PPP.prefixo = "rain_diario_"
        self.serie_PPP.mutiply_factor = 0.01
        self.serie_PPP.date_mask = "%Y-%m-%d"
        
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\3-TAW"
        self.serie_TAW = SerialTemporalFiles()
        self.serie_TAW.root_path = root_path
        self.serie_TAW.prefixo = "TAW_"
        self.serie_TAW.mutiply_factor = 1
        self.serie_TAW.date_mask = "%Y%m%d"
        
        self.ui.txImgCAD.setText("C:\\Gafanhoto WorkSpace\\Soja11_12\\Mapa_solo\\soloVSMascaraSoja11_12.tif")
        
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\4-Dr"
        self.serie_Dr = SerialTemporalFiles()
        self.serie_Dr.root_path = root_path
        self.serie_Dr.prefixo = "dr_"
        self.serie_Dr.mutiply_factor = 100

        self.serie_Dr.date_mask = "%Y-%m-%d"  
        

------------------  ConEstatisticasEspectrais.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jun 10, 2015

@author: Paloschi
'''

from Modelo.Funcoes.Estatisticos import SpectreStatisticalStractor
from Modelo.beans import SerialFile, TableData
from Controle import AbstractController
import os.path as path

class Controller(AbstractController.Controller):
    '''
    classdocs
    '''
    
    def findInFolder(self):
        self.findPath(self.ui.leInFolder, "folder")
        
    def findOutFolder(self):
        self.findPath(self.ui.leOutFolder, "folder")
  
    def executa(self):
        
        self.function = SpectreStatisticalStractor()
        

        self.print_text(u"Organizando dados necessários")
        
        root_in = str(self.ui.leInFolder.text())
        root_in = path.normpath(root_in)
        
        imagens_entrada = SerialFile()
        imagens_entrada = imagens_entrada.loadListByRoot(root_in, "tif, img")
        
        if(len(imagens_entrada)==0):
            self.console(u"Nenhuma imagem encontrada, abortando função")
            self.finalizar()
            self.console(u"Função finalizada")
            return
        
        root_out = str(self.ui.leOutFolder.text())
        root_out = path.normpath(root_out)
        
        paramsIN = TableData()
        paramsIN["images"] = imagens_entrada
        paramsIN["statistics"] = self.statistical_list

        images_saida = self.function.executar(paramsIN)
    
        self.print_text("Salvando imagens")
        
        if self.funcao_cancelada(): 
            
            return None
        
        for imagem in images_saida :

            try:
                imagem.saveRasterData(file_path=root_out, ext="tif")   
                self.console("Imagem "+ imagem.file_name+" salva.")
            except:
                self.console(u"Não foi possivel salvar a imagem: " + imagem.file_name+ u". Verifique se o arquivo está sendo usado por outro aplicativo.")
            
        self.print_text(u"Conluído.")
        self.finalizar()
        
        
    def valida_form(self):

        if not path.exists(str(self.ui.leInFolder.text())):
            self.message(u"Pasta de entrada nao encontrada")   
            return False     
        if not path.exists(str(self.ui.leOutFolder.text())):
            self.message(u"Pasta de saída nao encontrada")
            return False
        
        self.statistical_list = list()
        
        if self.ui.cbMax.isChecked() : self.statistical_list.append("max")
        if self.ui.cbMedia.isChecked() : self.statistical_list.append("media")
        if self.ui.cbMediana.isChecked() : self.statistical_list.append("mediana")
        if self.ui.cbMin.isChecked() : self.statistical_list.append("min")
        if self.ui.cbAmplitude.isChecked() : self.statistical_list.append("amplitude")
        if self.ui.cbSD.isChecked() : self.statistical_list.append("sd")
        if self.ui.cbSoma.isChecked() : self.statistical_list.append("soma")
        if self.ui.cbCV.isChecked() : self.statistical_list.append("cv")

        if len(self.statistical_list) == 0 :
            self.message(u"Selecione pelo menos uma opção na aba Configuração")
            return False
        
        return True
    
    def parametros_teste(self):
            self.ui.leInFolder.setText("C:\\Users\\Paloschi\\Desktop\\teste\\")
            self.ui.leOutFolder.setText("C:\\Users\\Paloschi\\Desktop\\")
    


------------------  ConEstimativaDatasCultura.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jun 10, 2015

@author: Paloschi
'''

from Modelo.Funcoes.BalancoHidrico import ExtratorSemeaduraColheita
from Modelo.beans import SerialFile, TableData
from Controle import AbstractController
from numpy import double
import os.path

#try:
#    _fromUtf8 = QtCore.QString.fromUtf8
#except AttributeError:
#    def _fromUtf8(s):
#        return s
    
class Controller(AbstractController.Controller):
    
    def findInFolder(self):
        self.findPath(self.ui.leInFolder, "folder")
        
    def findOutFolder(self):
        self.findPath(self.ui.leOutFolder, "folder")
  
    def executa(self):
        
        self.function = ExtratorSemeaduraColheita()
        self.function.print_text = self.print_text
        
        root_out = str(self.ui.leOutFolder.text())
        root_in = str(self.ui.leInFolder.text())
        
        parametrosIN = TableData()
        images = SerialFile(root_path=root_in)
        parametrosIN["images"] = images
        parametrosIN["avanco_semeadura"] = double(self.ui.dspASemeadura.value())
        parametrosIN["avanco_colheita"] = double(self.ui.dsbAColheita.value())
        parametrosIN["intervalo_pico"] = str(self.ui.lePPico.text())
        parametrosIN["intervalo_semeadura"] = str(self.ui.lePSemeadura.text())
        parametrosIN["intervalo_colheita"] = str(self.ui.lePColheita.text())
        parametrosIN["null_value"] = double(self.ui.leNullValue.text())
        parametrosIN["prefixo"] = str(self.ui.lePrefixo.text())
        parametrosIN["sufixo"] = str(self.ui.leSufixo.text())
        parametrosIN["mask"] = str(self.ui.leMascara.text())
        
        images = self.function.executar(parametrosIN)
        
        if self.funcao_cancelada() : return
        
        self.print_text(u"Salvando imagens.")
        
        semeadura = images["imagem_semeadura"]
        semeadura.file_name = self.ui.leImgSemeadura.text()
        semeadura.file_path = str(self.ui.leOutFolder.text())
        semeadura.file_ext = "tif"
        semeadura.saveRasterData()
        
        colheita = images["imagem_colheita"]
        colheita.file_name = self.ui.leImgColheita.text()
        colheita.file_path = str(self.ui.leOutFolder.text())
        colheita.file_ext = "tif"
        colheita.saveRasterData()
        
        pico = images["imagem_pico"]
        pico.file_name = self.ui.leImgPico.text()
        pico.file_path = str(self.ui.leOutFolder.text())
        pico.file_ext = "tif"
        pico.saveRasterData()
        
        
        self.print_text("Terminado.")        
        self.finalizar()

    def valida_form(self):

        if not os.path.exists(self.ui.leInFolder.text()):
            self.message(u"Pasta de entrada das imagens não encontrada, verifique o endereço.")
            return False   
        if not os.path.exists(self.ui.leOutFolder.text()):
            self.message(u"Pasta de saida das imagens não encontrada, verifique o endereço.")
            return False    
        if str(self.ui.lePPico.text()) == "" : 
            self.message(u"Preencha o intervalo para as imagens de pico (ex.: 10-20).")
            return False
        if str(self.ui.lePSemeadura.text()) == "" : 
            self.message(u"Preencha o intervalo para as imagens de semeadura (ex.: 20-30).")
            return False
        if str(self.ui.lePColheita.text()) == "" : 
            self.message(u"Preencha o intervalo para as imagens de colheita (ex.: 30-40).")
            return False
        if str(self.ui.leMascara.text())  == "" : 
            self.message(u"É necessário informar uma máscara, (ex.: %Y%m%d).")
            return False    
   
        return True


------------------  ConEtc.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 11/11/2015

@author: Rennan
'''
from Controle import AbstractController
from Modelo.Funcoes.BalancoHidrico import Etc
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles
class Controller(AbstractController.Controller):
    
    serie_ET0 = None
    serie_ETc = None
    serie_Kc = None
    
    etc = True
    
    def MudaPraETc(self):
        self.ui.label_5.setText(u"Imagens diárias de ETc")
        self.ui.label_2.setText(u"Imagens diárias de ET0")
        self.ui.label_3.setText(u"Imagens diárias de Kc")
        self.etc = True
    
    def MudaPraETa(self):
        self.ui.label_5.setText(u"Imagens diárias de ETa")
        self.ui.label_2.setText(u"Imagens diárias de Ks")
        self.ui.label_3.setText(u"Imagens diárias de ETc")
        self.etc = False

    def setSerieET0(self):
        imagens = self.getSerieTemporal(self.serie_ET0)
        if imagens is not None:
            self.serie_ET0 = imagens
            self.ui.chET0.setCheckState(True)

    def setSerie_ETc(self):
        imagens = self.getSerieTemporal(self.serie_ETc)
        if imagens is not None:
            self.serie_ETc = imagens
            self.ui.chETc.setCheckState(True)

    def setSerie_Kc(self):
        imagens = self.getSerieTemporal(self.serie_Kc)
        if imagens is not None:
            self.serie_Kc = imagens
            self.ui.chKc.setCheckState(True)
    
    def executa(self):
        self.function = Etc()
        
        parametros = TableData()
        parametros["ET0"] = self.serie_ET0
        parametros["Kc"] = self.serie_Kc
        parametros["ETc"] = self.serie_ETc
        
        resultado = self.function.executar(parametros)
        
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            self.finalizar()

    def valida_form(self):
        
        if self.etc :
            if self.serie_ET0 is None :
                self.message(u"Série de imagens de ET0 não configurada.")
                return False
            elif self.serie_Kc is None:
                self.message(u"Série de imagens de Kc não configurada.")
                return False
            elif self.serie_ETc is None:
                self.message(u"Série de imagens de ETc não configurada.")
                return False
        else :
            if self.serie_ET0 is None :
                self.message(u"Série de imagens de Etc não configurada.")
                return False
            elif self.serie_Kc is None:
                self.message(u"Série de imagens de Ks não configurada.")
                return False
            elif self.serie_ETc is None:
                self.message(u"Série de imagens de ETa não configurada.")
                return False           
        return True

    def parametros_teste(self):
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\5-Ks"
        self.serie_ET0 = SerialTemporalFiles()
        self.serie_ET0.root_path = root_path
        self.serie_ET0.prefixo = "Ks_"
        self.serie_ET0.mutiply_factor = 0.01
        self.serie_ET0.date_mask = "%Y-%m-%d"
        
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\3-ETc"
        self.serie_Kc = SerialTemporalFiles()
        self.serie_Kc.root_path = root_path
        self.serie_Kc.prefixo = "etc_"
        self.serie_Kc.mutiply_factor = 0.01
        self.serie_Kc.date_mask = "%Y-%m-%d"
        
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\6-Eta2"
        self.serie_ETc = SerialTemporalFiles()
        self.serie_ETc.root_path = root_path
        self.serie_ETc.prefixo = "eta_"
        self.serie_ETc.date_mask = "%Y-%m-%d"    
        self.serie_ETc.mutiply_factor = 100    
        

------------------  ConFiltroSavitzGolay.py  ------------------
# -*- coding: utf-8 -*-

'''
Created on Jun 10, 2015

@author: Paloschi
'''
from PyQt4.QtGui import QFileDialog
from Modelo.Funcoes.Filtros import FiltroSavitz
from Modelo.beans import TableData, SerialFile
from PyQt4 import QtCore
from Controle import AbstractController
import os

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s
    
class Controller(AbstractController.Controller):
    
    def findInFolder(self):
        self.findPath(self.ui.leInFolder, "folder")
        
    def findOutFolder(self):
        self.findPath(self.ui.leOutFolder, "folder")         
        
    def executa(self):
        
        self.function = FiltroSavitz()
        
        self.function.console = self.print_text
        
        self.print_text(u"Inicializando filtro.")
        
        root_out = self.ui.leOutFolder.text()
        root_out = _fromUtf8(str(root_out) + "\\")
        root_out = str(root_out).replace("\\", "/")
        
        parametrosIn = self.carregarParamIN()
        
        self.print_text(u"Filtrando imagens...")
        imagens_filtradas = self.function.executar(parametrosIn)
        
        if self.funcao_cancelada() : return None
        elif imagens_filtradas == None :
            self.print_text(u"Erro desconhecido.")
            self.finalizar()
        else :
            imagens_filtradas.saveListByRoot(root_path=root_out, ext="tif") 
            self.print_text(u"Função concluída")
        
    def carregarParamIN(self):
        
        images = SerialFile()
        parametrosIN = TableData()
        root_in = self.ui.leInFolder.text()
        root_in = _fromUtf8(str(root_in) + "\\")
        root_in = str(root_in).replace("\\", "/")

        images.loadListByRoot(root_in)
        self.print_text(u"Numero de imagens encontradas:" + str(len(images)))
        
        parametrosIN["images"] = images
        
        conf_algoritimo = TableData()
        conf_algoritimo["window_size"] = self.ui.leWindowSize.text()
        conf_algoritimo["order"] = self.ui.leOrdem.text()
        #if self.ui.checkBox.isChecked() : conf_algoritimo["null_value"] = double(self.ui.leNullValue.text())
        #else : conf_algoritimo["null_value"] = FileData(data= None)
        
        parametrosIN["conf_algoritimo "] = conf_algoritimo
        
        return parametrosIN
    
    def valida_form(self):
        
        if not os.path.exists(self.ui.leInFolder.text()):
            self.message(u"Pasta de entrada das imagens não encontrada, verifique o endereço.")
            return False   
        if not os.path.exists(self.ui.leOutFolder.text()):
            self.message(u"Pasta de saida das imagens não encontrada, verifique o endereço.")
            return False 
        return True
           

------------------  ConInvdistnnRaster2Raster.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 13/10/2015

@author: Rennan
'''
from Modelo.Funcoes.RasterTools import RasterToCSVeVRT
from Modelo.Funcoes.Interpoladores import IDW
from Modelo.beans import SerialFile, TableData
from PyQt4 import QtCore
from Controle import AbstractController
import os.path
from Modelo.beans.RasterData import RasterFile

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

class Controller(AbstractController.Controller):
    '''
    classdocs
    
    '''
    def findInFolder(self):
        self.findPath(self.ui.txInFolder, "folder")
        
    def findOutFolder(self):
        self.findPath(self.ui.txOutFolder, "folder")
  
    def findImgRef(self):
        self.findPath(self.ui.txImgReference)

    def valida_form(self):
        if not os.path.exists(self.ui.txInFolder.text()):
            self.message(u"Pasta de entrada das imagens não encontrada, verifique o endereço.")
            return False   
        if not os.path.exists(self.ui.txOutFolder.text()):
            self.message(u"Pasta de saida das imagens não encontrada, verifique o endereço.")
            return False
        if not os.path.exists(self.ui.txImgReference.text()):
            self.message(u"Imagem de referencia das imagens não encontrada, verifique o endereço.")
            return False     
        return True

    def executa(self):
        
        '''
            Criando arquivos CSVs e VRTs para submeter a interpolação
        '''
        
        self.print_text(u'Criando arquivos necessários para a interpolação')
        
        self.function = RasterToCSVeVRT()
        paramIn = TableData()
        paramIn["images"] = SerialFile(root_path=str(self.ui.txInFolder.text()))
        paramIn["out_folder"] = str(self.ui.txOutFolder.text())
          
        
        
        resultado = self.interpolar_todas_as_imagens(paramIn)
            
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função concluída")
            self.finalizar()
    
    def interpolar_todas_as_imagens(self, paramIn):
        
        self.print_text(u"Lendo imagens e criando arquivos para a interpolação")
    
        resposta = self.function.executar(paramIn)
        if self.funcao_cancelada() : return
        
        CSVs = resposta["CSVs"]
        VRTs = resposta["VRTs"]
        
        self.print_text("Numero de imagens identificadas para interpolar: " + str(len(CSVs)))
        
        conf_algoritimo = TableData()
        conf_algoritimo["power"] = str(self.ui.txPower.value())
        conf_algoritimo["radius"] = str(self.ui.txRadius.value())
        conf_algoritimo["max_points"] = str(self.ui.txMaxPoint.value())
        conf_algoritimo["min_points"] = str(self.ui.txMinPoint.value())
        
        conf_img_out = RasterFile(file_full_path=str(self.ui.txImgReference.text())).getRasterInformation()
        
        for i in range(len(CSVs)):
            
            resultado = None
            
            img_out = RasterFile(file_full_path=VRTs[i].file_full_path)
            img_out.file_ext = "tif"           
            
            paramIn = TableData()
            paramIn["csv"] = CSVs[i]
            paramIn["vrt"] = VRTs[i]
            paramIn["img_out_config"] = conf_img_out
            paramIn["conf_algoritimo"] = conf_algoritimo
            paramIn["img_out"] = img_out
            
            self.function = IDW()
            
            self.function.progresso = (float(i+1) / len(CSVs)) * 100
            
            print len(VRTs)
            print len(CSVs)
            
            #print "1----------------------------------------------------------------------------------"
            self.function.data = paramIn
            
            self.print_text("Interpolando imagens...")
            
            self.function.progresso = 0
            
            imagem_interpolada = self.function.data
            
            #print "2----------------------------------------------------------------------------------"
            
            self.print_text("Imagem interpolada: " + imagem_interpolada.file_name)
        
        return "tudo certo!"
        

    def set_param(self):
            
        self.ui.txInFolder.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\raster\\Para interpolar")
        self.ui.txOutFolder.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\out\\interpolado_no_gafanhoto")
        self.ui.txImgReference.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\raster\\rain_20110101_imagem de referencia.tif")
            
            
            
            
            
            
            
            
            


------------------  ConInvdistnnShapeEcmwf2Raster.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Mar 6, 2015

@author: Paloschi
'''
from PyQt4.QtGui import QFileDialog, QMessageBox
from Modelo.beans import TableData, FileData, VectorFile, RasterFile
from Modelo.Funcoes.VectorTools import SplitTable
from Modelo.Funcoes.Interpoladores import Interpola
import sys
from PyQt4 import QtCore, QtGui
from Controle import AbstractController
import os.path

class Controller(AbstractController.Controller):
    '''
    classdocs
    '''
    ShapeSelected = None
    ImgRefSelected = None
    
    def inicializar(self):
        
        self.ui.leImgRefPath.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\raster\\semeadura_soja_11-12.tif")
        self.ui.leShapePath.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\shape\\Contorno_Agassis_Pontos_2015.shp")
        
    def btn_FindShp_ClickAction(self):
        self.findPath(self.ui.leShapePath)

    def btn_FindImgRef_ClickAction(self):
        self.findPath(self.ui.leImgRefPath)

    def le_shapePath_ChangeAction(self):
        if (self.ShapeSelected == None):
            text = str(self.ui.leShapePath.text())
            self.ShapeSelected = VectorFile(file_full_path = text)
        else:
            self.ShapeSelected.file_full_path = self.ui.leShapePath.text()
            
        itens = self.ShapeSelected.readVectorData()["properties"].keys()
        self.ui.cbAtribute.addItems(itens)
        self.ui.cbAtribute.setEnabled(True)
        self.ui.cbAtribute.setCurrentIndex(0)
        
    def le_imgRefPath_ChangeAction(self):
        if (self.ImgRefSelected == None):
            self.ImgRefSelected = RasterFile(file_full_path = str(self.ui.leImgRefPath.text()))
        else:
            self.ImgRefSelected.file_full_path = str(self.ui.leImgRefPath.text())
        
    def cb_Atribute_ChangeAction(self):
        
        itens = self.ShapeSelected.readVectorData()["properties"].keys()   
        
        itens.remove(self.ui.cbAtribute.currentText())
        
        self.ui.lwGroupAtributes.clear()
        
        for item in itens:
        
            item = QtGui.QListWidgetItem(item)
            item.setCheckState(QtCore.Qt.Unchecked)
            self.ui.lwGroupAtributes.addItem(item)
            
        self.ui.lwGroupAtributes.setEnabled(True)
        __sortingEnabled = self.ui.lwGroupAtributes.isSortingEnabled()
        self.ui.lwGroupAtributes.setSortingEnabled(__sortingEnabled)
      
    def executa(self):
        
        print "executando.."
        
        self.function = Interpola.InterpolaTabela()
        self.function.console = self.print_text
        
        self.print_text("Executando..")
        
        separador = SplitTable()   
        dados_separador = TableData()
        atributos = list()
        
        for index in xrange(self.ui.lwGroupAtributes.count()):
            if self.ui.lwGroupAtributes.item(index).checkState() == 2:
                atributos.append(str(self.ui.lwGroupAtributes.item(index).text()))
        
        
        vector_table = self.ShapeSelected.readVectorData()
        
        dados_separador.data = {'table' : vector_table, 'atributos' : atributos}
        dados_separador.data["data_path"] = self.ui.leShapePath.text()
        
          
        dados_interpolador = TableData()
        image_information = self.ImgRefSelected.getRasterInformation()

        dados_interpolador['table_data'] = dados_separador
        dados_interpolador['atributo'] = str(self.ui.cbAtribute.currentText())
        dados_interpolador["format_image_data"] = image_information

        
        self.print_text("Interpolando")
        
        mensagem = self.function.executar(dados_interpolador)
        self.finalizar()
        

    def valida_form(self):
        if self.ShapeSelected is None:
            self.message(u"Shape para interpolação não encontrado.")
            return False   
        if self.ImgRefSelected is None:
            self.message(u"Imagem de referencia não encontrada.")
            return False   
        return True
    


------------------  ConKs.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 11/11/2015

@author: Rennan
'''
from Controle import AbstractController
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles
from Modelo.beans import RasterData
from Modelo.Funcoes.BalancoHidrico.BHFAO.Ks import Ks

class Controller(AbstractController.Controller):
    
    serie_Ks = None
    serie_RAW = None
    serie_TAW = None
    serie_Dr = None

    def setSerieRAW(self):
        imagens = self.getSerieTemporal(self.serie_RAW)
        if imagens is not None:
            self.serie_RAW = imagens
            self.ui.chRAW.setCheckState(True)

    def setSerie_Ks(self):
        imagens = self.getSerieTemporal(self.serie_Ks)
        if imagens is not None:
            self.serie_Ks = imagens
            self.ui.chKs.setCheckState(True)

    def setSerie_TAW(self):
        imagens = self.getSerieTemporal(self.serie_TAW)
        if imagens is not None:
            self.serie_TAW = imagens
            self.ui.chTAW.setCheckState(True)

    def setSerie_Dr(self):
        imagens = self.getSerieTemporal(self.serie_Dr)
        if imagens is not None:
            self.serie_Dr = imagens
            self.ui.chDr.setCheckState(True)
    
    def executa(self):
        self.function = Ks()
        
        parametros = TableData()
        parametros["RAW"] = self.serie_RAW
        parametros["TAW"] = self.serie_TAW
        parametros["Dr"] = self.serie_Dr
        parametros["Ks"] = self.serie_Ks
        
        resultado = self.function.executar(parametros)
        
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            self.finalizar()

    def valida_form(self):
        
        if self.serie_Ks == None :
            self.message(u"Série de imagens de Ks não configurada.")
            return False
        elif self.serie_RAW == None:
            self.message(u"Série de imagens de RAW não configurada.")
            return False
        elif self.serie_TAW == None:
            self.message(u"Série de imagens de TAW não configurada.")
            return False
        elif self.serie_Dr == None:
            self.message(u"Série de imagens de Dr não configurada.")
            return False
        return True

    def parametros_teste(self):
        root_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\5-Ks"
        self.serie_Ks = SerialTemporalFiles()
        self.serie_Ks.root_path = root_path
        self.serie_Ks.prefixo = "Ks_"
        self.serie_Ks.date_mask = "%Y-%m-%d"     
        self.serie_Ks.mutiply_factor = 100
        
        root_path = "E:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\RAW"
        self.serie_RAW = SerialTemporalFiles()
        self.serie_RAW.root_path = root_path
        self.serie_RAW.prefixo = "RAW_"
        self.serie_RAW.mutiply_factor = 1
        self.serie_RAW.date_mask = "%Y-%m-%d"
        
        root_path = "E:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\TAW\\soltas"
        self.serie_TAW = SerialTemporalFiles()
        self.serie_TAW.root_path = root_path
        self.serie_TAW.prefixo = "TAW_"
        self.serie_TAW.mutiply_factor = 1
        self.serie_TAW.date_mask = "%Y%m%d"
        
        root_path = "E:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\Dr"
        self.serie_Dr = SerialTemporalFiles()
        self.serie_Dr.root_path = root_path
        self.serie_Dr.prefixo = "dr_"
        self.serie_Dr.mutiply_factor = 0.01
        self.serie_Dr.date_mask = "%Y-%m-%d"  
        

------------------  ConPPR.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Nov 27, 2015

@author: rennan.paloschi
'''
from Controle import AbstractController
from Modelo.beans.SerialFileData import SerialTemporalFiles
from Modelo.Funcoes.BalancoHidrico.BHFAO import PPR
from Modelo.beans.TableData import TableData

class Controller(AbstractController.Controller):

    serie_T = None
    serie_PPR = None
    
    def setSerieT(self):
        imagens = self.getSerieTemporal(self.serie_T)
        if imagens is not None:
            self.serie_T = imagens
            self.ui.chT.setCheckState(True)

    def setSeriePPR(self):
        imagens = self.getSerieTemporal(self.serie_PPR)
        if imagens is not None:
            self.serie_PPR = imagens
            self.ui.chPPR.setCheckState(True)            
         
    def parametros_teste(self):
    
        self.serie_T = SerialTemporalFiles(root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\8-Diario\\tav")
        self.serie_T.prefixo = "tav_"  
        self.serie_T.date_mask = "%Y%m%d" 

        self.serie_PPR = SerialTemporalFiles(root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\PPR")
        self.serie_PPR.prefixo = "ppr_"  
        self.serie_PPR.date_mask = "%Y-%m-%d"      
         
    def executa(self):
        self.function = PPR.PPR()
        
        param = TableData()
        param["T"] = self.serie_T
        param["PPR"] = self.serie_PPR
        param["Cc"] = self.ui.txCc.value()
        
        resultado = self.function.executar(param)
           
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            self.finalizar()
    
    def valida_form(self):
        if self.serie_T == None :
            self.message(u"Série de imagens de Temperatura média não configurada.")
            return False
        elif self.serie_PPR == None:
            self.message(u"Série de imagens de PPR não configurada.")
            return False
        return True

------------------  ConTAW.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 11/11/2015

@author: Rennan
'''
from Controle import AbstractController
from Modelo.Funcoes.BalancoHidrico import Etc
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles, SerialFile
import os.path as path
from Modelo.Funcoes.BalancoHidrico.BHFAO.TAW import TAW
from Modelo.beans.FileData import FileData
from Modelo.beans import RasterData

class Controller(AbstractController.Controller):
    
    serie_Zr = None
    serie_TAW = None
    
    def findImgCAD(self):
        self.findPath(self.ui.txImgCAD)

    def setSerieZr(self):
        imagens = self.getSerieTemporal(self.serie_Zr)
        if imagens is not None:
            self.serie_Zr = imagens
            self.ui.chZr.setCheckState(True)

    def setSerie_TAW(self):
        imagens = self.getSerieTemporal(self.serie_TAW)
        if imagens is not None:
            self.serie_TAW = imagens
            self.ui.chTAW.setCheckState(True)
    
    def executa(self):

        self.function = TAW()
        
        parametros = TableData()
        parametros["CAD"] = RasterData.RasterFile(file_full_path=str(self.ui.txImgCAD.text()))
        parametros["Zr"] = self.serie_Zr
        parametros["TAW"] = self.serie_TAW
        
        resultado = self.function.executar(parametros)
        
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            self.finalizar()

    def valida_form(self):
        if not path.exists(str(self.ui.txImgCAD.text())):
            self.message(u"Imagem CAD não encontrada.")
            return False
        if self.serie_Zr is None :
            self.message(u"Série de imagens Zr não configurada.")
            return False
        elif self.serie_TAW is None:
            self.message(u"Série de imagens TAW não configurada.")
            return False
        return True

    def parametros_teste(self):
        
        self.ui.txImgCAD.setText("E:\\Gafanhoto WorkSpace\\Soja11_12\\Mapa_solo\\Cad_mm_250m_TamanhoZr.tif")
        
        root_path = "E:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\Zr\\soltas"
        self.serie_Zr = SerialTemporalFiles()
        self.serie_Zr.root_path = root_path
        self.serie_Zr.prefixo = ""
        self.serie_Zr.mutiply_factor = 0.01
        self.serie_Zr.date_mask = "%Y-%m-%d"
        
        root_path = "E:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\RAW"
        self.serie_TAW = SerialTemporalFiles()
        self.serie_TAW.root_path = root_path
        self.serie_TAW.prefixo = "RAW_"
        self.serie_TAW.mutiply_factor = 0.5
        self.serie_TAW.date_mask = "%Y-%m-%d"   
        

------------------  ConYaFao.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 03/12/2015

@author: Paloschi
'''
from Controle import AbstractController
from Modelo.Funcoes.BalancoHidrico.BHFAO.Ya import Ya
from Modelo.beans.TableData import TableData
from Modelo.beans.SerialFileData import SerialTemporalFiles

class Controller(AbstractController.Controller):
    
    serie_ETa = None
    serie_ETc = None
    serie_Yx = None
    serie_Ya = None
    serie_Kc = None
    
    def setSerie_ETa(self):
        imagens = self.getSerieTemporal(self.serie_ETa)
        if imagens is not None:
            self.serie_ETa = imagens
            self.ui.chETa.setCheckState(True)

    def setSerie_ETc(self):
        imagens = self.getSerieTemporal(self.serie_ETc)
        if imagens is not None:
            self.serie_ETc = imagens
            self.ui.chETc.setCheckState(True)

    def setSerie_Yx(self):
        imagens = self.getSerieTemporal(self.serie_Yx)
        if imagens is not None:
            self.serie_Yx = imagens
            self.ui.chYx.setCheckState(True)

    def setSerie_Ya(self):
        imagens = self.getSerieTemporal(self.serie_Ya)
        if imagens is not None:
            self.serie_Ya = imagens
            self.ui.chYa.setCheckState(True)
            
    def setSerie_Kc(self):
        imagens = self.getSerieTemporal(self.serie_Kc)
        if imagens is not None:
            self.serie_Kc = imagens
            self.ui.chKc.setCheckState(True)

    def executa(self):
        self.function = Ya()
        
        param = TableData()
        
        param["ETa"] = self.serie_ETa
        param["ETc"] = self.serie_ETc
        param["Ky"] = self.ui.txKy.value()
        param["Yx"] = self.serie_Yx
        param["Ya"] = self.serie_Ya
        param["Kc"] = self.serie_Kc
        
        resultado = self.function.executar(param)
        
        if self.funcao_cancelada():
            self.console(u"Função interrompida")
            self.finalizar()
        elif resultado is not None:
            self.console(u"Função conluída")
            
            self.finalizar()
    
    def valida_form(self):
        if self.serie_ETa == None :
            self.message(u"Série de imagens de ETa não configurada.")
            return False
        elif self.serie_ETc == None:
            self.message(u"Série de imagens de ETc não configurada.")
            return False
        elif self.serie_Yx == None:
            self.message(u"Série de imagens de Yx não configurada.")
            return False
        elif self.serie_Ya == None:
            self.message(u"Série de imagens de Ya não configurada.")
            return False
        return True
    
    def parametros_teste(self):


        self.serie_ETa = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\6-Eta")
        self.serie_ETa.prefixo = "eta_"
        self.serie_ETa.date_mask = "%Y-%m-%d"
        self.serie_ETa.mutiply_factor = 0.01
        
        self.serie_ETc = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\3-ETc")
        self.serie_ETc.prefixo = "etc_"
        self.serie_ETc.date_mask = "%Y-%m-%d"
        self.serie_ETc.mutiply_factor = 0.01
        
        self.serie_Yx = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\5-PPR(Yx)")
        self.serie_Yx.prefixo = "ppr_"
        self.serie_Yx.date_mask = "%Y-%m-%d"
        self.serie_Yx.mutiply_factor = 1
        
        self.serie_Ya = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\7-Ya")
        self.serie_Ya.prefixo = "Ya_"
        self.serie_Ya.date_mask = "%Y-%m-%d"
        self.serie_Ya.mutiply_factor = 1
        
        self.serie_Kc = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\2-Kc")
        self.serie_Kc.date_mask = "%Y-%m-%d"
    


------------------  CyMP.py  ------------------
'''
Created on Jul 7, 2015

@author: Paloschi
'''
from PyQt4 import QtGui
from Visao import TelaPrincipal
from multiprocessing import Process
from PyQt4 import QtCore
from PyQt4.Qt import QLocale, QTranslator

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

import warnings
warnings.filterwarnings('ignore')

import multiprocessing as mp

         
if __name__ == '__main__':

    
    import sys
    import ctypes
    import ConfigParser
    
    mp.freeze_support() # optional if the program is not frozen

    config = ConfigParser.RawConfigParser()
    config.read('workspace.properties')
    
    company=config.get('Version', 'company')
    product=config.get('Version', 'product')
    subproduct=config.get('Version', 'subproduct')
    version=config.get('Version', 'Version')

    myappid = (company + "." + product + "." + subproduct + "." + version)
    ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
    
    app = QtGui.QApplication(sys.argv)
    icon=config.get('Icon', 'icon.general')
    app.setWindowIcon(QtGui.QIcon(icon))

    locale = QLocale.system().name()
    qtTranslator = QTranslator()
    coretranslator = QtCore.QTranslator(app)
    if qtTranslator.load("qt_"+locale):
        qtTranslator.load('qt_%s' % locale,
                          QtCore.QLibraryInfo.location(QtCore.QLibraryInfo.TranslationsPath))
        app.installTranslator(qtTranslator)
        app.installTranslator(coretranslator)
    
    #print("Numero de nucleos: " + str(GeneralTools.available_cpu_count()))

    ex = TelaPrincipal.Ui_MainWindow()
    ex.show()
    sys.exit(app.exec_())
    


------------------  Decendial2Diario.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Oct 5, 2015

@author: rennan.paloschi
'''

from Modelo.beans import TABLE_DATA, FILE_DATA, SERIAL_FILE_DATA
from datetime import timedelta
import calendar
from Modelo.beans import RasterFile
import numpy
from Modelo.Funcoes import AbstractFunction
import threading

#serie_imagem_in = SerialTemporalFiles(root_path="E:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\7-Cortado_tamanho_Modis\\evpt_2012")
#serie_imagem_in.loadListByRoot()
#serie_imagem_in.prefixo = "evpt_"
#serie_imagem_in.date_mask = "%Y%m%d"

#serie_imagem_out = SerialTemporalFiles(root_path="E:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\8-Diario")
#serie_imagem_out.loadListByRoot()
#serie_imagem_out.prefixo = "evpt_diario_"
#serie_imagem_out.date_mask = "%Y-%m-%d"
#serie_imagem_out.mutiply_factor = 100
#serie_imagem_out.out_datatype = "uint16"

class Funcao(AbstractFunction):
    
    def __setParamIN__(self): 
        self.descriptionIN["In"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Serie temporal de imagens de entrada"}
        self.descriptionIN["Out_config"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Serie temporal de saida saida (configuração)"}
        self.descriptionIN["Operation"] = {"Required":True, "Type":None, "Description":"Operação será aplicada aos valores das imagens baseando-se na quantia de dias do decende, ex.: chuva é soma, então.:'dividir'"}

    def __setParamOUT__(self):
        self.descriptionOUT["Out"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Serie temporal de saida saida"}
        
    def __execOperation__(self):
        
        serie_imagem_in = self.paramentrosIN_carregados["In"].loadListByRoot()
        serie_imagem_out = self.paramentrosIN_carregados["Out_config"]
        
        imagem_in_factor = float(serie_imagem_in.mutiply_factor)
        imagem_out_factor = float(serie_imagem_out.mutiply_factor)
        
        
        n_imagens = len(serie_imagem_in)
        
        if n_imagens is 0 :
            self.console(u"Erro: Nenhuma imagem encontrada na pasta especificada.") 
            self.console(u"Cancelando função.") 
            threading.currentThread().stop()
            return
        
        self.console(u"Construindo série temporal diária...")
        
        for i in range(n_imagens):
            
            self.progresso = (i / float(n_imagens)) * 100
            
            '''Recupera a data correspondente a imagem atual do laço '''
            data = serie_imagem_in.getDate_time(i)
            dia_mes = data.day
            
            '''Calcula quantos dias tem no decend atual'''
            if dia_mes <= 10: duracao = 10
            elif dia_mes <= 20: duracao = 10
            else : duracao =  int(calendar.monthrange(data.year, data.month)[1]) - 20
            
            if threading.currentThread().stopped()  :
                print "thread parada, retornando da função"
                return 
           
            imagem_ = serie_imagem_in[i].loadRasterData()
            imagem_ *= imagem_in_factor

            if self.paramentrosIN_carregados["Operation"] == "dividir valores": 
                imagem_ = (imagem_ / float(duracao))
                imagem_ = numpy.round(imagem_, 4)
            elif self.paramentrosIN_carregados["Operation"] == "manter valores": 
                pass

                
            imagem_ *= imagem_out_factor

            #imagem_ = self.compactar(imagem_)
                 
            for ii in range (0, duracao):
                img = RasterFile()
                img.file_path = serie_imagem_out.root_path   
                data_img = data + timedelta(ii)
                img.file_name = serie_imagem_out.prefixo + data_img.strftime(serie_imagem_out.date_mask) + serie_imagem_out.sufixo
                img.data = imagem_
                img.file_ext = "tif"
                metadata = serie_imagem_in[i].metadata
                #metadata.update(nodata=0)
                img.saveRasterData(metadata=metadata)
                print metadata

   
        self.console(u"Série temporal diária concluída.")

        

------------------  DIF.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 22, 2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA, RasterData
import subprocess
import gdal
import sys
from Modelo.beans.RasterData import RasterFile
progress = gdal.TermProgress_nocb
import numpy

class Etc(AbstractFunction):
    '''
        Essa função calcula a diferença (DIF, mm) entre a precipitação e a evapotranspiração da cultura (ETc)
        Formula: DIF = PPP - ETc
        Para efeitos de histórico, periodos de ETc anteriores ao periodo da cultura devem ser inseridos, por default quando a
    cultura não está presente, o Kc é considerado de valor 1
        
        Esta função não entende datas por isso todos os parametros devem ser passados com referencia a cena
    '''
    
    def __setParamIN__(self):
        
        self.descriptionIN["DIF"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de diferença"}
        self.descriptionIN["PPP"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de precipitacao"}
        self.descriptionIN["ETc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de evapotranspiração da cultura"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["DIF"] = {"Type":SERIAL_FILE_DATA, "Description":"Série de imagens de evapotranspiração da cultura"}
    
    def __execOperation__(self):
        '''
            Por padrão agora assumo que, quando uma variavel tiver como sufixo um underline "_"
            é porque esta variavel contem os valores carregados (matrizes brutas) dos dados
        '''
        
        serie_ET0 = self.paramentrosIN_carregados["ET0"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_Kc = self.paramentrosIN_carregados["Kc"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_ETc = self.paramentrosIN_carregados["ETc"] # pucha lista
        
        Kc_factor = float(serie_Kc.mutiply_factor)
        ET0_factor = serie_ET0.mutiply_factor
        ETC_factor = serie_ETc.mutiply_factor
        
        
        
        for i_Kc in range(len(serie_Kc)):
            #gdal_calc.py [-A <filename>] [--A_band] [-B...-Z filename] [other_options]
            Kc = serie_Kc[i_Kc]
            data_kc = serie_Kc.getDate_time(file=Kc)
            
            ET0 = self.procurar_descende_correspondente(data_kc, serie_ET0)
            
            etc = RasterFile(file_path=serie_ETc.root_path, ext="tif", file_name=Kc.file_name)
            
            ET0_ = numpy.array(ET0.loadRasterData()).astype(dtype="float32") * ET0_factor
            Kc_ = numpy.array(Kc.loadRasterData()).astype(dtype="float32") * Kc_factor
            
            dias_decend = self.dias_decend
            
            ETc_ = Kc_ * (ET0_  / dias_decend) * ETC_factor
            
            #print ET0.file_full_path
            #print Kc.file_full_path
            
            etc.metadata = Kc.metadata
            etc.data = ETc_
            etc.saveRasterData()
            
    
    def procurar_descende_correspondente(self, data, serie_temporal):
        '''
            Esse método procura a imagem correspondente para a data informada (feito para capturar o descende correto)
        '''
        img_correspondente = None
        
        for i_img in range(len(serie_temporal)-1):
            data_img =  serie_temporal.getDate_time(i_img)
            data_img_1 = serie_temporal.getDate_time(i_img+1)
            if data_img == data : 
                img_correspondente = serie_temporal[i_img]
                self.dias_decend = (data_img_1 - data_img).days
                break
            elif data_img < data and data_img_1 > data: 
                img_correspondente = serie_temporal[i_img]
                self.dias_decend = (data_img_1 - data_img).days
        
        if img_correspondente == None : img_correspondente = serie_temporal[-1]
           
        return img_correspondente


------------------  Distribuidor_IC.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Sep 10, 2015

@author: rennan.paloschi
'''

from Modelo.Funcoes import AbstractFunction
from Modelo.beans import TABLE_DATA, FILE_DATA, RasterFile
import datetime
import numpy as np
from numpy.core.numeric import array
from datetime import timedelta
import gdal
from Modelo.beans.SerialFileData import SerialFile
import Modelo
from Modelo.GeneralTools import available_cpu_count
progress = gdal.TermProgress_nocb   
from multiprocessing import Process, Queue
import threading
import time
from Modelo import GeneralTools

def Ds_DC_to_date(data):
        
        n = len(str(data))
        year = int(str(data)[0:4])    
        days = int(str(data)[4:n])
        date = datetime.datetime(year, 1, 1) + datetime.timedelta(days - 1)
        return date

def distribuir_kc(data_minima, data_maxima, semeadura_, colheita_, periodo_kc, kc_vetorizado, path_img_referencia, i, path_out):
    
        import ctypes
        import ConfigParser
        config = ConfigParser.RawConfigParser()
        config.read('workspace.properties')
    
        company=config.get('Version', 'company')
        product=config.get('Version', 'product')
        subproduct=config.get('Version', 'subproduct')
        version=config.get('Version', 'Version')
    
        myappid = (company + "." + product + "." + subproduct + "." + version)
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
    
        threading.currentThread().terminada = False
        imagem_kc = RasterFile(file_full_path = path_img_referencia)
        imagem_kc.loadRasterData()
        imagem_kc.file_path = path_out
        
        #print imagem_kc.metadata
        
        n_linhas = len(semeadura_)
        n_colunas = len(colheita_[0])
        
        delta_total = (data_maxima-data_minima).days+1

        for i_dia in range (0, delta_total):

            imagem_kc_ = np.zeros((n_linhas, n_colunas))
            imagem_kc_ = array(imagem_kc_).astype(dtype="uint8")
       
            dia = data_minima + timedelta(i_dia)
            
            imagem_kc.data = array(semeadura_)
            imagem_kc.file_name = str(dia.date())
            
            #if delta_total > 1 : 
                
                #progresso = (i_dia/float(delta_total))*100
                    
            for i_linha in range(0, n_linhas):
                
                progress(i_linha/float(n_linhas-1))
                
                
                
                for i_coluna in range(0, n_colunas):
                     
                    try:
                        Ds = Ds_DC_to_date(semeadura_[i_linha][i_coluna])
                        Dc = Ds_DC_to_date(colheita_[i_linha][i_coluna])
                        delta_c = (Dc - Ds).days + 1
                        
                        if(dia >= Ds and dia <= Dc):
                            k = dia - Ds
                            i_FKc = int( (k * periodo_kc).days / delta_c)
                            Kc = kc_vetorizado[i_FKc]
                            imagem_kc_[i_linha][i_coluna] = Kc                       
                    except :
                        pass                      

            imagem_kc.metadata.update(nodata=0)
            imagem_kc.saveRasterData(band_matrix = imagem_kc_)
        print "retornando do processo", i
        #threading.currentThread().stopped = True
        threading.currentThread().terminada = True
        return None


class DistribuidorKC(AbstractFunction):
    
    ''' Essa classe pega o KC tabelado e transforma em um cubo temporal de kc pra cada cultura dependendo da data de colheita e semeadura '''
    
    def __setParamIN__(self):
        self.descriptionIN["Kc"] = {"Required":True, "Type":TABLE_DATA, "Description":"Dados Kc tabelado"}
        self.descriptionIN["semeadura"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de semeadura"}
        self.descriptionIN["colheita"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de colheita"} 
        self.descriptionIN["path_out"] = {"Required":True, "Type":None, "Description":"Caminho de saida das imagens"}   
        self.descriptionIN["multply_factor"] = {"Required":True, "Type":None, "Description":"Fator multiplicador pelo indice"}   
        
    def __setParamOUT__(self):
        self.descriptionOUT["images"] = "Série de imagens kc distribuidas de acordo com as imagens de semeadura e  colheita" 
            
    def __execOperation__(self):
        
        try:
            semeadura_ = self.paramentrosIN_carregados["semeadura"].loadRasterData()
            colheita_ = self.paramentrosIN_carregados["colheita"].loadRasterData()
        except: 
            print "não foi possivel carregar as imagens de semeadura e colheita"
            return None
        try:
            data_minima = self.Ds_DC_to_date(np.min(semeadura_))
            #data_minima = self.Ds_DC_to_date("2013240")
            data_maxima = self.Ds_DC_to_date(np.max(colheita_))
            #data_maxima = self.Ds_DC_to_date("201499")
        except:
            print "não foi possivel converter os valores das imagens de semeadura e colheita em datas"
            return None
        

        #data_minima = datetime.datetime(2012, 04, 19)
        #print data_minima        
        #data_maxima = datetime.datetime(2012, 04, 19)
        #print data_maxima
        
        kc_vetorizado = self.vetorizar_kc()
        periodo_kc = len(kc_vetorizado)
        
        delta_total = (data_maxima-data_minima).days
        
        #print data_maxima
        
        #print "total de dias", delta_total
        
        metadata = self.paramentrosIN_carregados["semeadura"].metadata
        
        #print metadata
        
        n_of_process = available_cpu_count() - 2

        processos = list()
        
        for i in range (0, n_of_process):
            
            path_img_semeadura = self.paramentrosIN_carregados["semeadura"].file_full_path
        
            q = Queue()
            if i == 0 : data_minima_process = data_minima
            else : 
                dt = data_minima + timedelta(float(i)*int(float(delta_total)/float(n_of_process)))
                data_minima_process =  dt
                #print data_minima_process
                #print data_minima_process.date()

            
            if i == n_of_process-1 : data_maxima_process = data_maxima
            else : 
                dt = data_minima + timedelta(((i+1)*int(float(delta_total)/float(n_of_process)))-1)
                data_maxima_process =  dt

            
            #print data_minima_process, data_maxima_process
            
            p = Process(target=distribuir_kc, args=(data_minima_process, 
                                                     data_maxima_process, 
                                                     semeadura_, colheita_, periodo_kc, kc_vetorizado, path_img_semeadura, 
                                                     i, self.paramentrosIN_carregados["path_out"]))
            p.daemon = True
            processos.append(p)
            p.start()
            
            
            
            
        print "vai aguardar processos --------------------------------------------------"
        
        numero_de_processos_prontos = 1        
        processos_prontos = False
        while numero_de_processos_prontos < n_of_process:
            processos_prontos = 0
            for p in processos:
                p.join()
                numero_de_processos_prontos +=1
                print "mais um processo terminado ", i, " -------------------------------------"
            time.sleep(0.5)
        
        print "Acabou, retornando ----------------------------------------------------"
        
        return SerialFile(root_path = self.paramentrosIN_carregados["path_out"])
                
    def vetorizar_kc(self): 
        
        if self.paramentrosIN_carregados.has_key("multply_factor") :
            multply_factor = self.paramentrosIN_carregados["multply_factor"]
        else :
            multply_factor = 1
        
        tamanho = 0
        for key in self.paramentrosIN_carregados["Kc"].keys():
            fim = int(key.split("-")[1])
            if fim > tamanho : tamanho = fim
        
        kc_vetorizado = np.zeros(tamanho)
        
        print len(kc_vetorizado)
        
        for key in self.paramentrosIN_carregados["Kc"].keys():
            inicio = int(key.split("-")[0])
            fim = int(key.split("-")[1])
            print "chave:", key, "- inicio:", inicio, "- fim:", fim, "- tamanho:", fim - inicio
            for x in range(inicio, fim+1):
                kc_vetorizado[x-1] = self.paramentrosIN_carregados["Kc"][key] * multply_factor
                
        print kc_vetorizado
        print len(kc_vetorizado)
        return kc_vetorizado
    
    def Ds_DC_to_date(self, data):
        
        n = len(str(data))
        year = int(str(data)[0:4])    
        days = int(str(data)[4:n])
        date = datetime.datetime(year, 1, 1) + datetime.timedelta(days - 1)
        return date


------------------  Distribuidor_IC_2.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Sep 10, 2015

@author: rennan.paloschi
'''

import warnings
warnings.filterwarnings('ignore')

from Modelo.Funcoes import AbstractFunction
from Modelo.beans import TABLE_DATA, FILE_DATA, RasterFile
import datetime
import numpy as np
import gdal
from Modelo.beans.SerialFileData import SerialFile
from Modelo.GeneralTools import available_cpu_count
progress = gdal.TermProgress_nocb   
from multiprocessing import Process
import threading
import time

def distribuir_kc(dia, semeadura_, colheita_, ano_inicio, dia_inicio, periodo_kc, kc_vetorizado, path_img_referencia, path_out):
    
        threading.currentThread().terminada = False
        imagem_kc = RasterFile(file_full_path = path_img_referencia)
        imagem_kc.getLoadJustMetaData()
        imagem_kc.file_path = path_out

        n_linhas = len(semeadura_)
        n_colunas = len(semeadura_[0])
        
        delta_c = (colheita_ - semeadura_)#.astype(np.float32)
        tempo_em_campo = (dia+1 - semeadura_)#.astype(np.float32)
            
        i_FKc = np.zeros((n_linhas, n_colunas)).astype(np.float32)
                        
        for i in range(n_linhas) :
            mask = ((tempo_em_campo[i] > 0) & (tempo_em_campo[i] <= delta_c[i]))
            i_FKc[i][mask] = ((tempo_em_campo[i][mask]-1) * periodo_kc)/delta_c[i][mask]
            i_FKc[i][mask] = np.ceil(i_FKc[i][mask])
            i_FKc[i][mask] = [kc_vetorizado[index] for index in i_FKc[i][mask]]
            
        imagem_kc.file_name = str(datetime.datetime(ano_inicio, 1, 1) + datetime.timedelta(dia + dia_inicio - 1))[:10]
        imagem_kc.metadata.update(nodata=0)
        imagem_kc.metadata.update(dtype="float32")
        
        imagem_kc.saveRasterData(band_matrix = i_FKc)

        threading.currentThread().terminada = True
                
        return


class DistribuidorKC_(AbstractFunction):
    
    ''' Essa classe pega o KC tabelado e transforma em um cubo temporal de kc pra cada cultura dependendo da data de colheita e semeadura '''
    
    def __setParamIN__(self):
        self.descriptionIN["Kc"] = {"Required":True, "Type":TABLE_DATA, "Description":"Dados Kc tabelado"}
        self.descriptionIN["semeadura"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de semeadura"}
        self.descriptionIN["colheita"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de colheita"} 
        self.descriptionIN["path_out"] = {"Required":True, "Type":None, "Description":"Caminho de saida das imagens"}   
        self.descriptionIN["multply_factor"] = {"Required":False, "Type":None, "Description":"Fator multiplicador pelo indice"}   
        
    def __setParamOUT__(self):
        self.descriptionOUT["images"] = "Série de imagens kc distribuidas de acordo com as imagens de semeadura e  colheita" 
            
    def __execOperation__(self):
        
        self.setProgresso(0, 100)
        
        self.console(u"Carregando imagens de semeadura e colheita...")
        
        try:
            semeadura_ = self.paramentrosIN_carregados["semeadura"].loadRasterData()
            colheita_ = self.paramentrosIN_carregados["colheita"].loadRasterData()
        except: 
            self.console ("não foi possivel carregar as imagens de semeadura e colheita")
            return None
        try:
            data_minima = self.Ds_DC_to_date(np.min(semeadura_))
            data_maxima = self.Ds_DC_to_date(np.max(colheita_))          
        except:
            self.console( u"As imagens foram carregadas mas não foi possível converter os valores das imagens de semeadura e colheita em datas")
            return None 
            
        self.console(u"Convertendo datas e gerando dados necessários...")
        
        semeadura_, colheita_, primeiro_ano, primeiro_dia = self.normalize_datas(semeadura_, colheita_)
        
        data_minima_ = 0
        data_maxima_ = np.max(colheita_)
        
        kc_vetorizado = self.vetorizar_kc()
        periodo_kc = len(kc_vetorizado)
        
        delta_total = (data_maxima-data_minima).days
        
        self.console(u"Numero de dias da primeira DS à ultima DC: " +  str(delta_total))
        self.console(u"Numero de processadores identificados: " +  str(available_cpu_count()))

        if (available_cpu_count()>4):
            n_of_process = available_cpu_count() - 1
        elif (available_cpu_count()>1) :
            n_of_process = available_cpu_count()
        else :
            n_of_process = 1

        processadores_disponiveis = n_of_process
        self.console(u"Numero de processadores utilizados: "+  str(n_of_process))

        processos = list()
        
        path_img_semeadura = self.paramentrosIN_carregados["semeadura"].file_full_path
        self.console("Processando...")

        for dia in range (data_minima_, data_maxima_):
            
            if threading.currentThread().stopped()  : return 
        
            p = Process(target=distribuir_kc, args=(dia,     
                                                        semeadura_, colheita_,
                                                        primeiro_ano, primeiro_dia,
                                                        periodo_kc, kc_vetorizado, path_img_semeadura, 
                                                        self.paramentrosIN_carregados["path_out"]))
            p.daemon = True
            processos.append(p)
            p.start()
            
            processadores_disponiveis -=1
                    
            while (processadores_disponiveis == 0): 
                for p in processos:
                    if not p.is_alive(): 
                        processadores_disponiveis += 1
                        processos.remove(p)
                time.sleep(0.5)

            self.setProgresso(data_minima_ + dia, data_maxima_)
            
        ##print "Acabou, retornando ----------------------------------------------------"
        
        return SerialFile(root_path = self.paramentrosIN_carregados["path_out"])
                
    def vetorizar_kc(self): 
        
        if self.paramentrosIN_carregados.has_key("multply_factor") :
            multply_factor = self.paramentrosIN_carregados["multply_factor"]
        else :
            multply_factor = 1
        
        tamanho = 0
        for key in self.paramentrosIN_carregados["Kc"].keys():
            fim = int(key.split("-")[1])
            if fim > tamanho : tamanho = fim
        
        kc_vetorizado = np.zeros(tamanho)
        
        for key in self.paramentrosIN_carregados["Kc"].keys():
            inicio = int(key.split("-")[0])
            fim = int(key.split("-")[1])
            #print "chave:", key, "- inicio:", inicio, "- fim:", fim, "- tamanho:", fim - inicio
            for x in range(inicio, fim+1):
                kc_vetorizado[x-1] = self.paramentrosIN_carregados["Kc"][key] * multply_factor
                
        #print kc_vetorizado
        #print len(kc_vetorizado)
        return kc_vetorizado
        
    def normalize_datas(self, semeadura, colheita):
        
        ano_semeadura = semeadura.astype(int)/1000
        dia_semeadura = semeadura - ano_semeadura * 1000
        
        ano_colheita = colheita.astype(int)/1000
        dia_colheita = colheita - ano_colheita * 1000
        
        primeira_data = np.min(semeadura)
        primeiro_ano = primeira_data/1000
        primeiro_dia = primeira_data - primeiro_ano * 1000
        
        dias_no_ano = self.dias_ano(primeiro_ano)
        
        semeadura_normalizada = (ano_semeadura - primeiro_ano - 1) * (primeiro_dia - dia_semeadura)  + (ano_semeadura - primeiro_ano) * dia_semeadura + (ano_semeadura - primeiro_ano) * (dias_no_ano - primeiro_dia) 
        colheita_normalizada = ((ano_colheita - primeiro_ano) - 1) * (primeiro_dia - dia_colheita)  + (ano_colheita - primeiro_ano) * dia_colheita + (ano_colheita - primeiro_ano) * (365 - primeiro_dia)
        
        return semeadura_normalizada, colheita_normalizada, primeiro_ano, primeiro_dia
    
    def dias_ano(self, ano):
        if ano%4==0:
            if ano%100==0:
                if ano%400==0:
                    return 366
                else:
                    return 365
            else:
                return 366
        else:
            return False
        
    def Ds_DC_to_date(self, data):
        n = len(str(data))
        year = int(str(data)[0:4])    
        days = int(str(data)[4:n])
        date = datetime.datetime(year, 1, 1) + datetime.timedelta(days - 1)
        return date

		
------------------  DlgDecendial2Diario.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgDecendial2Diario.ui'
#
# Created: Mon Nov 09 13:44:39 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle import ConDecendial2Diario

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Decendial2Diario(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = ConDecendial2Diario.Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(283, 166)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.chDecendial = QtGui.QCheckBox(Dialog)
        self.chDecendial.setText(_fromUtf8(""))
        #self.chDecendial.setCheckState()
        self.chDecendial.setCheckable(False)
        self.chDecendial.setEnabled(False)
        
        self.chDecendial.setObjectName(_fromUtf8("chDecendial"))
        self.gridLayout.addWidget(self.chDecendial, 2, 2, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 2, 0, 1, 1)
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.gridLayout.addWidget(self.pushButton_2, 2, 1, 1, 1)
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.gridLayout.addWidget(self.pushButton, 1, 1, 1, 1)
        self.chDiario = QtGui.QCheckBox(Dialog)
        self.chDiario.setText(_fromUtf8(""))
        self.chDiario.setCheckable(False)
        self.chDiario.setObjectName(_fromUtf8("chDiario"))
        self.chDiario.setEnabled(False)
        self.gridLayout.addWidget(self.chDiario, 1, 2, 1, 1)

        self.label_3 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_3, 3, 1, 2, 1)
        
        self.cbOperacao = QtGui.QComboBox(Dialog)
        self.cbOperacao.setEditable(True)
        self.cbOperacao.setObjectName(_fromUtf8("cbOperacao"))
        self.cbOperacao.addItem(_fromUtf8("manter valores"))
        self.cbOperacao.addItem(_fromUtf8("dividir valores"))
        self.gridLayout.addWidget(self.cbOperacao, 3, 1, 2, 1)
        
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.pushButton.clicked.connect(self.controller.setSerieEntrada)
        self.pushButton_2.clicked.connect(self.controller.setSerieSaida)
        
        #self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Decendial para diário", None))
        self.label_2.setText(_translate("Dialog", "Entrada de imagens decendiais", None))
        self.label_3.setText(_translate("MainWindow", "", None))
        self.label.setText(_translate("Dialog", "Saída de imagens diárias", None))
        self.pushButton_2.setText(_translate("Dialog", "configurar", None))
        self.pushButton.setText(_translate("Dialog", "configurar", None))



------------------  DlgDistribuidorDeIndice.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgDistribuidorDeIndice.ui'
#
# Created: Mon Oct 19 07:14:46 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConDistribuidorDeIndice import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_DistribuidorDeIndice(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(437, 332)
        self.label = QtGui.QLabel(Dialog)
        self.label.setGeometry(QtCore.QRect(26, 44, 111, 16))
        self.label.setObjectName(_fromUtf8("label"))
        self.btFindImgSemeadura = QtGui.QToolButton(Dialog)
        self.btFindImgSemeadura.setGeometry(QtCore.QRect(370, 40, 25, 19))
        self.btFindImgSemeadura.setObjectName(_fromUtf8("btFindImgSemeadura"))
        self.btFindOutFolder = QtGui.QToolButton(Dialog)
        self.btFindOutFolder.setGeometry(QtCore.QRect(370, 130, 25, 19))
        self.btFindOutFolder.setObjectName(_fromUtf8("btFindOutFolder"))
        self.txOutFolder = QtGui.QLineEdit(Dialog)
        self.txOutFolder.setGeometry(QtCore.QRect(146, 130, 211, 20))
        self.txOutFolder.setObjectName(_fromUtf8("txOutFolder"))
        self.txImgSemeadura = QtGui.QLineEdit(Dialog)
        self.txImgSemeadura.setGeometry(QtCore.QRect(146, 40, 211, 20))
        self.txImgSemeadura.setObjectName(_fromUtf8("txImgSemeadura"))
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setGeometry(QtCore.QRect(26, 134, 81, 16))
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.btOkCancel = QtGui.QDialogButtonBox(Dialog)
        self.btOkCancel.setGeometry(QtCore.QRect(30, 300, 401, 23))
        self.btOkCancel.setOrientation(QtCore.Qt.Horizontal)
        self.btOkCancel.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.btOkCancel.setObjectName(_fromUtf8("btOkCancel"))
        self.tableWidget = QtGui.QTableWidget(Dialog)
        self.tableWidget.setGeometry(QtCore.QRect(30, 170, 261, 111))
        self.tableWidget.setObjectName(_fromUtf8("tableWidget"))
        self.tableWidget.setColumnCount(3)
        self.tableWidget.setRowCount(1)
        self.tableWidget.rowCount()
        item = QtGui.QTableWidgetItem()
        self.tableWidget.setVerticalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(1, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(2, item)
        item = QtGui.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.tableWidget.setItem(0, 0, item)
        item = QtGui.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 1, item)
        item = QtGui.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 2, item)
        self.btRemover = QtGui.QPushButton(Dialog)
        self.btRemover.setGeometry(QtCore.QRect(300, 260, 75, 23))
        self.btRemover.setObjectName(_fromUtf8("btRemover"))
        self.btAdicionar = QtGui.QPushButton(Dialog)
        self.btAdicionar.setGeometry(QtCore.QRect(300, 230, 75, 23))
        self.btAdicionar.setObjectName(_fromUtf8("btAdicionar"))
                                                  
        self.txMultiplyFactor = QtGui.QSpinBox(Dialog)
        self.txMultiplyFactor.setMaximum(10000)
        self.txMultiplyFactor.setGeometry(QtCore.QRect(146, 100, 211, 20))
        self.txMultiplyFactor.setObjectName(_fromUtf8("txMultiplyFactor"))
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setGeometry(QtCore.QRect(26, 100, 101, 16))
        self.label_3.setObjectName(_fromUtf8("label_3"))
        #self.btFindImgPico = QtGui.QToolButton(Dialog)
        #self.btFindImgPico.setGeometry(QtCore.QRect(370, 70, 25, 19))
        #self.btFindImgPico.setObjectName(_fromUtf8("btFindImgPico"))
        self.txImgColheita = QtGui.QLineEdit(Dialog)
        self.txImgColheita.setGeometry(QtCore.QRect(146, 70, 211, 20))
        self.txImgColheita.setObjectName(_fromUtf8("txImgColheita"))
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setGeometry(QtCore.QRect(26, 70, 101, 16))
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.btFindImgColheita = QtGui.QToolButton(Dialog)
        self.btFindImgColheita.setGeometry(QtCore.QRect(370, 70, 25, 19))
        self.btFindImgColheita.setObjectName(_fromUtf8("btFindImgColheita"))
        self.comboBox = QtGui.QComboBox(Dialog)
        self.comboBox.setGeometry(QtCore.QRect(300, 170, 121, 22))
        self.comboBox.setObjectName(_fromUtf8("comboBox"))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setGeometry(QtCore.QRect(100, 10, 208, 13))
        self.label_5.setObjectName(_fromUtf8("label_5"))

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.btOkCancel, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.btOkCancel, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Distribuidor de índice.", None))
        self.label.setText(_translate("Dialog", "Imagem de semeadura", None))
        self.btFindImgSemeadura.setText(_translate("Dialog", "...", None))
        self.btFindOutFolder.setText(_translate("Dialog", "...", None))
        self.label_2.setText(_translate("Dialog", "Pasta de saída:", None))
        
        
        item = self.tableWidget.verticalHeaderItem(0)
        item.setText(_translate("Dialog", "Estádio 1", None))
        item = self.tableWidget.horizontalHeaderItem(0)
        self.tableWidget.setColumnWidth(0, 60)
        item.setText(_translate("Dialog", "Dia inicial", None))
        item = self.tableWidget.horizontalHeaderItem(1)
        self.tableWidget.setColumnWidth(1, 60)
        item.setText(_translate("Dialog", "Dia final", None))
        item = self.tableWidget.horizontalHeaderItem(2)
        self.tableWidget.setColumnWidth(2, 60)
        item.setText(_translate("Dialog", "Valor", None))
        self.tableWidget.horizontalHeader().setStretchLastSection(True)
        
        
        __sortingEnabled = self.tableWidget.isSortingEnabled()
        self.tableWidget.setSortingEnabled(False)
        item = self.tableWidget.item(0, 0)
        item.setText(_translate("Dialog", "1", None))
        item = self.tableWidget.item(0, 2)
        item.setText(_translate("Dialog", "1", None))
        #self.tableWidget.setSortingEnabled(__sortingEnabled)
        self.btRemover.setText(_translate("Dialog", "Remover", None))
        self.btAdicionar.setText(_translate("Dialog", "Adicionar", None))
        self.label_3.setText(_translate("Dialog", "Fator multiplicador:", None))
        #self.btFindImgPico.setText(_translate("Dialog", "...", None))
        self.label_4.setText(_translate("Dialog", "Imagem de colheita:", None))
        self.btFindImgColheita.setText(_translate("Dialog", "...", None))
        self.comboBox.setItemText(1, _translate("Dialog", "Kc FAO - Soja", None))
        self.comboBox.setItemText(2, _translate("Dialog", "Zr FAO - Soja", None))
        self.label_5.setText(_translate("Dialog", "Distribuidor de índice por Estádio fenológico", None))
        self.txMultiplyFactor.setValue(100)
        
        self.btFindImgSemeadura.clicked.connect(self.controller.findImgSemeadura)
        self.btFindOutFolder.clicked.connect(self.controller.findOutFolder)
        #self.btFindImgPico.clicked.connect(self.controller.findImgPico)
        self.btFindImgColheita.clicked.connect(self.controller.findImgColheita)
        
        self.comboBox.currentIndexChanged.connect(self.controller.changeDefaultIndices)
        
        self.btAdicionar.clicked.connect(self.controller.addEstagio)
        self.btRemover.clicked.connect(self.controller.remEstagio)
        
        #self.txImgColheita.setText("C:\\Users\\Paloschi\\Desktop\\2-DS, DC, DMDV\\colheita_soja_11-12.tif")
        #self.txImgSemeadura.setText("C:\\Users\\Paloschi\\Desktop\\2-DS, DC, DMDV\\semeadura_soja_11-12.tif")
        #self.txOutFolder.setText("C:\\Users\\Paloschi\\Desktop\\TesteDistribuidor\\")



------------------  DlgDr.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgDr.ui'
#
# Created: Wed Nov 11 04:59:35 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConDr import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(451, 273)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)

        self.gridLayout = QtGui.QGridLayout()
      
        self.label = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        
        self.label_2 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.btnConfETc = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfETc, 1, 1, 1, 1)
        self.chEtc = QtGui.QCheckBox(Dialog)
        self.chEtc.setEnabled(False)
        self.gridLayout.addWidget(self.chEtc, 1, 2, 1, 1)
        
        self.label_3 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.btnConfPPP = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfPPP, 2, 1, 1, 1)
        self.chPPP = QtGui.QCheckBox(Dialog)
        self.chPPP.setEnabled(False)
        self.gridLayout.addWidget(self.chPPP, 2, 2, 1, 1)
        
        self.label_4 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.btnConfTAW = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfTAW, 3, 1, 1, 1)
        self.chTAW = QtGui.QCheckBox(Dialog)
        self.chTAW.setEnabled(False)
        self.gridLayout.addWidget(self.chTAW, 3, 2, 1, 1)
        
        self.label_7 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_7, 4, 0, 1, 1)
        self.txImgCAD = QtGui.QLineEdit(Dialog)
        self.gridLayout.addWidget(self.txImgCAD, 4, 1, 1, 1)
        self.btnFindImgCAD = QtGui.QToolButton(Dialog)
        self.gridLayout.addWidget(self.btnFindImgCAD, 4, 2, 1, 1)        
        
        self.label_5 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_5, 5, 0, 1, 1)       

        self.label_6 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_6, 6, 0, 1, 1) 
        self.BtnConfDr = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.BtnConfDr, 6, 1, 1, 1)               
        self.chDr = QtGui.QCheckBox(Dialog)
        self.chDr.setEnabled(False)
        self.gridLayout.addWidget(self.chDr, 6, 2, 1, 1)
        
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.gridLayout.addItem(spacerItem, 7, 0, 1, 1)
        
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)

        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.BtnConfDr.clicked.connect(self.controller.setSerie_Dr)
        self.btnConfETc.clicked.connect(self.controller.setSerie_ETc)
        self.btnConfPPP.clicked.connect(self.controller.setSeriePPP)
        self.btnConfTAW.clicked.connect(self.controller.setSerie_TAW)
        self.btnFindImgCAD.clicked.connect(self.controller.findImgCAD)
        
        self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Valor de esgotamento (Dr)", None))
        self.chTAW.setText(_translate("Dialog", "configurado", None))
        self.btnConfPPP.setText(_translate("Dialog", "configurar", None))
        self.label.setText(_translate("Dialog", "Configuração de entrada:", None))
        self.chDr.setText(_translate("Dialog", "configurado", None))
        self.label_2.setText(_translate("Dialog", "Série de imagens de Etc:", None))
        self.label_3.setText(_translate("Dialog", "Série de imagens de Precipitação:", None))
        self.label_4.setText(_translate("Dialog", "Série de imagens TAW:", None))
        self.label_5.setText(_translate("Dialog", "Configuração de saída:", None))
        self.label_5.setText(_translate("Dialog", "Configuração de saída:", None))
        self.btnConfTAW.setText(_translate("Dialog", "configurar", None))
        self.btnConfETc.setText(_translate("Dialog", "configurar", None))
        self.label_6.setText(_translate("Dialog", "Série de Imagens de esgotamento:", None))
        self.chPPP.setText(_translate("Dialog", "configurado", None))
        self.BtnConfDr.setText(_translate("Dialog", "configurar", None))
        self.chEtc.setText(_translate("Dialog", "configurado", None))
        self.label_7.setText(_translate("Dialog", "Imagem de CAD:", None))
        self.btnFindImgCAD.setText(_translate("Dialog", "...", None))



------------------  DlgEstatisticasEspectrais.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgEstatisticasEspectrais.ui'
#
# Created: Wed Jul 01 11:12:16 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle import ConEstatisticasEspectrais

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_DlgEstatisticasEspectrais(QtGui.QDialog):
    def setupUi(self, DlgEstatisticasEspectrais):
        
        self.controller = ConEstatisticasEspectrais.Controller(self)
        
        DlgEstatisticasEspectrais.setObjectName(_fromUtf8("DlgEstatisticasEspectrais"))
        DlgEstatisticasEspectrais.setWindowModality(QtCore.Qt.WindowModal)
        DlgEstatisticasEspectrais.resize(359, 272)
        DlgEstatisticasEspectrais.setMinimumSize(QtCore.QSize(50, 0))
        DlgEstatisticasEspectrais.setSizeIncrement(QtCore.QSize(1, 0))
        DlgEstatisticasEspectrais.setBaseSize(QtCore.QSize(50, 0))
        DlgEstatisticasEspectrais.setStyleSheet(_fromUtf8(""))
        self.verticalLayout = QtGui.QVBoxLayout(DlgEstatisticasEspectrais)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.tabWidget = QtGui.QTabWidget(DlgEstatisticasEspectrais)
        self.tabWidget.setObjectName(_fromUtf8("tabWidget"))
        self.tab_3 = QtGui.QWidget()
        self.tab_3.setObjectName(_fromUtf8("tab_3"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.tab_3)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.leInFolder = QtGui.QLineEdit(self.tab_3)
        self.leInFolder.setObjectName(_fromUtf8("leInFolder"))
        self.gridLayout.addWidget(self.leInFolder, 0, 1, 1, 1)
        self.toolbFindInFolder = QtGui.QToolButton(self.tab_3)
        self.toolbFindInFolder.setObjectName(_fromUtf8("toolbFindInFolder"))
        self.gridLayout.addWidget(self.toolbFindInFolder, 0, 2, 1, 1)
        self.label = QtGui.QLabel(self.tab_3)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.verticalLayout_2.addLayout(self.gridLayout)
        self.tabWidget.addTab(self.tab_3, _fromUtf8(""))
        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName(_fromUtf8("tab_2"))
        self.verticalLayout_4 = QtGui.QVBoxLayout(self.tab_2)
        self.verticalLayout_4.setObjectName(_fromUtf8("verticalLayout_4"))
        self.gridLayout_4 = QtGui.QGridLayout()
        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
        self.label_8 = QtGui.QLabel(self.tab_2)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_4.addWidget(self.label_8, 0, 0, 1, 1)
        self.toolbFindOutFolder = QtGui.QToolButton(self.tab_2)
        self.toolbFindOutFolder.setObjectName(_fromUtf8("toolbFindOutFolder"))
        self.gridLayout_4.addWidget(self.toolbFindOutFolder, 0, 2, 1, 1)
        self.leOutFolder = QtGui.QLineEdit(self.tab_2)
        self.leOutFolder.setObjectName(_fromUtf8("leOutFolder"))
        self.gridLayout_4.addWidget(self.leOutFolder, 0, 1, 1, 1)
        self.verticalLayout_4.addLayout(self.gridLayout_4)
        self.tabWidget.addTab(self.tab_2, _fromUtf8(""))
        self.tab = QtGui.QWidget()
        self.tab.setObjectName(_fromUtf8("tab"))
        self.verticalLayout_3 = QtGui.QVBoxLayout(self.tab)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.gridLayout_2 = QtGui.QGridLayout()
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.cbSD = QtGui.QCheckBox(self.tab)
        self.cbSD.setObjectName(_fromUtf8("cbSD"))
        self.gridLayout_2.addWidget(self.cbSD, 1, 0, 1, 1)
        self.cbMedia = QtGui.QCheckBox(self.tab)
        self.cbMedia.setObjectName(_fromUtf8("cbMedia"))
        self.gridLayout_2.addWidget(self.cbMedia, 0, 0, 1, 1)
        self.cbAmplitude = QtGui.QCheckBox(self.tab)
        self.cbAmplitude.setObjectName(_fromUtf8("cbAmplitude"))
        self.gridLayout_2.addWidget(self.cbAmplitude, 3, 0, 1, 1)
        self.cbMin = QtGui.QCheckBox(self.tab)
        self.cbMin.setObjectName(_fromUtf8("cbMin"))
        self.gridLayout_2.addWidget(self.cbMin, 0, 1, 1, 1)
        self.cbCV = QtGui.QCheckBox(self.tab)
        self.cbCV.setObjectName(_fromUtf8("cbCV"))
        self.gridLayout_2.addWidget(self.cbCV, 2, 0, 1, 1)
        self.cbMax = QtGui.QCheckBox(self.tab)
        self.cbMax.setObjectName(_fromUtf8("cbMax"))
        self.gridLayout_2.addWidget(self.cbMax, 1, 1, 1, 1)
        self.cbSoma = QtGui.QCheckBox(self.tab)
        self.cbSoma.setObjectName(_fromUtf8("cbSoma"))
        self.gridLayout_2.addWidget(self.cbSoma, 2, 1, 1, 1)
        self.cbMediana = QtGui.QCheckBox(self.tab)
        self.cbMediana.setObjectName(_fromUtf8("cbMediana"))
        self.gridLayout_2.addWidget(self.cbMediana, 3, 1, 1, 1)
        self.verticalLayout_3.addLayout(self.gridLayout_2)
        self.tabWidget.addTab(self.tab, _fromUtf8(""))
        self.verticalLayout.addWidget(self.tabWidget)
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.bbOkCancel = QtGui.QDialogButtonBox(DlgEstatisticasEspectrais)
        self.bbOkCancel.setOrientation(QtCore.Qt.Horizontal)
        self.bbOkCancel.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.bbOkCancel.setObjectName(_fromUtf8("bbOkCancel"))
        self.horizontalLayout.addWidget(self.bbOkCancel)
        self.verticalLayout.addLayout(self.horizontalLayout)

        self.retranslateUi(DlgEstatisticasEspectrais)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(DlgEstatisticasEspectrais)

    def retranslateUi(self, DlgEstatisticasEspectrais):
        DlgEstatisticasEspectrais.setWindowTitle(_translate("DlgEstatisticasEspectrais", "CyMP - Estatísticas Descritivas (Perfil)", None))
        self.toolbFindInFolder.setText(_translate("DlgEstatisticasEspectrais", "...", None))
        self.label.setText(_translate("DlgEstatisticasEspectrais", "Pasta de entrada das imagens:", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("DlgEstatisticasEspectrais", "Dados de entrada", None))
        self.label_8.setText(_translate("DlgEstatisticasEspectrais", "Pasta de saída das imagens:", None))
        self.toolbFindOutFolder.setText(_translate("DlgEstatisticasEspectrais", "...", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("DlgEstatisticasEspectrais", "Dados de saída", None))
        self.cbSD.setText(_translate("DlgEstatisticasEspectrais", "Desvio padrão", None))
        self.cbMedia.setText(_translate("DlgEstatisticasEspectrais", "Média", None))
        self.cbAmplitude.setText(_translate("DlgEstatisticasEspectrais", "Amplitude", None))
        self.cbMin.setText(_translate("DlgEstatisticasEspectrais", "Mínimo", None))
        self.cbCV.setText(_translate("DlgEstatisticasEspectrais", "Coeficiente de variação", None))
        self.cbMax.setText(_translate("DlgEstatisticasEspectrais", "Máximo", None))
        self.cbSoma.setText(_translate("DlgEstatisticasEspectrais", "Soma", None))
        self.cbMediana.setText(_translate("DlgEstatisticasEspectrais", "Mediana", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("DlgEstatisticasEspectrais", "Configuração", None))
        
        #self.leInFolder.setText("C:\\Users\\Paloschi\\Desktop\\data\\Rasters\\TesteFiltro\\entrada_pesada")
        #self.leOutFolder.setText("C:\\Users\\Paloschi\\Desktop\\data\\Rasters\\TesteFiltro\\saida")
        

        self.toolbFindInFolder.clicked.connect(self.controller.findInFolder)
        self.toolbFindOutFolder.clicked.connect(self.controller.findOutFolder)
        
        #self.controller.parametros_teste()


------------------  DlgEstimativaDatasCultura.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgEstimativaDatasCultura.ui'
#
# Created: Thu Jun 11 16:55:09 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConEstimativaDatasCultura import Controller
#import ConfigParser

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_DlgEstimativaDatasAgricolas(QtGui.QDialog):

    
    def setupUi(self, DlgEstimativaDatasAgricolas):
        
        self.controller = Controller(self);
        
        DlgEstimativaDatasAgricolas.setObjectName(_fromUtf8("DlgEstimativaDatasAgricolas"))
        DlgEstimativaDatasAgricolas.setWindowModality(QtCore.Qt.WindowModal)
        DlgEstimativaDatasAgricolas.resize(371, 278)
        DlgEstimativaDatasAgricolas.setMinimumSize(QtCore.QSize(50, 0))
        DlgEstimativaDatasAgricolas.setSizeIncrement(QtCore.QSize(1, 0))
        DlgEstimativaDatasAgricolas.setBaseSize(QtCore.QSize(50, 0))
        DlgEstimativaDatasAgricolas.setStyleSheet(_fromUtf8(""))
        
        self.tabWidget = QtGui.QTabWidget(DlgEstimativaDatasAgricolas)
        self.tabWidget.setGeometry(QtCore.QRect(10, 10, 351, 201))
        self.tabWidget.setObjectName(_fromUtf8("tabWidget"))
        
        self.tab_3 = QtGui.QWidget()
        self.tab_3.setObjectName(_fromUtf8("tab_3"))
        
        self.gridLayoutWidget = QtGui.QWidget(self.tab_3)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(10, 10, 331, 51))
        self.gridLayoutWidget.setObjectName(_fromUtf8("gridLayoutWidget"))
        
        self.gridLayout = QtGui.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        
        self.leInFolder = QtGui.QLineEdit(self.gridLayoutWidget)
        self.leInFolder.setObjectName(_fromUtf8("leInFolder"))
        self.gridLayout.addWidget(self.leInFolder, 0, 1, 1, 1)
        

        self.toolbFindInFolder = QtGui.QToolButton(self.gridLayoutWidget)
        self.toolbFindInFolder.setObjectName(_fromUtf8("toolbFindInFolder"))
        self.gridLayout.addWidget(self.toolbFindInFolder, 0, 2, 1, 1)
        
        self.label = QtGui.QLabel(self.gridLayoutWidget)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        
        self.gridLayoutWidget_3 = QtGui.QWidget(self.tab_3)
        self.gridLayoutWidget_3.setGeometry(QtCore.QRect(10, 80, 311, 71))
        self.gridLayoutWidget_3.setObjectName(_fromUtf8("gridLayoutWidget_3"))
        
        self.gridLayout_3 = QtGui.QGridLayout(self.gridLayoutWidget_3)
        self.gridLayout_3.setMargin(0)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        
        self.leSufixo = QtGui.QLineEdit(self.gridLayoutWidget_3)
        self.leSufixo.setObjectName(_fromUtf8("leSufixo"))
        self.gridLayout_3.addWidget(self.leSufixo, 1, 1, 1, 1)
        
        self.label_6 = QtGui.QLabel(self.gridLayoutWidget_3)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_3.addWidget(self.label_6, 1, 0, 1, 1)
        
        self.label_7 = QtGui.QLabel(self.gridLayoutWidget_3)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout_3.addWidget(self.label_7, 0, 2, 1, 1)
        
        self.lePrefixo = QtGui.QLineEdit(self.gridLayoutWidget_3)
        self.lePrefixo.setObjectName(_fromUtf8("lePrefixo"))
        self.gridLayout_3.addWidget(self.lePrefixo, 0, 1, 1, 1)
        
        self.label_5 = QtGui.QLabel(self.gridLayoutWidget_3)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout_3.addWidget(self.label_5, 0, 0, 1, 1)
        
        self.leMascara = QtGui.QLineEdit(self.gridLayoutWidget_3)
        self.leMascara.setAutoFillBackground(False)
        self.leMascara.setObjectName(_fromUtf8("leMascara"))
        self.gridLayout_3.addWidget(self.leMascara, 0, 3, 1, 1)
        
        self.tabWidget.addTab(self.tab_3, _fromUtf8(""))
        
        self.tab = QtGui.QWidget()
        self.tab.setObjectName(_fromUtf8("tab"))
        
        self.gridLayoutWidget_2 = QtGui.QWidget(self.tab)
        self.gridLayoutWidget_2.setGeometry(QtCore.QRect(10, 10, 321, 161))
        self.gridLayoutWidget_2.setObjectName(_fromUtf8("gridLayoutWidget_2"))
        
        self.gridLayout_2 = QtGui.QGridLayout(self.gridLayoutWidget_2)
        self.gridLayout_2.setMargin(0)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        
        self.dspASemeadura = QtGui.QDoubleSpinBox(self.gridLayoutWidget_2)
        self.dspASemeadura.setMinimum(-99.99)
        self.dspASemeadura.setObjectName(_fromUtf8("dspASemeadura"))
        self.gridLayout_2.addWidget(self.dspASemeadura, 3, 1, 1, 1)
        
        self.label_4 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout_2.addWidget(self.label_4, 4, 0, 1, 1)
        
        self.dsbAColheita = QtGui.QDoubleSpinBox(self.gridLayoutWidget_2)
        self.dsbAColheita.setMinimum(-99.99)
        self.dsbAColheita.setObjectName(_fromUtf8("dsbAColheita"))
        self.gridLayout_2.addWidget(self.dsbAColheita, 4, 1, 1, 1)
        
        self.label_2 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_2.addWidget(self.label_2, 1, 0, 1, 1)
        
        self.label_10 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.gridLayout_2.addWidget(self.label_10, 2, 0, 1, 1)
        
        self.label_3 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout_2.addWidget(self.label_3, 3, 0, 1, 1)
        
        self.label_9 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.gridLayout_2.addWidget(self.label_9, 0, 0, 1, 1)
        
        self.lePSemeadura = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.lePSemeadura.setObjectName(_fromUtf8("lePSemeadura"))
        self.gridLayout_2.addWidget(self.lePSemeadura, 0, 1, 1, 1)
        
        self.lePPico = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.lePPico.setObjectName(_fromUtf8("lePPico"))
        self.gridLayout_2.addWidget(self.lePPico, 1, 1, 1, 1)
        
        self.lePColheita = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.lePColheita.setObjectName(_fromUtf8("lePColheita"))
        self.gridLayout_2.addWidget(self.lePColheita, 2, 1, 1, 1)
        
        self.leNullValue = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.leNullValue.setInputMask(_fromUtf8(""))
        self.leNullValue.setObjectName(_fromUtf8("leNullValue"))
        
        regexp = QtCore.QRegExp("[0-9]\\d{0,5}")
        validator = QtGui.QRegExpValidator(regexp)
        self.leNullValue.setValidator(validator)
        
        self.gridLayout_2.addWidget(self.leNullValue, 5, 1, 1, 1)
        
        self.label_14 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_14.setObjectName(_fromUtf8("label_14"))
        self.gridLayout_2.addWidget(self.label_14, 5, 0, 1, 1)
        
        self.tabWidget.addTab(self.tab, _fromUtf8(""))
        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName(_fromUtf8("tab_2"))
        self.gridLayoutWidget_4 = QtGui.QWidget(self.tab_2)
        self.gridLayoutWidget_4.setGeometry(QtCore.QRect(10, 10, 331, 100))
        self.gridLayoutWidget_4.setObjectName(_fromUtf8("gridLayoutWidget_4"))
        
        self.gridLayout_4 = QtGui.QGridLayout(self.gridLayoutWidget_4)
        self.gridLayout_4.setMargin(0)
        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
        
        self.label_12 = QtGui.QLabel(self.gridLayoutWidget_4)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.gridLayout_4.addWidget(self.label_12, 2, 0, 1, 1)
        
        self.label_8 = QtGui.QLabel(self.gridLayoutWidget_4)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_4.addWidget(self.label_8, 0, 0, 1, 1)
        
        self.toolbFindOutFolder = QtGui.QPushButton(self.gridLayoutWidget_4)
        self.toolbFindOutFolder.setObjectName(_fromUtf8("toolbFindOutFolder"))
        self.gridLayout_4.addWidget(self.toolbFindOutFolder, 0, 2, 1, 1)
        
        self.leOutFolder = QtGui.QLineEdit(self.gridLayoutWidget_4)
        self.leOutFolder.setObjectName(_fromUtf8("leOutFolder"))
        self.gridLayout_4.addWidget(self.leOutFolder, 0, 1, 1, 1)
        
        self.leImgPico = QtGui.QLineEdit(self.gridLayoutWidget_4)
        self.leImgPico.setObjectName(_fromUtf8("leImgPico"))
        self.gridLayout_4.addWidget(self.leImgPico, 2, 1, 1, 1)
        
        self.label_11 = QtGui.QLabel(self.gridLayoutWidget_4)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.gridLayout_4.addWidget(self.label_11, 1, 0, 1, 1)
        
        self.leImgSemeadura = QtGui.QLineEdit(self.gridLayoutWidget_4)
        self.leImgSemeadura.setObjectName(_fromUtf8("leImgSemeadura"))
        self.gridLayout_4.addWidget(self.leImgSemeadura, 1, 1, 1, 1)
        
        self.label_13 = QtGui.QLabel(self.gridLayoutWidget_4)
        self.label_13.setObjectName(_fromUtf8("label_13"))
        self.gridLayout_4.addWidget(self.label_13, 3, 0, 1, 1)
        
        self.leImgColheita = QtGui.QLineEdit(self.gridLayoutWidget_4)
        self.leImgColheita.setObjectName(_fromUtf8("leImgColheita"))
        self.gridLayout_4.addWidget(self.leImgColheita, 3, 1, 1, 1)
        
        self.tabWidget.addTab(self.tab_2, _fromUtf8(""))
        self.horizontalLayoutWidget = QtGui.QWidget(DlgEstimativaDatasAgricolas)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(10, 220, 351, 41))
        
        self.horizontalLayoutWidget.setObjectName(_fromUtf8("horizontalLayoutWidget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        
        #self.progressBar = QtGui.QProgressBar(self.horizontalLayoutWidget)
        #self.progressBar.setProperty("value", 0)
        #self.progressBar.setMinimum(1)
        #self.progressBar.setMaximum(100)
        #self.progressBar.setObjectName(_fromUtf8("progressBar"))
        #self.horizontalLayout.addWidget(self.progressBar)
        
        self.bbOkCancel = QtGui.QDialogButtonBox(self.horizontalLayoutWidget)
        self.bbOkCancel.setOrientation(QtCore.Qt.Horizontal)
        self.bbOkCancel.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.bbOkCancel.setObjectName(_fromUtf8("bbOkCancel"))
        self.horizontalLayout.addWidget(self.bbOkCancel)
        
        self.retranslateUi(DlgEstimativaDatasAgricolas)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("rejected()")), DlgEstimativaDatasAgricolas.reject)
        QtCore.QMetaObject.connectSlotsByName(DlgEstimativaDatasAgricolas)
        
        self.dsbAColheita.value()

    def retranslateUi(self, DlgEstimativaDatasAgricolas):
        
        DlgEstimativaDatasAgricolas.setWindowTitle(_translate("DlgEstimativaDatasAgricolas", "CyMP - Estimativa de datas da cultura", None))
        self.toolbFindInFolder.setText(_translate("DlgEstimativaDatasAgricolas", "...", None))
        self.label.setText(_translate("DlgEstimativaDatasAgricolas", "Pasta de entrada das imagens:", None))
        self.label_6.setText(_translate("DlgEstimativaDatasAgricolas", "Sufixo:", None))
        self.label_7.setText(_translate("DlgEstimativaDatasAgricolas", "Máscara:", None))
        self.label_5.setText(_translate("DlgEstimativaDatasAgricolas", "Prefixo:", None))
        self.leMascara.setText(_translate("DlgEstimativaDatasAgricolas", "%Y%m%d", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("DlgEstimativaDatasAgricolas", "Dados de pasta", None))
        self.label_4.setText(_translate("DlgEstimativaDatasAgricolas", "Avanço colheita:", None))
        self.label_2.setText(_translate("DlgEstimativaDatasAgricolas", "Posição DMDV:", None))
        self.label_10.setText(_translate("DlgEstimativaDatasAgricolas", "Posição Colheita:", None))
        self.label_3.setText(_translate("DlgEstimativaDatasAgricolas", "Avanço semeadura:", None))
        self.label_9.setText(_translate("DlgEstimativaDatasAgricolas", "Posição Semeadura:", None))
        self.lePSemeadura.setText(_translate("DlgEstimativaDatasAgricolas", "0-3", None))
        self.lePPico.setText(_translate("DlgEstimativaDatasAgricolas", "3-4", None))
        self.lePColheita.setText(_translate("DlgEstimativaDatasAgricolas", "4-6", None))
        self.label_14.setText(_translate("DlgEstimativaDatasAgricolas", "Valor Nulo:", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("DlgEstimativaDatasAgricolas", "Configuração", None))
        self.label_12.setText(_translate("DlgEstimativaDatasAgricolas", "Nome imagem de DMDV:", None))
        self.label_8.setText(_translate("DlgEstimativaDatasAgricolas", "Pasta de saída das imagens:", None))
        self.toolbFindOutFolder.setText(_translate("DlgEstimativaDatasAgricolas", "...", None))
        self.label_11.setText(_translate("DlgEstimativaDatasAgricolas", "Nome imagem de Semeadura", None))
        self.label_13.setText(_translate("DlgEstimativaDatasAgricolas", "Nome imagem de colheita:", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("DlgEstimativaDatasAgricolas", "Dados de saída", None))
        
        self.leImgColheita.setText("colheita")
        self.leImgPico.setText("pico")
        self.leImgSemeadura.setText("semeadura")
        self.lePrefixo.setText("")
        self.leSufixo.setText("")
        self.leNullValue.setText("0")
        
                
        #self.config = ConfigParser.RawConfigParser()
        #self.config.read('workspace.properties')
        
        #workspace = self.config.get('WorkSpace', 'space.default')
        #raster = workspace + self.config.get('WorkSpace', 'space.raster')
        #out = workspace + self.config.get('WorkSpace', 'space.out')
        
        #self.leInFolder.setText(raster)
        #self.leOutFolder.setText(out)
        
        self.toolbFindInFolder.clicked.connect(self.controller.findInFolder)
        self.toolbFindOutFolder.clicked.connect(self.controller.findOutFolder)
        

------------------  DlgETc.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgETc.ui'
#
# Created: Wed Nov 11 00:58:52 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConEtc import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        

        Dialog.resize(371, 290)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)      
        self.gridLayout = QtGui.QGridLayout()
        self.verticalLayout.addLayout(self.gridLayout)
        
        self.rbEtc = QtGui.QRadioButton(Dialog)
        self.gridLayout.addWidget(self.rbEtc, 0,0,1,1)
        self.rbEtc.setChecked(True)

        self.rbEta = QtGui.QRadioButton(Dialog)
        self.gridLayout.addWidget(self.rbEta, 0,1,1,1)        
        
        self.label = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label, 1, 0, 1, 1)
        
        self.label_2 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
        
        self.btnConfET0 = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfET0, 2, 1, 1, 1)
        
        self.chET0 = QtGui.QCheckBox(Dialog)
        self.chET0.setEnabled(False)
        self.gridLayout.addWidget(self.chET0, 2, 2, 1, 1)
        
        self.label_3 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_3, 3, 0, 1, 1)
        
        self.btnConfKc = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfKc, 3, 1, 1, 1)
        
        self.chKc = QtGui.QCheckBox(Dialog)
        self.chKc.setEnabled(False)
        self.gridLayout.addWidget(self.chKc, 3, 2, 1, 1)
        
        self.label_4 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_4, 4, 0, 1, 1)
        
        self.label_5 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_5, 5, 0, 1, 1)
        
        self.btnConfETc = QtGui.QPushButton(Dialog)
        self.gridLayout.addWidget(self.btnConfETc, 5, 1, 1, 1)
        
        self.chETc = QtGui.QCheckBox(Dialog)
        self.chETc.setEnabled(False)
        self.gridLayout.addWidget(self.chETc, 5, 2, 1, 1)

        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.gridLayout.addItem(spacerItem, 6, 1, 1, 1)
        

        
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)

        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.btnConfET0.clicked.connect(self.controller.setSerieET0)
        self.btnConfKc.clicked.connect(self.controller.setSerie_Kc)
        self.btnConfETc.clicked.connect(self.controller.setSerie_ETc)
        
        self.rbEta.clicked.connect(self.controller.MudaPraETa)
        self.rbEtc.clicked.connect(self.controller.MudaPraETc)
        
        self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Evapotranspiração", None))
        self.label_4.setText(_translate("Dialog", "Configuração de saída:", None))
        self.label_5.setText(_translate("Dialog", "Imagens diárias de ETc", None))
        self.btnConfETc.setText(_translate("Dialog", "Configurar", None))
        self.chETc.setText(_translate("Dialog", "Configurado", None))
        self.label.setText(_translate("Dialog", "Configuração de entrada", None))
        self.label_2.setText(_translate("Dialog", "Imagens diárias de ET0", None))
        self.btnConfET0.setText(_translate("Dialog", "Configurar", None))
        self.chET0.setText(_translate("Dialog", "Configurado", None))
        self.label_3.setText(_translate("Dialog", "Imagens diárias de Kc", None))
        self.btnConfKc.setText(_translate("Dialog", "Configurar", None))
        self.chKc.setText(_translate("Dialog", "Configurado", None))
        
        self.rbEta.setText(_translate("Dialog", "ETa (FAO)", None))
        self.rbEtc.setText(_translate("Dialog", "ETc", None))



------------------  DlgFiltroSavitzGolay.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\Paloschi\Desktop\Gafanhoto\Software\Gafanhoto_1.0\InterfacesQT\DlgFiltroSavitzGolay.ui'
#
# Created: Fri Jun 12 14:10:00 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle import ConFiltroSavitzGolay

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_DlgSavitzGolay(QtGui.QDialog):
    def setupUi(self, DlgSavitzGolay):
        
        self.controller = ConFiltroSavitzGolay.Controller(self);
        
        DlgSavitzGolay.setObjectName(_fromUtf8("DlgSavitzGolay"))
        DlgSavitzGolay.setWindowModality(QtCore.Qt.WindowModal)
        DlgSavitzGolay.resize(371, 278)
        DlgSavitzGolay.setMinimumSize(QtCore.QSize(50, 0))
        DlgSavitzGolay.setSizeIncrement(QtCore.QSize(1, 0))
        DlgSavitzGolay.setBaseSize(QtCore.QSize(50, 0))
        DlgSavitzGolay.setStyleSheet(_fromUtf8(""))
        
        
        self.tabWidget = QtGui.QTabWidget(DlgSavitzGolay)
        self.tabWidget.setGeometry(QtCore.QRect(10, 10, 351, 201))
        self.tabWidget.setObjectName(_fromUtf8("tabWidget"))
        self.tab_3 = QtGui.QWidget()
        self.tab_3.setObjectName(_fromUtf8("tab_3"))
        self.gridLayoutWidget = QtGui.QWidget(self.tab_3)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(10, 10, 331, 51))
        self.gridLayoutWidget.setObjectName(_fromUtf8("gridLayoutWidget"))
        self.gridLayout = QtGui.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.leInFolder = QtGui.QLineEdit(self.gridLayoutWidget)
        self.leInFolder.setObjectName(_fromUtf8("leInFolder"))
        self.gridLayout.addWidget(self.leInFolder, 0, 1, 1, 1)
        self.toolbFindInFolder = QtGui.QToolButton(self.gridLayoutWidget)
        self.toolbFindInFolder.setObjectName(_fromUtf8("toolbFindInFolder"))
        self.gridLayout.addWidget(self.toolbFindInFolder, 0, 2, 1, 1)
        self.label = QtGui.QLabel(self.gridLayoutWidget)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.tabWidget.addTab(self.tab_3, _fromUtf8(""))
        
        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName(_fromUtf8("tab_2"))
        self.gridLayoutWidget_4 = QtGui.QWidget(self.tab_2)
        self.gridLayoutWidget_4.setGeometry(QtCore.QRect(10, 10, 331, 100))
        self.gridLayoutWidget_4.setObjectName(_fromUtf8("gridLayoutWidget_4"))
        self.gridLayout_4 = QtGui.QGridLayout(self.gridLayoutWidget_4)
        self.gridLayout_4.setMargin(0)
        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
        self.label_8 = QtGui.QLabel(self.gridLayoutWidget_4)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_4.addWidget(self.label_8, 0, 0, 1, 1)
        self.toolbFindOutFolder = QtGui.QToolButton(self.gridLayoutWidget_4)
        self.toolbFindOutFolder.setObjectName(_fromUtf8("toolbFindOutFolder"))
        self.gridLayout_4.addWidget(self.toolbFindOutFolder, 0, 2, 1, 1)
        self.leOutFolder = QtGui.QLineEdit(self.gridLayoutWidget_4)
        self.leOutFolder.setObjectName(_fromUtf8("leOutFolder"))
        self.gridLayout_4.addWidget(self.leOutFolder, 0, 1, 1, 1)
        self.tabWidget.addTab(self.tab_2, _fromUtf8(""))
        
        self.tab = QtGui.QWidget()
        self.tab.setObjectName(_fromUtf8("tab"))
        self.gridLayoutWidget_2 = QtGui.QWidget(self.tab)
        self.gridLayoutWidget_2.setGeometry(QtCore.QRect(10, 10, 321, 161))
        self.gridLayoutWidget_2.setObjectName(_fromUtf8("gridLayoutWidget_2"))
        self.gridLayout_2 = QtGui.QGridLayout(self.gridLayoutWidget_2)
        self.gridLayout_2.setMargin(0)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_2 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_2.addWidget(self.label_2, 1, 0, 1, 1)
        self.label_9 = QtGui.QLabel(self.gridLayoutWidget_2)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.gridLayout_2.addWidget(self.label_9, 0, 0, 1, 1)
        self.leWindowSize = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.leWindowSize.setObjectName(_fromUtf8("leWindowSize"))
        self.gridLayout_2.addWidget(self.leWindowSize, 0, 1, 1, 1)
        self.leOrdem = QtGui.QLineEdit(self.gridLayoutWidget_2)
        self.leOrdem.setObjectName(_fromUtf8("leOrdem"))
        self.gridLayout_2.addWidget(self.leOrdem, 1, 1, 1, 1)
        #self.leNullValue = QtGui.QLineEdit(self.gridLayoutWidget_2)
        #self.leNullValue.setInputMask(_fromUtf8(""))
        #self.leNullValue.setObjectName(_fromUtf8("leNullValue"))
        #self.leNullValue.setEnabled(False)
        
        #self.gridLayout_2.addWidget(self.leNullValue, 2, 1, 1, 1)
        #self.label_14 = QtGui.QLabel(self.gridLayoutWidget_2)
        #self.label_14.setObjectName(_fromUtf8("label_14"))
        #self.label_14.setEnabled(False)
        #self.gridLayout_2.addWidget(self.label_14, 2, 0, 1, 1)
        #self.checkBox = QtGui.QCheckBox(self.gridLayoutWidget_2)
        #self.checkBox.setText(_fromUtf8(""))
        #self.checkBox.setObjectName(_fromUtf8("checkBox"))
        #self.checkBox.setEnabled(False)
        #self.gridLayout_2.addWidget(self.checkBox, 2, 2, 1, 1)
        self.tabWidget.addTab(self.tab, _fromUtf8(""))
        
        
        self.horizontalLayoutWidget = QtGui.QWidget(DlgSavitzGolay)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(10, 220, 351, 41))
        self.horizontalLayoutWidget.setObjectName(_fromUtf8("horizontalLayoutWidget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        #self.progressBar = QtGui.QProgressBar(self.horizontalLayoutWidget)
        #self.progressBar.setProperty("value", 24)
        #self.progressBar.setObjectName(_fromUtf8("progressBar"))
        #self.horizontalLayout.addWidget(self.progressBar)
        #self.progressBar.setEnabled(False)
        self.bbOkCancel = QtGui.QDialogButtonBox(self.horizontalLayoutWidget)
        self.bbOkCancel.setOrientation(QtCore.Qt.Horizontal)
        self.bbOkCancel.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.bbOkCancel.setObjectName(_fromUtf8("bbOkCancel"))
        self.horizontalLayout.addWidget(self.bbOkCancel)

        self.retranslateUi(DlgSavitzGolay)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.bbOkCancel, QtCore.SIGNAL(_fromUtf8("rejected()")), DlgSavitzGolay.reject)
        QtCore.QMetaObject.connectSlotsByName(DlgSavitzGolay)

    def retranslateUi(self, DlgEstimativaDatasAgricolas):
        DlgEstimativaDatasAgricolas.setWindowTitle(_translate("DlgEstimativaDatasAgricolas", "CyMP - Filtro Savitzky-golay", None))
        self.toolbFindInFolder.setText(_translate("DlgEstimativaDatasAgricolas", "...", None))
        self.label.setText(_translate("DlgEstimativaDatasAgricolas", "Pasta de entrada das imagens:", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("DlgEstimativaDatasAgricolas", "Dados de pasta", None))
        self.label_2.setText(_translate("DlgEstimativaDatasAgricolas", "Ordem:", None))
        self.label_9.setText(_translate("DlgEstimativaDatasAgricolas", "Tamanho da janela:", None))
        self.leWindowSize.setText(_translate("DlgEstimativaDatasAgricolas", "5", None))
        self.leOrdem.setText(_translate("DlgEstimativaDatasAgricolas", "3", None))
        #self.label_14.setText(_translate("DlgEstimativaDatasAgricolas", "Valor Nulo:", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("DlgEstimativaDatasAgricolas", "Configuração", None))
        self.label_8.setText(_translate("DlgEstimativaDatasAgricolas", "Pasta de saída das imagens:", None))
        self.toolbFindOutFolder.setText(_translate("DlgEstimativaDatasAgricolas", "...", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("DlgEstimativaDatasAgricolas", "Dados de saída", None))
        
        
        #self.leInFolder.setText("C:\\Gafanhoto WorkSpace\\Soja11_12\\Modis\\6-EVI_AQUA_TERRA_11-12_FLAT_MASK_SOJA")
        #self.leInFolder.setText("C:\\Gafanhoto Workspace\\Soja11_12\\ECMWF\\2-CORTADAS_11-12")
        #self.leOutFolder.setText("C:\Gafanhoto WorkSpace\Soja11_12\Modis\8-EVI_AQUA_TERRA_11-12_FLAT_MASK_SOJA_Comp_Savitzk")
        
        #self.checkBox.clicked.connect(self.controller.actionCheckBox)
        self.toolbFindInFolder.clicked.connect(self.controller.findInFolder)
        self.toolbFindOutFolder.clicked.connect(self.controller.findOutFolder)

------------------  DlgInvdistnnRaster2Raster.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Gafanhoto2.2InterpoladorInvdistnnRasterToRaster.ui'
#
# Created: Tue Oct 13 12:55:39 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle import ConInvdistnnRaster2Raster
from PyQt4.Qt import QLocale, QTranslator

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)



class Ui_InvdistnnRaster2Raster(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        locale = QLocale.system().name()
        qtTranslator = QTranslator()
        if qtTranslator.load("qt_"+locale):
            Dialog.installTranslator(qtTranslator)
        
        self.controller = ConInvdistnnRaster2Raster.Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.TabContent = QtGui.QTabWidget(Dialog)
        self.TabContent.setObjectName(_fromUtf8("TabContent"))
        self.tab_4 = QtGui.QWidget()
        self.tab_4.setObjectName(_fromUtf8("tab_4"))
        self.gridLayout_2 = QtGui.QGridLayout(self.tab_4)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.textBrowser = QtGui.QTextBrowser(self.tab_4)
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        self.gridLayout_2.addWidget(self.textBrowser, 0, 0, 2, 2)
        self.TabContent.addTab(self.tab_4, _fromUtf8(""))
        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName(_fromUtf8("tab_2"))
        self.gridLayout_3 = QtGui.QGridLayout(self.tab_2)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.label_6 = QtGui.QLabel(self.tab_2)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_3.addWidget(self.label_6, 1, 0, 1, 1)
        
        self.txInFolder = QtGui.QLineEdit(self.tab_2)
        self.txInFolder.setObjectName(_fromUtf8("txInFolder"))
        self.gridLayout_3.addWidget(self.txInFolder, 0, 1, 1, 1)
        
        self.txOutFolder = QtGui.QLineEdit(self.tab_2)
        self.txOutFolder.setObjectName(_fromUtf8("txOutFolder"))
        self.gridLayout_3.addWidget(self.txOutFolder, 1, 1, 1, 1)
        self.label_2 = QtGui.QLabel(self.tab_2)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_3.addWidget(self.label_2, 0, 0, 1, 1)
        self.btFindInFolder = QtGui.QToolButton(self.tab_2)
        self.btFindInFolder.setObjectName(_fromUtf8("btFindInFolder"))
        self.gridLayout_3.addWidget(self.btFindInFolder, 0, 2, 1, 1)
        self.btFindOutFolder = QtGui.QToolButton(self.tab_2)
        self.btFindOutFolder.setObjectName(_fromUtf8("btFindOutFolder"))
        self.gridLayout_3.addWidget(self.btFindOutFolder, 1, 2, 1, 1)
        self.TabContent.addTab(self.tab_2, _fromUtf8(""))
        self.tab_3 = QtGui.QWidget()
        self.tab_3.setObjectName(_fromUtf8("tab_3"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.tab_3)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.rbImgReference = QtGui.QRadioButton(self.tab_3)
        self.rbImgReference.setChecked(True)
        self.rbImgReference.setObjectName(_fromUtf8("rbImgReference"))
        self.verticalLayout_2.addWidget(self.rbImgReference)
        self.groupBox_2 = QtGui.QGroupBox(self.tab_3)
        self.groupBox_2.setTitle(_fromUtf8(""))
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.gridLayout_5 = QtGui.QGridLayout(self.groupBox_2)
        self.gridLayout_5.setObjectName(_fromUtf8("gridLayout_5"))
        self.btFindImgReference = QtGui.QToolButton(self.groupBox_2)
        self.btFindImgReference.setObjectName(_fromUtf8("btFindImgReference"))
        self.gridLayout_5.addWidget(self.btFindImgReference, 0, 3, 1, 1)
        self.txImgReference = QtGui.QLineEdit(self.groupBox_2)
        self.txImgReference.setObjectName(_fromUtf8("txImgReference"))
        self.gridLayout_5.addWidget(self.txImgReference, 0, 2, 1, 1)
        self.label_7 = QtGui.QLabel(self.groupBox_2)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout_5.addWidget(self.label_7, 0, 0, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_2)
        self.rbManualConf = QtGui.QRadioButton(self.tab_3)
        self.rbManualConf.setEnabled(False)
        self.rbManualConf.setChecked(False)
        self.rbManualConf.setObjectName(_fromUtf8("rbManualConf"))
        self.verticalLayout_2.addWidget(self.rbManualConf)
        self.groupBox_3 = QtGui.QGroupBox(self.tab_3)
        self.groupBox_3.setEnabled(False)
        self.groupBox_3.setTitle(_fromUtf8(""))
        self.groupBox_3.setObjectName(_fromUtf8("groupBox_3"))
        self.gridLayout_6 = QtGui.QGridLayout(self.groupBox_3)
        self.gridLayout_6.setObjectName(_fromUtf8("gridLayout_6"))
        self.label_10 = QtGui.QLabel(self.groupBox_3)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.gridLayout_6.addWidget(self.label_10, 1, 0, 1, 1)
        self.label_9 = QtGui.QLabel(self.groupBox_3)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.gridLayout_6.addWidget(self.label_9, 2, 0, 1, 1)
        self.label_12 = QtGui.QLabel(self.groupBox_3)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.gridLayout_6.addWidget(self.label_12, 1, 2, 1, 1)
        self.label_13 = QtGui.QLabel(self.groupBox_3)
        self.label_13.setObjectName(_fromUtf8("label_13"))
        self.gridLayout_6.addWidget(self.label_13, 2, 2, 1, 1)
        self.label_11 = QtGui.QLabel(self.groupBox_3)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.gridLayout_6.addWidget(self.label_11, 0, 2, 1, 1)
        self.label_8 = QtGui.QLabel(self.groupBox_3)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_6.addWidget(self.label_8, 0, 0, 1, 1)
        self.txXinit = QtGui.QLineEdit(self.groupBox_3)
        self.txXinit.setObjectName(_fromUtf8("txXinit"))
        self.gridLayout_6.addWidget(self.txXinit, 0, 1, 1, 1)
        self.txYinit = QtGui.QLineEdit(self.groupBox_3)
        self.txYinit.setObjectName(_fromUtf8("txYinit"))
        self.gridLayout_6.addWidget(self.txYinit, 1, 1, 1, 1)
        self.txLinesNumber = QtGui.QLineEdit(self.groupBox_3)
        self.txLinesNumber.setObjectName(_fromUtf8("txLinesNumber"))
        self.gridLayout_6.addWidget(self.txLinesNumber, 2, 1, 1, 1)
        self.txXend = QtGui.QLineEdit(self.groupBox_3)
        self.txXend.setObjectName(_fromUtf8("txXend"))
        self.gridLayout_6.addWidget(self.txXend, 0, 3, 1, 1)
        self.txYend = QtGui.QLineEdit(self.groupBox_3)
        self.txYend.setObjectName(_fromUtf8("txYend"))
        self.gridLayout_6.addWidget(self.txYend, 1, 3, 1, 1)
        self.txColumnsNumber = QtGui.QLineEdit(self.groupBox_3)
        self.txColumnsNumber.setObjectName(_fromUtf8("txColumnsNumber"))
        self.gridLayout_6.addWidget(self.txColumnsNumber, 2, 3, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_3)
        self.TabContent.addTab(self.tab_3, _fromUtf8(""))
        self.tab = QtGui.QWidget()
        self.tab.setObjectName(_fromUtf8("tab"))
        self.gridLayout = QtGui.QGridLayout(self.tab)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_3 = QtGui.QLabel(self.tab)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.label_4 = QtGui.QLabel(self.tab)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.label_5 = QtGui.QLabel(self.tab)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.txPower = QtGui.QDoubleSpinBox(self.tab)
        self.txPower.setProperty("value", 2.0)
        self.txPower.setObjectName(_fromUtf8("txPower"))
        self.gridLayout.addWidget(self.txPower, 1, 1, 1, 1)
        self.txRadius = QtGui.QDoubleSpinBox(self.tab)
        self.txRadius.setObjectName(_fromUtf8("txRadius"))
        self.gridLayout.addWidget(self.txRadius, 2, 1, 1, 1)
        self.txMaxPoint = QtGui.QSpinBox(self.tab)
        self.txMaxPoint.setProperty("value", 12)
        self.txMaxPoint.setObjectName(_fromUtf8("txMaxPoint"))
        self.gridLayout.addWidget(self.txMaxPoint, 3, 1, 1, 1)
        self.txMinPoint = QtGui.QSpinBox(self.tab)
        self.txMinPoint.setObjectName(_fromUtf8("txMinPoint"))
        self.gridLayout.addWidget(self.txMinPoint, 4, 1, 1, 1)
        self.label = QtGui.QLabel(self.tab)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 1, 0, 1, 1)
        self.TabContent.addTab(self.tab, _fromUtf8(""))
        self.verticalLayout.addWidget(self.TabContent)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setContextMenuPolicy(QtCore.Qt.DefaultContextMenu)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        self.TabContent.setCurrentIndex(0)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.controller.set_param()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Interpolador raster pra raster", None))
        self.textBrowser.setHtml(_translate("Dialog", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;\"><span style=\" font-family:\'Lucida Grande,Verdana,Geneva,Arial,sans-serif\'; font-size:8pt; font-weight:600; color:#000000; background-color:#ffffff;\">Invdistnn</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11pt;\">Interpolador raster pra raster (série de imagens)</span></p>\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11pt;\"><br /></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11pt;\">Inverso da distância para uma potência com procura de vizinho mais próximo</span></p>\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11pt;\"><br /></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11pt;\">Inverse distance to a power with nearest neighbor searching.</span></p>\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11pt;\"><br /></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:\'Times New Roman\'; font-size:11pt; color:#000000;\">Mais informações: http://www.gdal.org/gdal_grid.html</span></a></p></body></html>", None))
        self.TabContent.setTabText(self.TabContent.indexOf(self.tab_4), _translate("Dialog", "Descrição", None))
        
        
        self.label_6.setText(_translate("Dialog", "Pasta de saída das imagens", None))
        self.label_2.setText(_translate("Dialog", "Pasta de entrada das imagens", None))
        self.btFindInFolder.setText(_translate("Dialog", "...", None))
        self.btFindOutFolder.setText(_translate("Dialog", "...", None))
        self.TabContent.setTabText(self.TabContent.indexOf(self.tab_2), _translate("Dialog", "Conf. pasta", None))
        self.rbImgReference.setText(_translate("Dialog", "Por imagem de referencia", None))
        self.btFindImgReference.setText(_translate("Dialog", "...", None))
        self.label_7.setText(_translate("Dialog", "Imagem:", None))
        self.rbManualConf.setText(_translate("Dialog", "Configuração manual", None))
        self.label_10.setText(_translate("Dialog", "Y Inicial:", None))
        self.label_9.setText(_translate("Dialog", "N. de linhas:", None))
        self.label_12.setText(_translate("Dialog", "Y Final:", None))
        self.label_13.setText(_translate("Dialog", "N. de Colunas:", None))
        self.label_11.setText(_translate("Dialog", "X Final:", None))
        self.label_8.setText(_translate("Dialog", "X Inicial:", None))
        self.TabContent.setTabText(self.TabContent.indexOf(self.tab_3), _translate("Dialog", "Conf. Imagem", None))
        self.label_3.setText(_translate("Dialog", "Raio:", None))
        self.label_4.setText(_translate("Dialog", "Máximo de pontos:", None))
        self.label_5.setText(_translate("Dialog", "Mínimo de pontos:", None))
        self.label.setText(_translate("Dialog", "Força:", None))
        self.TabContent.setTabText(self.TabContent.indexOf(self.tab), _translate("Dialog", "Conf. interpolador", None))
        
        self.btFindInFolder.clicked.connect(self.controller.findInFolder)
        self.btFindOutFolder.clicked.connect(self.controller.findOutFolder)
        self.btFindImgReference.clicked.connect(self.controller.findImgRef)
        
        #self.txInFolder.setText("C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\2-CORTADAS_11-12")
        #self.txOutFolder.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\out\\Primeira tentativa")
        #self.txImgReference.setText("C:\\Gafanhoto WorkSpace\\DataTestes\\out\\colheita.tif")


------------------  DlgInvdistnnShapeEcmwf2Raster.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'interpoladorECMWF_Demo.ui'
#
# Created: Fri Mar 06 22:12:54 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle import ConInvdistnnShapeEcmwf2Raster

 
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class UI_DlgInterpoladorShapeEcmwf(QtGui.QDialog):
        
    def setupUi(self, Form):
        
        self.controller = ConInvdistnnShapeEcmwf2Raster.Controller(self)
        
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(436, 361)
        self.leShapePath = QtGui.QLineEdit(Form)
        self.leShapePath.setGeometry(QtCore.QRect(10, 40, 301, 20))
        self.leShapePath.setObjectName(_fromUtf8("leShapePath"))
        self.cbAtribute = QtGui.QComboBox(Form)
        self.cbAtribute.setEnabled(False)
        self.cbAtribute.setGeometry(QtCore.QRect(10, 90, 331, 22))
        self.cbAtribute.setObjectName(_fromUtf8("cbAtribute"))
        self.btnFindShp = QtGui.QPushButton(Form)
        self.btnFindShp.setGeometry(QtCore.QRect(330, 40, 75, 23))
        self.btnFindShp.setObjectName(_fromUtf8("btnFindShp"))
        self.bbOkCancela = QtGui.QDialogButtonBox(Form)
        self.bbOkCancela.setGeometry(QtCore.QRect(190, 330, 156, 23))
        self.bbOkCancela.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.bbOkCancela.setObjectName(_fromUtf8("bbOkCancela"))
        self.lwGroupAtributes = QtGui.QListWidget(Form)
        self.lwGroupAtributes.setEnabled(False)
        self.lwGroupAtributes.setGeometry(QtCore.QRect(10, 230, 331, 71))
        self.lwGroupAtributes.setObjectName(_fromUtf8("lwGroupAtributes"))
        self.label_2 = QtGui.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(10, 200, 161, 16))
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.label_3 = QtGui.QLabel(Form)
        self.label_3.setGeometry(QtCore.QRect(10, 70, 131, 16))
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.verticalLayoutWidget = QtGui.QWidget(Form)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(120, 40, 2, 2))
        self.verticalLayoutWidget.setObjectName(_fromUtf8("verticalLayoutWidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setSpacing(2)
        self.verticalLayout.setMargin(0)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.label = QtGui.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(10, 10, 81, 21))
        self.label.setObjectName(_fromUtf8("label"))
        self.label_4 = QtGui.QLabel(Form)
        self.label_4.setGeometry(QtCore.QRect(10, 130, 111, 16))
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.leImgRefPath = QtGui.QLineEdit(Form)
        self.leImgRefPath.setGeometry(QtCore.QRect(10, 150, 301, 20))
        self.leImgRefPath.setObjectName(_fromUtf8("leImgRefPath"))
        self.btnFindImgRef = QtGui.QPushButton(Form)
        self.btnFindImgRef.setGeometry(QtCore.QRect(330, 150, 75, 23))
        self.btnFindImgRef.setObjectName(_fromUtf8("btnFindImgRef"))

        QtCore.QObject.connect(self.bbOkCancela, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.bbOkCancela, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        
        self.controller.inicializar()

    def retranslateUi(self, Form):
        
        Form.setWindowTitle(_translate("Form", "CyMP - Interpolador shape ECMWF para raster", None))
        self.btnFindShp.setText(_translate("Form", "Procurar", None))
        self.label_2.setText(_translate("Form", "Agrupar dados pelor atributos:", None))
        self.label_3.setText(_translate("Form", "Atributo a ser interpolado", None))
        self.label.setText(_translate("Form", "Shape ECMWF", None))
        self.label_4.setText(_translate("Form", "Imagem de referencia", None))
        self.btnFindImgRef.setText(_translate("Form", "Procurar", None))
        
        self.btnFindShp.clicked.connect(self.controller.btn_FindShp_ClickAction)
        self.btnFindImgRef.clicked.connect(self.controller.btn_FindImgRef_ClickAction)
        self.leShapePath.textChanged.connect(self.controller.le_shapePath_ChangeAction)
        self.leImgRefPath.textChanged.connect(self.controller.le_imgRefPath_ChangeAction)
        self.cbAtribute.currentIndexChanged.connect(self.controller.cb_Atribute_ChangeAction)
        
    #def contextMenuEvent(self, event):
         
        #menu = QMenu(self)
        #quitAction = menu.addAction("Quit")
        #action = menu.exec_(self.mapToGlobal(event.pos()))
        #if action == quitAction:
            #pass
            #qApp.quit()

------------------  DlgKs.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgKs.ui'
#
# Created: Wed Nov 18 11:12:14 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConKs import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(451, 273)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.chTAW = QtGui.QCheckBox(Dialog)
        self.chTAW.setEnabled(False)
        self.chTAW.setObjectName(_fromUtf8("chTAW"))
        self.gridLayout.addWidget(self.chTAW, 3, 2, 1, 1)
        self.btnConfRAW = QtGui.QPushButton(Dialog)
        self.btnConfRAW.setObjectName(_fromUtf8("btnConfRAW"))
        self.gridLayout.addWidget(self.btnConfRAW, 2, 1, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.chKs = QtGui.QCheckBox(Dialog)
        self.chKs.setEnabled(False)
        self.chKs.setObjectName(_fromUtf8("chKs"))
        self.gridLayout.addWidget(self.chKs, 5, 2, 1, 1)
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.btnConfTAW = QtGui.QPushButton(Dialog)
        self.btnConfTAW.setObjectName(_fromUtf8("btnConfTAW"))
        self.gridLayout.addWidget(self.btnConfTAW, 3, 1, 1, 1)
        self.btnConfDr = QtGui.QPushButton(Dialog)
        self.btnConfDr.setObjectName(_fromUtf8("btnConfDr"))
        self.gridLayout.addWidget(self.btnConfDr, 1, 1, 1, 1)
        self.label_6 = QtGui.QLabel(Dialog)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout.addWidget(self.label_6, 5, 0, 1, 1)
        self.chRAW = QtGui.QCheckBox(Dialog)
        self.chRAW.setEnabled(False)
        self.chRAW.setObjectName(_fromUtf8("chRAW"))
        self.gridLayout.addWidget(self.chRAW, 2, 2, 1, 1)
        self.btnConfKs = QtGui.QPushButton(Dialog)
        self.btnConfKs.setObjectName(_fromUtf8("btnConfKs"))
        self.gridLayout.addWidget(self.btnConfKs, 5, 1, 1, 1)
        self.chDr = QtGui.QCheckBox(Dialog)
        self.chDr.setEnabled(False)
        self.chDr.setObjectName(_fromUtf8("chDr"))
        self.gridLayout.addWidget(self.chDr, 1, 2, 1, 1)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.gridLayout.addItem(spacerItem, 6, 0, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.btnConfTAW.clicked.connect(self.controller.setSerie_TAW)
        self.btnConfDr.clicked.connect(self.controller.setSerie_Dr)
        self.btnConfKs.clicked.connect(self.controller.setSerie_Ks)
        self.btnConfRAW.clicked.connect(self.controller.setSerieRAW)
        
        #self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Fator de estresse hídrico da cultura (Ks)", None))
        self.chTAW.setText(_translate("Dialog", "configurado", None))
        self.btnConfRAW.setText(_translate("Dialog", "configurar", None))
        self.label.setText(_translate("Dialog", "Configuração de entrada:", None))
        self.chKs.setText(_translate("Dialog", "configurado", None))
        self.label_2.setText(_translate("Dialog", "Série de imagens Dr:", None))
        self.label_3.setText(_translate("Dialog", "Série de imagens RAW:", None))
        self.label_4.setText(_translate("Dialog", "Série de imagens TAW:", None))
        self.label_5.setText(_translate("Dialog", "Configuração de saída:", None))
        self.btnConfTAW.setText(_translate("Dialog", "configurar", None))
        self.btnConfDr.setText(_translate("Dialog", "configurar", None))
        self.label_6.setText(_translate("Dialog", "Série de Imagens de Ks:", None))
        self.chRAW.setText(_translate("Dialog", "configurado", None))
        self.btnConfKs.setText(_translate("Dialog", "configurar", None))
        self.chDr.setText(_translate("Dialog", "configurado", None))



------------------  DlgNovaSerieTemporal.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgNovaSerieTempora.ui'
#
# Created: Mon Nov 09 11:00:26 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Modelo.beans.SerialFileData import SerialTemporalFiles
from PyQt4.Qt import QDialog
import os
import ConfigParser
from PyQt4.Qt import QString

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QDialog):
    
    SerieTemporal = None
        
    def ok(self):
        
        if not os.path.exists(str(self.txIn.text())):
            self.message(u"Pasta especificada não encontrada")
            return False  
        
        self.SerieTemporal = SerialTemporalFiles()
        self.SerieTemporal.root_path = str(self.txIn.text())
        self.SerieTemporal.prefixo = str(self.txPrefixo.text())
        self.SerieTemporal.sufixo = str(self.txSufixo.text())
        self.SerieTemporal.mutiply_factor = self.txFatorMultiplicador.value()
        self.SerieTemporal.date_mask = str(self.cbMascara.currentText())
        
        self.close()
        
        return self.SerieTemporal
    
    def setForm(self, serieTemporal):
    
        if serieTemporal is not None:
            self.SerieTemporal = serieTemporal
            self.txIn.setText(serieTemporal.root_path)
            self.txPrefixo.setText(serieTemporal.prefixo)
            self.txSufixo.setText(serieTemporal.sufixo)
            self.txFatorMultiplicador.setValue(serieTemporal.mutiply_factor)
            index = self.cbMascara.findText(serieTemporal.date_mask)
            if(index>0):
                self.cbMascara.setCurrentIndex(index)
            else :
                self.cbMascara.setCurrentIndex(1)
                self.cbMascara.setItemText(1, serieTemporal.date_mask)
        
        

    def message(self, text):
        text = QString(text)
        QtGui.QMessageBox.about(self, "Ops...", text)       
    
    def findPath(self):
        config = ConfigParser.RawConfigParser()
        config.read('workspace.properties')
        workspace=config.get('WorkSpace', 'space.default')
        fname = QtGui.QFileDialog.getExistingDirectory(None, "Escolha uma pasta", workspace,)
        if fname!="" :
            self.txIn.setText (fname)
 
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.setWindowModality(QtCore.Qt.WindowModal)
        Dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.tbIn = QtGui.QToolButton(Dialog)
        self.tbIn.setObjectName(_fromUtf8("tbIn"))
        self.gridLayout.addWidget(self.tbIn, 0, 2, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.txIn = QtGui.QLineEdit(Dialog)
        self.txIn.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.txIn.setText(_fromUtf8(""))
        self.txIn.setObjectName(_fromUtf8("txIn"))
        self.gridLayout.addWidget(self.txIn, 0, 1, 1, 1)
        self.txPrefixo = QtGui.QLineEdit(Dialog)
        self.txPrefixo.setObjectName(_fromUtf8("txPrefixo"))
        self.gridLayout.addWidget(self.txPrefixo, 1, 1, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.txSufixo = QtGui.QLineEdit(Dialog)
        self.txSufixo.setObjectName(_fromUtf8("txSufixo"))
        self.gridLayout.addWidget(self.txSufixo, 2, 1, 1, 1)
        self.cbMascara = QtGui.QComboBox(Dialog)
        self.cbMascara.setEditable(True)
        self.cbMascara.setObjectName(_fromUtf8("cbMascara"))
        self.cbMascara.addItem(_fromUtf8(""))
        self.cbMascara.addItem(_fromUtf8(""))
        self.gridLayout.addWidget(self.cbMascara, 3, 1, 1, 1)
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.txFatorMultiplicador = QtGui.QDoubleSpinBox(Dialog)
        self.txFatorMultiplicador.setMaximum(1000)
        self.txFatorMultiplicador.setObjectName(_fromUtf8("txFatorMultiplicador"))
        self.gridLayout.addWidget(self.txFatorMultiplicador, 4, 1, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)
        self.txFatorMultiplicador.setValue(1)
        
        self.label_6 = QtGui.QLabel(Dialog)
        self.gridLayout.addWidget(self.label_6, 5, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.tbIn.clicked.connect(self.findPath)

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Nova série temporal", None))
        self.tbIn.setText(_translate("Dialog", "...", None))
        self.label.setText(_translate("Dialog", "Endereço das imagens", None))
        self.label_3.setText(_translate("Dialog", "Sufixo", None))
        self.cbMascara.setItemText(0, _translate("Dialog", "%Y%m%d", None))
        self.cbMascara.setItemText(1, _translate("Dialog", "Outro Formato", None))
        self.label_2.setWhatsThis(_translate("Dialog", "<html><head/><body><p>Este campo representa uma série de caracteres que vem antes da informação de data, no exemplo &quot;IMG_MODIS_2014-04-23_FILTRADA.tif&quot;, a sequencia de caracteres &quot;IMG_MODIS_&quot; é o prefixo, e este deve ser comum a todas as imagens presentes.</p></body></html>", None))
        self.label_2.setText(_translate("Dialog", "Prefixo", None))
        self.label_4.setText(_translate("Dialog", "Máscara de tempo", None))
        descricao = ('<html><head/><body><p><a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior" target="_blank"></p></body></html>')
        self.label_4.setWhatsThis(_translate("Dialog", descricao, None))                     
        self.label_5.setText(_translate("Dialog", "Fator multiplicador", None))
        

------------------  DlgPPR.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgPPB.ui'
#
# Created: Fri Nov 27 07:19:40 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui
from Controle.ConPPR import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.txCc = QtGui.QDoubleSpinBox(Dialog)
        self.txCc.setDecimals(4)
        self.txCc.setMaximum(999.99999999)
        self.txCc.setObjectName(_fromUtf8("txCc"))
        self.gridLayout.addWidget(self.txCc, 2, 1, 1, 1)
        self.chT = QtGui.QCheckBox(Dialog)
        self.chT.setEnabled(False)
        self.chT.setObjectName(_fromUtf8("chT"))
        self.gridLayout.addWidget(self.chT, 1, 2, 1, 1)
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 4, 0, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 0, 0, 1, 1)
        self.chPPR = QtGui.QCheckBox(Dialog)
        self.chPPR.setEnabled(False)
        self.chPPR.setObjectName(_fromUtf8("chPPR"))
        self.gridLayout.addWidget(self.chPPR, 4, 2, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.btnConfPPR = QtGui.QPushButton(Dialog)
        self.btnConfPPR.setObjectName(_fromUtf8("btnConfPPR"))
        self.gridLayout.addWidget(self.btnConfPPR, 4, 1, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 2, 0, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 1, 0, 1, 1)
        self.btnConfTemp = QtGui.QPushButton(Dialog)
        self.btnConfTemp.setObjectName(_fromUtf8("btnConfTemp"))
        self.gridLayout.addWidget(self.btnConfTemp, 1, 1, 1, 1)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 5, 1, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)
        
        #self.txCc.setValue(0.35599427)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        self.btnConfTemp.clicked.connect(self.controller.setSerieT)
        self.btnConfPPR.clicked.connect(self.controller.setSeriePPR)
        
        #self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Produtividade potencial bruta (PPB)", None))
        self.chT.setText(_translate("Dialog", "Configurado", None))
        self.label_2.setText(_translate("Dialog", "Série de imagens de PPB:", None))
        self.label_3.setText(_translate("Dialog", "Dados de entrada:", None))
        self.chPPR.setText(_translate("Dialog", "Configurado", None))
        self.label_4.setText(_translate("Dialog", "Configuração de saída:", None))
        self.btnConfPPR.setText(_translate("Dialog", "Configurar", None))
        self.label_5.setText(_translate("Dialog", "Indice de colheita (Cc):", None))
        self.label.setText(_translate("Dialog", "Série de imagens de Temperatura:", None))
        self.btnConfTemp.setText(_translate("Dialog", "Configurar", None))



------------------  DlgTAW.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgTAW.ui'
#
# Created: Wed Nov 11 04:59:25 2015
#      by: PyQt4 UI code generator 4.11.3

from PyQt4 import QtCore, QtGui
from Controle.ConTAW import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(460, 243)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 1, 0, 1, 1)
        self.chZr = QtGui.QCheckBox(Dialog)
        self.chZr.setEnabled(False)
        self.chZr.setObjectName(_fromUtf8("chZr"))
        self.gridLayout.addWidget(self.chZr, 2, 2, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.btnConfTAW = QtGui.QPushButton(Dialog)
        self.btnConfTAW.setObjectName(_fromUtf8("btnConfTAW"))
        self.gridLayout.addWidget(self.btnConfTAW, 4, 1, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.chTAW = QtGui.QCheckBox(Dialog)
        self.chTAW.setEnabled(False)
        self.chTAW.setObjectName(_fromUtf8("chTAW"))
        self.gridLayout.addWidget(self.chTAW, 4, 2, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 0, 0, 1, 1)
        self.txImgCAD = QtGui.QLineEdit(Dialog)
        self.txImgCAD.setObjectName(_fromUtf8("txImgCAD"))
        self.gridLayout.addWidget(self.txImgCAD, 1, 1, 1, 1)
        self.btnConfZr = QtGui.QPushButton(Dialog)
        self.btnConfZr.setObjectName(_fromUtf8("btnConfZr"))
        self.gridLayout.addWidget(self.btnConfZr, 2, 1, 1, 1)
        self.btnFindImgCAD = QtGui.QToolButton(Dialog)
        self.btnFindImgCAD.setObjectName(_fromUtf8("btnFindImgCAD"))
        self.gridLayout.addWidget(self.btnFindImgCAD, 1, 2, 1, 1)
        
        self.label_desc = QtGui.QLabel(Dialog)
        self.label_desc.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_desc, 5, 0, 1, 1)
        
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        
        self.gridLayout.addItem(spacerItem, 6, 1, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)
        
        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.btnConfTAW.clicked.connect(self.controller.setSerie_TAW)
        self.btnConfZr.clicked.connect(self.controller.setSerieZr)
        self.btnFindImgCAD.clicked.connect(self.controller.findImgCAD)
        
        #self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - TAW/RAW", None))
        self.label_2.setText(_translate("Dialog", "Série de imagens de Zr:", None))
        self.label.setText(_translate("Dialog", "Imagem de CAD:", None))
        self.chZr.setText(_translate("Dialog", "configurado", None))
        self.label_4.setText(_translate("Dialog", "Configuração de saída:", None))
        self.btnConfTAW.setText(_translate("Dialog", "configurar", None))
        self.label_5.setText(_translate("Dialog", "Série de imagem TAW", None))
        self.chTAW.setText(_translate("Dialog", "configurado", None))
        self.label_3.setText(_translate("Dialog", "Configuração de entrada:", None))
        self.btnConfZr.setText(_translate("Dialog", "configurar", None))
        self.btnFindImgCAD.setText(_translate("Dialog", "...", None))
        
        self.label_desc.setText(_translate("Dialog", "Altere o fator multiplicador para a RAW!", None))



------------------  DlgYa.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgYa.ui'
#
# Created: Mon Dec 07 03:15:49 2015
#      by: PyQt4 UI code generator 4.11.3

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_7 = QtGui.QLabel(Dialog)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout.addWidget(self.label_7, 7, 0, 1, 1)
        self.btnConfYa = QtGui.QPushButton(Dialog)
        self.btnConfYa.setObjectName(_fromUtf8("btnConfYa"))
        self.gridLayout.addWidget(self.btnConfYa, 7, 1, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.btnConfEta = QtGui.QPushButton(Dialog)
        self.btnConfEta.setObjectName(_fromUtf8("btnConfEta"))
        self.gridLayout.addWidget(self.btnConfEta, 1, 1, 1, 1)
        self.btnConfYx = QtGui.QPushButton(Dialog)
        self.btnConfYx.setObjectName(_fromUtf8("btnConfYx"))
        self.gridLayout.addWidget(self.btnConfYx, 4, 1, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.label_6 = QtGui.QLabel(Dialog)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout.addWidget(self.label_6, 6, 0, 1, 1)
        self.chETa = QtGui.QCheckBox(Dialog)
        self.chETa.setEnabled(False)
        self.chETa.setObjectName(_fromUtf8("chETa"))
        self.gridLayout.addWidget(self.chETa, 1, 2, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.BtnConfETc = QtGui.QPushButton(Dialog)
        self.BtnConfETc.setObjectName(_fromUtf8("BtnConfETc"))
        self.gridLayout.addWidget(self.BtnConfETc, 2, 1, 1, 1)
        self.txKy = QtGui.QDoubleSpinBox(Dialog)
        self.txKy.setObjectName(_fromUtf8("txKy"))
        self.gridLayout.addWidget(self.txKy, 3, 1, 1, 1)
        self.chETc = QtGui.QCheckBox(Dialog)
        self.chETc.setEnabled(False)
        self.chETc.setObjectName(_fromUtf8("chETc"))
        self.gridLayout.addWidget(self.chETc, 2, 2, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.chYx = QtGui.QCheckBox(Dialog)
        self.chYx.setEnabled(False)
        self.chYx.setObjectName(_fromUtf8("chYx"))
        self.gridLayout.addWidget(self.chYx, 4, 2, 1, 1)
        self.chYa = QtGui.QCheckBox(Dialog)
        self.chYa.setEnabled(False)
        self.chYa.setObjectName(_fromUtf8("chYa"))
        self.gridLayout.addWidget(self.chYa, 7, 2, 1, 1)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 8, 0, 1, 1)
        self.label_8 = QtGui.QLabel(Dialog)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout.addWidget(self.label_8, 5, 0, 1, 1)
        self.btnConfKc = QtGui.QPushButton(Dialog)
        self.btnConfKc.setObjectName(_fromUtf8("btnConfKc"))
        self.gridLayout.addWidget(self.btnConfKc, 5, 1, 1, 1)
        self.chKc = QtGui.QCheckBox(Dialog)
        self.chKc.setEnabled(False)
        self.chKc.setObjectName(_fromUtf8("chKc"))
        self.gridLayout.addWidget(self.chKc, 5, 2, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), Dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "Produtividade Atingível (Ya)", None))
        self.label_7.setText(_translate("Dialog", "Produtividade atingível (Ya):", None))
        self.btnConfYa.setText(_translate("Dialog", "Configurar", None))
        self.label.setText(_translate("Dialog", "Dados de entrada:", None))
        self.label_2.setText(_translate("Dialog", "Evapotranspiração real (Eta)", None))
        self.btnConfEta.setText(_translate("Dialog", "Configurar", None))
        self.btnConfYx.setText(_translate("Dialog", "Configurar", None))
        self.label_5.setText(_translate("Dialog", "Produtividade Potencial (Yx):", None))
        self.label_6.setText(_translate("Dialog", "Dados de saída:", None))
        self.chETa.setText(_translate("Dialog", "configurado", None))
        self.label_3.setText(_translate("Dialog", "Evapotranspiração da cultura (ETc):", None))
        self.BtnConfETc.setText(_translate("Dialog", "Configurar", None))
        self.chETc.setText(_translate("Dialog", "configurado", None))
        self.label_4.setText(_translate("Dialog", "Fator de produtividade (Ky):", None))
        self.chYx.setText(_translate("Dialog", "configurado", None))
        self.chYa.setText(_translate("Dialog", "configurado", None))
        self.label_8.setText(_translate("Dialog", "Imagens de Kc", None))
        self.btnConfKc.setText(_translate("Dialog", "Configurar", None))
        self.chKc.setText(_translate("Dialog", "configurado", None))



------------------  DlgYaFao.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DlgYa.ui'
#
# Created: Thu Dec 03 17:49:02 2015
#      by: PyQt4 UI code generator 4.11.3

from PyQt4 import QtCore, QtGui

from Controle.ConYaFao import Controller

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_Dialog(QtGui.QDialog):
    def setupUi(self, Dialog):
        
        self.controller = Controller(self)
        
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.gridLayout = QtGui.QGridLayout()
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label_7 = QtGui.QLabel(Dialog)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout.addWidget(self.label_7, 7, 0, 1, 1)
        self.btnConfYa = QtGui.QPushButton(Dialog)
        self.btnConfYa.setObjectName(_fromUtf8("btnConfYa"))
        self.gridLayout.addWidget(self.btnConfYa, 7, 1, 1, 1)
        self.label = QtGui.QLabel(Dialog)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.label_2 = QtGui.QLabel(Dialog)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.btnConfEta = QtGui.QPushButton(Dialog)
        self.btnConfEta.setObjectName(_fromUtf8("btnConfEta"))
        self.gridLayout.addWidget(self.btnConfEta, 1, 1, 1, 1)
        self.btnConfYx = QtGui.QPushButton(Dialog)
        self.btnConfYx.setObjectName(_fromUtf8("btnConfYx"))
        self.gridLayout.addWidget(self.btnConfYx, 4, 1, 1, 1)
        self.label_5 = QtGui.QLabel(Dialog)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout.addWidget(self.label_5, 4, 0, 1, 1)
        self.label_6 = QtGui.QLabel(Dialog)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout.addWidget(self.label_6, 6, 0, 1, 1)
        self.chETa = QtGui.QCheckBox(Dialog)
        self.chETa.setEnabled(False)
        self.chETa.setObjectName(_fromUtf8("chETa"))
        self.gridLayout.addWidget(self.chETa, 1, 2, 1, 1)
        self.label_3 = QtGui.QLabel(Dialog)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.BtnConfETc = QtGui.QPushButton(Dialog)
        self.BtnConfETc.setObjectName(_fromUtf8("BtnConfETc"))
        self.gridLayout.addWidget(self.BtnConfETc, 2, 1, 1, 1)
        self.txKy = QtGui.QDoubleSpinBox(Dialog)
        self.txKy.setObjectName(_fromUtf8("txKy"))
        self.gridLayout.addWidget(self.txKy, 3, 1, 1, 1)
        self.chETc = QtGui.QCheckBox(Dialog)
        self.chETc.setEnabled(False)
        self.chETc.setObjectName(_fromUtf8("chETc"))
        self.gridLayout.addWidget(self.chETc, 2, 2, 1, 1)
        self.label_4 = QtGui.QLabel(Dialog)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout.addWidget(self.label_4, 3, 0, 1, 1)
        self.chYx = QtGui.QCheckBox(Dialog)
        self.chYx.setEnabled(False)
        self.chYx.setObjectName(_fromUtf8("chYx"))
        self.gridLayout.addWidget(self.chYx, 4, 2, 1, 1)
        self.chYa = QtGui.QCheckBox(Dialog)
        self.chYa.setEnabled(False)
        self.chYa.setObjectName(_fromUtf8("chYa"))
        self.gridLayout.addWidget(self.chYa, 7, 2, 1, 1)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 8, 0, 1, 1)
        self.label_8 = QtGui.QLabel(Dialog)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout.addWidget(self.label_8, 5, 0, 1, 1)
        self.btnConfKc = QtGui.QPushButton(Dialog)
        self.btnConfKc.setObjectName(_fromUtf8("btnConfKc"))
        self.gridLayout.addWidget(self.btnConfKc, 5, 1, 1, 1)
        self.chKc = QtGui.QCheckBox(Dialog)
        self.chKc.setEnabled(False)
        self.chKc.setObjectName(_fromUtf8("chKc"))
        self.gridLayout.addWidget(self.chKc, 5, 2, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), self.controller.action_ok)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), self.controller.action_cancel)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.txKy.setValue(0.8)
        
        self.btnConfEta.clicked.connect(self.controller.setSerie_ETa)
        self.BtnConfETc.clicked.connect(self.controller.setSerie_ETc)
        self.btnConfYa.clicked.connect(self.controller.setSerie_Ya)
        self.btnConfYx.clicked.connect(self.controller.setSerie_Yx)
        self.btnConfKc.clicked.connect(self.controller.setSerie_Kc)
        
        self.controller.parametros_teste()

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(_translate("Dialog", "CyMP - Produtividade Atingível (Ya)", None))
        self.label_7.setText(_translate("Dialog", "Produtividade atingível (Ya):", None))
        self.btnConfYa.setText(_translate("Dialog", "Configurar", None))
        self.label.setText(_translate("Dialog", "Dados de entrada:", None))
        self.label_2.setText(_translate("Dialog", "Evapotranspiração real (Eta)", None))
        self.btnConfEta.setText(_translate("Dialog", "Configurar", None))
        self.btnConfYx.setText(_translate("Dialog", "Configurar", None))
        self.label_5.setText(_translate("Dialog", "Produtividade Potencial Bruta (PPB-Yx):", None))
        self.label_6.setText(_translate("Dialog", "Dados de saída:", None))
        self.chETa.setText(_translate("Dialog", "configurado", None))
        self.label_3.setText(_translate("Dialog", "Evapotranspiração da cultura (ETc):", None))
        self.BtnConfETc.setText(_translate("Dialog", "Configurar", None))
        self.chETc.setText(_translate("Dialog", "configurado", None))
        self.label_4.setText(_translate("Dialog", "Fator de produtividade (Ky):", None))
        self.chYx.setText(_translate("Dialog", "configurado", None))
        self.chYa.setText(_translate("Dialog", "configurado", None))
        self.label_8.setText(_translate("Dialog", "Imagens de Kc", None))
        self.btnConfKc.setText(_translate("Dialog", "Configurar", None))
        self.chKc.setText(_translate("Dialog", "configurado", None))



------------------  Dr.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 22, 2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA, FILE_DATA
import gdal
from Modelo.beans.RasterData import RasterFile
progress = gdal.TermProgress_nocb
import numpy
import threading

class Dr(AbstractFunction):
    '''
        Essa função calcula o esgotamento
    '''
    def __setParamIN__(self):
        
        self.descriptionIN["Etc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de Etc"}
        self.descriptionIN["PPP"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de precipitação distribuido"}
        self.descriptionIN["TAW"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens TAW"}
        self.descriptionIN["Dr"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Configuração pra Série de imagens Dr"}
        self.descriptionIN["CAD"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de capacidade de armazenamento de agua no solo CAD"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["Dr"] = {"Type":SERIAL_FILE_DATA, "Description":"Série de imagens Dr"}
    
    def __execOperation__(self):

        self.console("Carregando imagens.")
        
        serie_Etc = self.paramentrosIN_carregados["Etc"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_PPP = self.paramentrosIN_carregados["PPP"].loadListByRoot() 
        serie_TAW = self.paramentrosIN_carregados["TAW"].loadListByRoot() 
        serie_Dr = self.paramentrosIN_carregados["Dr"]
        CAD_ = self.paramentrosIN_carregados["CAD"].loadRasterData()
        
        
        Etc_factor = float(serie_Etc.mutiply_factor)
        PPP_factor = float(serie_PPP.mutiply_factor)
        TAW_factor = float(serie_TAW.mutiply_factor)
        Dr_factor = float(serie_Dr.mutiply_factor)
        
        n_ppp = len(serie_PPP)
        
        self.console(str(n_ppp) + u" imagens de precipitação encontradas.")
        self.console(str(len(serie_Etc)) + u" imagens de Etc encontradas.")
        self.console(str(len(serie_TAW)) + u" imagens de TAW encontradas.")
        self.console(u"Gerando balanço...")

        '''
            O laço a seguir percorre todas as imagens de Zr presentes
            O calculo da TAW é Zr = CAD * Zr
        '''
        
        Dr_anterior = None

        for i in range(n_ppp):
            
            if threading.currentThread().stopped()  : return 
            self.setProgresso(i, n_ppp)

            ppp = serie_PPP[i]
            data_ppp = serie_PPP.getDate_time(file=ppp)
            ppp_ = numpy.array(ppp.loadRasterData()).astype(dtype="float32")
            ppp_ *= PPP_factor
            
            etc = self.procura_img_por_data(serie_Etc, data_ppp)
            etc_ = numpy.array(etc.loadRasterData()).astype(dtype="float32")
            etc_ *= Etc_factor
                
            taw = self.procura_img_por_data(serie_TAW, data_ppp)
            if taw is not None :
                taw_ = numpy.array(taw.loadRasterData()).astype(dtype="float32")   
                taw_ *= TAW_factor 
            else :
                taw_ = CAD_  
                
            
            if Dr_anterior != None:
                ppp_ -= Dr_anterior
            
            Dr_ = etc_ - ppp_

            for i in range(len(taw_)) :
                Dr_[i][-Dr_[i] > taw_[i]] = -taw_[i][-Dr_[i] > taw_[i]]
                "isso aqui em baixo é pro balanço idrico nao ser menor que 0 ou seja o Dr nao pode ser maior q 0"
                Dr_[i][Dr_[i] > 0] = 0 
                
            Dr_anterior = numpy.copy(Dr_)  
            Dr_ = numpy.round(Dr_, 2)   
            Dr_ *= Dr_factor
            
            Dr_ = self.compactar(Dr_)        
            
            dr = RasterFile(file_path=serie_Dr.root_path, ext="tif")
            dr = serie_Dr.setDate_time(data_ppp, file=dr)       
            dr.data = Dr_
            dr.metadata = ppp.metadata
            dr.saveRasterData()
            dr.data = None
            serie_Dr.append(dr)
  
        return serie_Dr



------------------  DragAndDropExample.py  ------------------
#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
from PyQt4 import QtGui, QtCore


class Button(QtGui.QPushButton):
    def mouseMoveEvent(self, e):
        if e.buttons() != QtCore.Qt.RightButton:
            return

        # write the relative cursor position to mime data
        mimeData = QtCore.QMimeData()
        # simple string with 'x,y'
        mimeData.setText('%d,%d' % (e.x(), e.y()))

        # let's make it fancy. we'll show a "ghost" of the button as we drag
        # grab the button to a pixmap
        pixmap = QtGui.QPixmap.grabWidget(self)

        # below makes the pixmap half transparent
        painter = QtGui.QPainter(pixmap)
        painter.setCompositionMode(painter.CompositionMode_DestinationIn)
        painter.fillRect(pixmap.rect(), QtGui.QColor(0, 0, 0, 127))
        painter.end()

        # make a QDrag
        drag = QtGui.QDrag(self)
        # put our MimeData
        drag.setMimeData(mimeData)
        # set its Pixmap
        drag.setPixmap(pixmap)
        # shift the Pixmap so that it coincides with the cursor position
        drag.setHotSpot(e.pos())

        # start the drag operation
        # exec_ will return the accepted action from dropEvent
        if drag.exec_(QtCore.Qt.CopyAction | QtCore.Qt.MoveAction) == QtCore.Qt.MoveAction:
            print 'moved'
        else:
            print 'copied'


    def mousePressEvent(self, e):
        QtGui.QPushButton.mousePressEvent(self, e)
        if e.button() == QtCore.Qt.LeftButton:
            print 'press'



class Example(QtGui.QMainWindow):
    def __init__(self):
        super(Example, self).__init__()
        self.initUI()


    def initUI(self):
        self.setAcceptDrops(True)

        button = Button('Button', self)
        button.move(100, 65)

        self.buttons = [button]

        self.setWindowTitle('Copy or Move')
        self.setGeometry(300, 300, 280, 150)


    def dragEnterEvent(self, e):
        e.accept()


    def dropEvent(self, e):
        # get the relative position from the mime data
        mime = e.mimeData().text()
        x, y = map(int, mime.split(','))

        if e.keyboardModifiers() & QtCore.Qt.ShiftModifier:
            # copy
            # so create a new button
            button = Button('Button', self)
            # move it to the position adjusted with the cursor position at drag
            button.move(e.pos()-QtCore.QPoint(x, y))
            # show it
            button.show()
            # store it
            self.buttons.append(button)
            # set the drop action as Copy
            e.setDropAction(QtCore.Qt.CopyAction)
        else:
            # move
            # so move the dragged button (i.e. event.source())
            e.source().move(e.pos()-QtCore.QPoint(x, y))
            # set the drop action as Move
            e.setDropAction(QtCore.Qt.MoveAction)
        # tell the QDrag we accepted it
        e.accept()
    

------------------  Etc.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 22, 2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA
import gdal
from Modelo.beans.RasterData import RasterFile
progress = gdal.TermProgress_nocb
import numpy
import threading

class Etc(AbstractFunction):
    '''
        Essa função calcula a evapotranspiração da cultura ETc, baseado nas datas de plantio, evapotranspiração de referencia
    e os coeficientes da cultura.
        Formula: ETc = Kc * ET0
        Onde o Kc varia dependendo do estado fenologico da cultura.
        Para efeitos de histórico, periodos de ETc anteriores ao periodo da cultura devem ser inseridos, por default quando a
    cultura não está presente, o Kc é considerado de valor 1
        
        Esta função não entende datas por isso todos os parametros devem ser passados com referencia a cena
    '''
    
    def __setParamIN__(self):
        
        self.descriptionIN["ET0"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de evapotranspiração de referencia"}
        self.descriptionIN["Kc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de Kc distribuido"}
        self.descriptionIN["ETc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Objeto série de imagens configurao para saida"}
        #self.descriptionIN["dias_inicio"] = {"Required":True, "Type":None, "Description":"Indica quantos dias anteriores a primeira data de semeadura que deve ser considerado"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["ETc"] = {"Type":SERIAL_FILE_DATA, "Description":"Série de imagens de evapotranspiração da cultura"}
    
    def __execOperation__(self):
        '''
            Por padrão agora assumo que, quando uma variavel tiver como sufixo um underline "_"
            é porque esta variavel contem os valores carregados (matrizes brutas) dos dados
        '''
        
        self.print_text("Carregando imagens.")
        
        serie_ET0 = self.paramentrosIN_carregados["ET0"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_Kc = self.paramentrosIN_carregados["Kc"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_ETc = self.paramentrosIN_carregados["ETc"] # pucha lista
        
        Kc_factor = float(serie_Kc.mutiply_factor)
        ET0_factor = float(serie_ET0.mutiply_factor)
        ETC_factor = float(serie_ETc.mutiply_factor)
        
        n_et0 = len(serie_ET0)
        
        #self.console(str(n_et0) + " imagens de ET0 encontradas.")
        #self.console(str(len(serie_Kc)) + " imagens de Kc encontradas.")
        
        self.console(u"Gerando imagens de saída...")

        '''
            O laço a seguir percorre todas as imagens de ET0 presentes
            ele verifica se há imagens de Kc correspondentes para realizar a multiplicação
            caso não haja ele simplesmente mantém a imagem de ET0 como imagem de ETc
            
            O calculo de Etc é Etc = Et0 * Kc
        '''

        for i_ET0 in range(n_et0):
            
            if threading.currentThread().stopped()  : return 
            self.setProgresso(i_ET0, n_et0)

            ET0 = serie_ET0[i_ET0]
            data_ET0 = serie_ET0.getDate_time(file=ET0)
            kc = None
            
            for i_Kc in range(len(serie_Kc)):
                data = serie_Kc.getDate_time(file=serie_Kc[i_Kc])
                if data == data_ET0:
                    kc = serie_Kc[i_Kc]
                    break
            
            etc = RasterFile(file_path=serie_ETc.root_path, ext="tif")
            #print data_ET0
            #print kc
            etc = serie_ETc.setDate_time(data_ET0, file=etc)
            
            ET0_ = numpy.array(ET0.loadRasterData()).astype(dtype="float32") #* ET0_factor
            ET0_[ET0_==ET0.metadata["nodata"]] = 0 
            ET0_ = ET0_ * ET0_factor
            
            if kc == None: # caso não encontre nenhum kc correspondente a mesma data
                ETc_ = ET0_
                ETc_ *= ETC_factor
                ETc_ = self.compactar(ETc_)
                etc.data = ETc_
                
            else: 
                    
                Kc_ = numpy.array(kc.loadRasterData()).astype(dtype="float32")
                Kc_ *= Kc_factor
                
                '''1 é o valor default pra quando o Kc for 0 isso tem que ser visto'''
                #Kc_[Kc_==0] = 1 
                
                #print ET0.metadata
                #print kc.metadata

                ETc_ = Kc_ * ET0_
                ETc_ = numpy.round(ETc_, 2)  
                
                print "Etc", Kc_[695][879]
                print "Ks", ET0_[695][879]
                print "ETs", ETc_[695][879]
                
                
                ETc_ *= ETC_factor
                ETc_ = self.compactar(ETc_)
                
                print "ETs", ETc_[695][879]
                    
                etc.data = ETc_
            
            
            etc.metadata = ET0.metadata
            etc.metadata.update(nodata=0)
            etc.saveRasterData()
            
            serie_ETc.append(etc)
            
        self.console(u"Concluído")
            
        return serie_ETc
            
    
    def procurar_descende_correspondente(self, data, serie_temporal):
        '''
            Esse método procura a imagem correspondente para a data informada (feito para capturar o descende correto)
        '''
        img_correspondente = None
        
        for i_img in range(len(serie_temporal)-1):
            data_img =  serie_temporal.getDate_time(i_img)
            data_img_1 = serie_temporal.getDate_time(i_img+1)
            if data_img == data : 
                img_correspondente = serie_temporal[i_img]
                self.dias_decend = (data_img_1 - data_img).days
                break
            elif data_img < data and data_img_1 > data: 
                img_correspondente = serie_temporal[i_img]
                self.dias_decend = (data_img_1 - data_img).days
        
        if img_correspondente == None : img_correspondente = serie_temporal[-1]
           
        return img_correspondente



------------------  EVI2.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Aug 17, 2015

@author: Paloschi
'''

from Modelo.beans import SerialFile
import rasterio
from numpy.core.numeric import array
import numpy

pathIn = "C:\\Users\\Paloschi\\Desktop\\New folder\\recortadas"
pathOut = "C:\Users\Paloschi\Desktop\New folder\EVI2"

imagens_rgb = SerialFile(root_path=pathIn)
imagens_rgb.loadListByRoot(filtro = "tif")

for img in imagens_rgb:
    with rasterio.open(img.file_full_path) as raster:
        r, g, b = raster.read()
        metadata = raster.meta
        
        '''EVI2= 2,5 [(N-R) / (N + 2,4R+1)] '''
        
    N = r.astype(rasterio.float64)# vermelho é o infravermelho próximo 
    R = b.astype(rasterio.float64) # azul é o vermelho
    
    #print r
    #print b
    
    #print N

    EVI2 = numpy.zeros(r.shape, dtype=rasterio.float64)
    
    EVI2 += 2.5 * (N - R) / (N + 2.4 * R + 1)
    
    #print("linhas e colunas: ", len(EVI2), len(EVI2[0]))
    #EVI2 = array(EVI2)
    
    #print EVI2.dtype
    
    img.data = EVI2
    img.file_name = img.file_name + "EVI2"
    img.file_path = pathOut
    metadata.update(dtype="float64")
    img.saveRasterData(band_matrix=EVI2, metadata=metadata)

------------------  Exemplo1.py  ------------------
'''
Created on 01/03/2016

@author: Paloschi
'''

import sys

palavra = "ooooi"

for i in range(0, len(palavra)):
    print palavra[i]


------------------  ExtratorSemeaduraColheita.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Apr 8, 2015

@author: Paloschi
'''

from Modelo.beans import TableData, SERIAL_FILE_DATA, RasterFile                   
from numpy.core.numeric import array
import gdal
from Modelo.Funcoes import AbstractFunction
progress = gdal.TermProgress_nocb   
from datetime import datetime as dt
from datetime import timedelta
import numpy as np
import sys
import threading


class ExtratorSemeaduraColheita(AbstractFunction):
    '''
    Essa função foi criada para extrair as datas de semeadura (primeiro low peak), colheita (segundo low peak) e pico
    
    ela pode ser configurada pra procurar os picos e os picos inferiores em intervalos especificos que são equivalentes ao �ndice da imagem 
    na série de imagens
    
    também pode ser passado como parametro determinados avanço que são relativos em porcentagem com a distancia ente o pico
    
    ex.: se o pico se dá na imagem 8, a colheita na imagem 4 e colocar um avanço na data de colheita de 10% será feito (8 - 4) * 1,10 = 4.4,
         a data de colheita para esse pixel será a data equivalente a 4,4 imagens
    
    '''

    def __setParamIN__(self):
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para procurar as datas"}
        
        self.descriptionIN["avanco_semeadura"] = {"Required":False, "Type":None, "Description":"parametro para avanco de semeadura (Default: 0)"}
        self.descriptionIN["avanco_colheita"] = {"Required":False, "Type":None, "Description":"parametro para avanco de colheita (Default: 0)"}
        self.descriptionIN["intervalo_semeadura"] = {"Required":True, "Type":None, "Description":"intervalo para procura da data nas imagens ex.: 3-24"}
        self.descriptionIN["intervalo_pico"] = {"Required":True, "Type":None, "Description":"intervalo para procura da data nas imagens ex.: 3-24"}
        self.descriptionIN["intervalo_colheita"] = {"Required":True, "Type":None, "Description":"intervalo para procura da data nas imagens ex.: 3-24"}
        self.descriptionIN["mask"] = {"Required":True, "Type":None, "Description":"Mascara usada para identificar a data de cada imagem ex.: %YY%mm%dd"}
        self.descriptionIN["prefixo"] = {"Required":True, "Type":None, "Description":"Prefixo usado antes da data no nome da imagem"}
        self.descriptionIN["sufixo"] = {"Required":True, "Type":None, "Description":"Sufixo usado depois da data no nome da imagem"}
        self.descriptionIN["null_value"] = {"Required":False, "Type":None, "Description":"valor nulo a ser ignorado"}
     
    def __setParamOUT__(self):
        self.descriptionOUT["imagem_semeadura"] = "imagem com as datas de semeadura" 
        self.descriptionOUT["imagem_pico"] = "imagem com as datas de pico vegetativo" 
        self.descriptionOUT["imagem_colheita"] = "imagem com as datas de colheita" 
        
    def __execOperation__(self):
        
        prefix = self.paramentrosIN_carregados["prefixo"]
        sufix = self.paramentrosIN_carregados["sufixo"]
        
        mask =  self.paramentrosIN_carregados["mask"]
        
        images_super = self.paramentrosIN_carregados["images"]
        avanco_semeadura = self.paramentrosIN_carregados["avanco_semeadura"]
        avanco_semeadura = avanco_semeadura
        avanco_colheita = self.paramentrosIN_carregados["avanco_colheita"]
        avanco_colheita = avanco_colheita
        
        intervalo_semeadura = self.paramentrosIN_carregados["intervalo_semeadura"]
        intervalo_pico = self.paramentrosIN_carregados["intervalo_pico"]
        intervalo_colheita = self.paramentrosIN_carregados["intervalo_colheita"]
        
        #barra_progresso = self.paramentrosIN_carregados["progress_bar"]
        
        intervalo_semeadura = intervalo_semeadura.split("-")
        intervalo_pico = intervalo_pico.split("-")
        intervalo_colheita = intervalo_colheita.split("-")
        
        images = images_super.loadListRasterData()
        
        if images==None:
            raise Exception("A funcao necessita de uma serie de imagens para funcionar")
        
        n_images = len(images)
        n_linhas = len(images[0])
        n_colunas = len(images[0][0])
        
        
        #nullValue = float(self.paramentrosIN_carregados["null_value"])
        

        #if(images[0][0][0] == nullValue) : print("null value igual") 
        #else : print("diferente")
        
        sys.stdout.write( "Criando imagens de referencia: ")
        self.print_text(u"Criando imagens de referência.")
        imagem_referencia = np.zeros((n_linhas, n_colunas))
        
        imagem_semeadura = array(imagem_referencia).astype(dtype="int32")
        imagem_colheita = array(imagem_referencia).astype(dtype="int32")
        imagem_pico = array(imagem_referencia).astype(dtype="int32")

        
        sys.stdout.write( "Gerando estimativas: ")
        self.print_text("Gerando estimativas.")
        progress(0.0)
        
        imagem_for_null_value = images[0]
        nullValue = imagem_for_null_value[0][0]
        #print(nullValue)
        
        avanco_semeadura = timedelta(avanco_semeadura)
        avanco_colheita = timedelta(avanco_colheita)
        
        images_super[0].metadata.update(nodata=0)
        #print images_super[0].metadata
        
        for i_linhas in range(0, n_linhas):
            progress(i_linhas/float(n_linhas))
            self.progresso = (i_linhas/float(n_linhas)) * 100
            for i_coluna in range(0, n_colunas):
                line = list()
                
                
                if threading.currentThread().stopped()  : return 
                    
                if nullValue != imagem_for_null_value[i_linhas][i_coluna] :
                            
                    for img in images:
                        line.append(img[i_linhas][i_coluna])
                    
                    cenaPico = self.findPeakHelper(line, int(intervalo_pico[0]), int(intervalo_pico[1])) # 3 - 23
                    data_txt_pico = images_super[cenaPico].file_name.replace(prefix, "").replace(sufix, "") 
                    data_pico = dt.strptime(data_txt_pico, mask)
                    ano_pico = data_pico.year
                    dia_juliano = data_pico.timetuple().tm_yday     
                    
                    imagem_pico[i_linhas][i_coluna] = ((ano_pico * 1000) + dia_juliano)
                      
                    cenaSemeadura = self.findLowPeakHelper(line, int(intervalo_semeadura[0]), int(intervalo_semeadura[1])) # 6 - 23
                    cenaColheita = self.findLowPeakHelper(line, int(intervalo_colheita[0]), int(intervalo_colheita[1])) # 11 - 34
                    
                    data_txt_semeadura = images_super[cenaSemeadura].file_name.replace(prefix, "").replace(sufix, "") 
                    data_semeadura = dt.strptime(data_txt_semeadura, mask)
                                   
                    data_txt_colheita = images_super[cenaColheita].file_name.replace(prefix, "").replace(sufix, "") 
                    data_colheita = dt.strptime(data_txt_colheita, mask)
                    
                    picoMenosSemeadura = data_pico - data_semeadura
                    ColheitaMenosPico = data_colheita - data_pico
                    data_semeadura += timedelta((picoMenosSemeadura.days * avanco_semeadura).days)
                    data_colheita += timedelta((ColheitaMenosPico.days * avanco_colheita).days)
                    
                    dia_juliano_semeadura = data_semeadura.timetuple().tm_yday 
                    imagem_semeadura[i_linhas][i_coluna] = ((data_semeadura.year * 1000) + dia_juliano_semeadura)
            
                    dia_juliano_colheita = data_colheita.timetuple().tm_yday 
                    imagem_colheita[i_linhas][i_coluna] = ((data_colheita.year * 1000) + dia_juliano_colheita)
                    
        saida = TableData()
        imagem_semeadura = RasterFile(data=imagem_semeadura)
        imagem_semeadura.metadata = images_super[0].metadata
        imagem_semeadura.data_name = "semeadura"
        
        imagem_colheita = RasterFile(data=imagem_colheita)
        imagem_colheita.metadata = images_super[0].metadata
        imagem_colheita.data_name = "colheita"
        
        imagem_pico = RasterFile(data=imagem_pico)
        imagem_pico.metadata = images_super[0].metadata
        imagem_pico.data_name = "cenaPico"
        
        saida["imagem_semeadura"] = imagem_semeadura
        saida["imagem_colheita"] = imagem_colheita
        saida["imagem_pico"] = imagem_pico
        
        return saida
    
    def findPeakHelper(self,num,start,end):
        mid = (start+end)/2
        if mid>start and mid < end:
            if(num[mid-1]<num[mid] and num[mid]>num[mid+1]):
                return mid
            if(num[mid-1]>num[mid]):
                return self.findPeakHelper(num,start,mid)
            else:
                return self.findPeakHelper(num,mid,end)
        else:
            if num[mid]>num[mid+1]:
                return mid
            else:return mid+1

    def findLowPeakHelper(self,num,start,end):
        mid = (start+end)/2
        if mid>start and mid < end:
            if(num[mid-1]>num[mid] and num[mid]<num[mid+1]):
                return mid
            if(num[mid-1]<num[mid]):
                return self.findLowPeakHelper(num,start,mid)
            else:
                return self.findLowPeakHelper(num,mid,end)
        else:
            if num[mid]>num[mid+1]:
                return mid
            else:return mid+1

    def valorPixelLinha(self, cena, vetor):
        if (cena - int(cena) > 0):
                valor = vetor[int(cena)] + ((vetor[int(cena)+1] - vetor[int(cena)]) * (cena - int(cena)))
        elif (cena - int(cena) < 0):  
                valor = vetor[int(cena)] + ((vetor[int(cena)] - vetor[int(cena)-1]) * (cena - int(cena)))
        else:
            valor = vetor[int(cena)]
        return valor






------------------  FileData.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 12, 2015

@author: Paloschi
'''

from AbstractData import ABData, FILE_DATA
import os

class FileData(ABData):
    '''
    Classe file data, essa classe abstrai um arquivo, e fornece algumas facilidades
    para manipular arquivos com mais praticidade
    '''
    __file_ext = None
    __file_path = None
    file_name = None
    
    def __init__(self, **params):
        
        super(FileData, self).__init__(FILE_DATA) # seta o tipo do objeto
        
        if params.get("data") != None : self.data = params.get("data")
        if params.get("ext") != None : self.file_ext = params.get("ext")
        if params.get("file_name") != None : self.file_name = params.get("file_name")
        if params.get("name") != None : self.name = params.get("name")
        if params.get("file_path") != None : self.file_path = params.get("file_path")
        if params.get("file_full_path") != None : self.file_full_path = params.get("file_full_path")
    
    @property
    def file_path(self):
        return self.__file_path
    
    @file_path.setter
    def file_path(self, data_path):
        self.__file_path = os.path.normpath(data_path) 
    
    @property
    def file_full_path(self):
        full_path = self.file_path + "\\" + self.file_name + "." + self.file_ext 
        return full_path
    
    @file_full_path.setter
    def file_full_path(self, file_full_path):
        full_path = os.path.normpath(file_full_path)
        name, ext = os.path.splitext(os.path.basename(full_path))
        self.file_name = name
        self.file_ext = ext
        self.__file_path = os.path.dirname(full_path)
        
    @property
    def file_ext(self):
        return self.__file_ext
    
    @file_ext.setter
    def file_ext(self, ext):
        ext = ext.replace(".", "")
        self.__file_ext = ext
            
        



------------------  FilesRenamer.py  ------------------
'''
Created on Sep 17, 2015

@author: rennan.paloschi
'''
import os

diretorio = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Modis\\1-EVI_AQUA_TERA_11-12"
os.chdir(diretorio)

'''
    Remover ou substituir fraze
'''

subistituir = ".250m_16_dias_EVI_PR"
por = ""

for nome in os.listdir('.'):
    novo_nome = nome.replace(subistituir,por)
    os.rename(nome, novo_nome)
    print 'OK'

------------------  FiltroSavitzGolay.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on May 5, 2015

@author: Paloschi
'''

import gdal
from Modelo.Funcoes import AbstractFunction
from numpy.core.numeric import array
from numpy import double
progress = gdal.TermProgress_nocb    
import numpy as np
from Modelo.beans import SERIAL_FILE_DATA, TABLE_DATA, SerialFile, RasterFile
import sys
import threading


class FiltroSavitz(AbstractFunction):
    '''
    Essa classe representa um filtro que filtra uma serie de imagens com o SavitzGolay
    '''
    
    def __setParamIN__(self):
        
        #self.descriptionIN["nome_atributo"] = {"Required":True, "Type":FILE_DATA, "Description":"um arquivo qualquer requerido"}
        
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para aplicar o filtro"}
        
        conf_algoritimo = dict()
        conf_algoritimo["window_size"] = {"Required":True, "Type":None, "Description":"Série de imagens para aplicar o filtro"}
        conf_algoritimo["order"] = {"Required":True, "Type":None, "Description":"parametros de configuração filtro"} # não implementado
        #conf_algoritimo["null_value"] = {"Required":True, "Type":None, "Description":"parametros de configuração filtro"} # não implementado
        
        self.descriptionIN["conf_algoritimo "] = {"Required":False, "Type":TABLE_DATA, "Table_Description":conf_algoritimo,"Description":"tabela de parametros para configuração do filtro"}
   
     
    def __setParamOUT__(self):
        self.descriptionOUT["images"] = "Série de imagens filtradas" 
    
    def __execOperation__(self):
        
        images = self.paramentrosIN_carregados["images"]
        if self.paramentrosIN_carregados.has_key("conf_algoritimo") : conf_algoritimo = self.paramentrosIN_carregados["conf_algoritimo"]
        else : conf_algoritimo = dict()
        img_matrix = images.loadListRasterData()
        
        if img_matrix == None:
            print self.console("Erro no carregamento das imagens")
            threading.currentThread().stop() 
            return
        
        self.imagem_0 = img_matrix[0] # imagem de referencia pra leitura de valores null
        conf_algoritimo["NoData"] = self.imagem_0[0][0]

        self.n_bandas = len(img_matrix)
        self.n_linhas = len(img_matrix[0])
        self.n_colunas = len(img_matrix[0][0])
        
        sys.stdout.write("Numero de bandas: " + str(self.n_bandas))
        sys.stdout.write(" Numero de linhas: " + str(self.n_linhas))
        print(" Numero de colunas: " + str(self.n_colunas))
        
        
    
        linhas_filtradas = self.filtrar(img_matrix, conf_algoritimo)
        if threading.currentThread().stopped()  : return 
        results = linhas_filtradas
        
        imgs_saida = SerialFile()
        imgs_saida.metadata = images.metadata
        i_imagem = 0
        for img in self.paramentrosIN_carregados["images"]:
            img.data = results[i_imagem]
            i_imagem+=1
            imgs_saida.append(img)
        
        return imgs_saida
    
    def filtrar(self, images, lol, **config):
        
        if config.get("window_size") == None : window_size=5
        else : window_size = config.get("window_size")
        if config.get("order") == None : order=3
        else : order = config.get("order")
        if config.get("NoData") == None : noData=0
        else : noData = config.get("NoData")
                
        print ("valor do primeiro pixel", images[0][0][0])
        sys.stdout.write( "Filtrando imagens: ")
        
        linhas_filtradas = list()   
        n_iteracoes = 0
        total = self.n_linhas
        progress( 0.0)

        results = np.zeros((self.n_bandas, self.n_linhas, self.n_colunas,))

        for i_linhas in range(0, self.n_linhas):   
            n_iteracoes+=1 
            
            progresso = n_iteracoes/float(total)
            progress(progresso)
            self.progresso  = progresso*100
            
            if threading.currentThread().stopped()  : return 
                                                                                                                                                                                                                                                                                                                                                                                                   
            for i_colunas in range(0, self.n_colunas):
                line = list()
                if self.imagem_0[i_linhas][i_colunas] != noData :
                    for img in images:
                        line.append(img[i_linhas][i_colunas])
                    line_filtred = array((savitzky_golay(line, window_size, order)))
                    
                    for i_images in range(self.n_bandas):
                        results[i_images][i_linhas][i_colunas] = line_filtred[i_images]             
                    
                    #linhas_filtradas.append(line_filtred)
                    
        return results
    
def Smooth( array, smooth_window):

        a = len(array)
        temp_intensity = array[:] #don't use the changed intensity values
        for i in range(a):
            if smooth_window<=i and i <= a-smooth_window-1:
                for j in range(i-smooth_window,i):
                    array[i]+= temp_intensity[j]
                for j in range(i+1, i+smooth_window+1):
                    array[i]+= temp_intensity[j]
                array[i] /= smooth_window*2 +1
            elif i < smooth_window:
                for j in range(i):
                    array[i] += temp_intensity[j]
                for j in range(i+1, 2*i+1):
                    array[i] += temp_intensity[j]
                array[i]/=(2*i+1)
            elif i >= a-smooth_window - 1:
                for j in range(i+1, a):
                    array[i] += temp_intensity[j]
                for j in range(2*i-a +1 , i):
                    array[i]+= temp_intensity[j]
                array[i] /=  (2*a -2*i-1)
            else: print "ERROR in Smooth: out of range"
        return array
        
def savitzky_golay(y, window_size=5, order=3, deriv=0, rate=1):
        r"""Smooth (and optionally differentiate) data with a Savitzky-Golay filter.
        The Savitzky-Golay filter removes high frequency noise from data.
        It has the advantage of preserving the original shape and
        features of the signal better than other types of filtering
        approaches, such as moving averages techniques.
        Parameters
        ----------
        y : array_like, shape (N,)
            the values of the time history of the signal.
        window_size : int
            the length of the window. Must be an odd integer number.
        order : int
            the order of the polynomial used in the filtering.
            Must be less then `window_size` - 1.
        deriv: int
            the order of the derivative to compute (default = 0 means only smoothing)
        Returns
        -------
        ys : ndarray, shape (N)
            the smoothed signal (or it's n-th derivative).
        Notes
        -----
        The Savitzky-Golay is a type of low-pass filter, particularly
        suited for smoothing noisy data. The main idea behind this
        approach is to make for each point a least-square fit with a
        polynomial of high order over a odd-sized window centered at
        the point.
        Examples
        --------
        t = np.linspace(-4, 4, 500)
        y = np.exp( -t**2 ) + np.random.normal(0, 0.05, t.shape)
        ysg = savitzky_golay(y, window_size=31, order=4)
        import matplotlib.pyplot as plt
        plt.plot(t, y, label='Noisy signal')
        plt.plot(t, np.exp(-t**2), 'k', lw=1.5, label='Original signal')
        plt.plot(t, ysg, 'r', label='Filtered signal')
        plt.legend()
        plt.show()
		
        Referencias
        ----------
        .. [1] A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of
           Data by Simplified Least Squares Procedures. Analytical
           Chemistry, 1964, 36 (8), pp 1627-1639.
        .. [2] Numerical Recipes 3rd Edition: The Art of Scientific Computing
           W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery
           Cambridge University Press ISBN-13: 9780521880688
        """

        from math import factorial
        
        try:
            window_size = np.abs(np.int(window_size))
            order = np.abs(np.int(order))
        except ValueError, msg:
            raise ValueError("window_size and order have to be of type int")
        if window_size % 2 != 1 or window_size < 1:
            raise TypeError("window_size size must be a positive odd number")
        if window_size < order + 2:
            raise TypeError("window_size is too small for the polynomials order")
        order_range = range(order+1)
        half_window = (window_size -1) // 2
        # precompute coefficients
        b = np.mat([[k**i for i in order_range] for k in range(-half_window, half_window+1)])
        m = np.linalg.pinv(b).A[deriv] * rate**deriv * factorial(deriv)
        # pad the signal at the extremes with
        # values taken from the signal itself
        firstvals = y[0] - np.abs( y[1:half_window+1][::-1] - y[0] )
        lastvals = y[-1] + np.abs(y[-half_window-1:-1][::-1] - y[-1])
        y = np.concatenate((firstvals, y, lastvals))
        return np.convolve( m[::-1], y, mode='valid')


------------------  Interpola.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Mar 1, 2015

@author: Paloschi
'''

from Modelo.beans import ABData, TableData
from Modelo.Funcoes import AbstractFunction
from lxml import etree


class InterpolaTabela(AbstractFunction):
    
    '''
    faz todos os tramites necessarios pra interpolar uma tabela
    '''
    def __setParamIN__(self):
        
        self.descriptionIN["table_data"] = {"Required":True, "Type":None, "Description":"Tabela de dados a ser interpolada"}
        self.descriptionIN["atributo"] = {"Required":True, "Type":None, "Description":"Atributo escolhido para a interpolação"}
        self.descriptionIN["format_image_data"] = {"Required":True, "Type":None, "Description":"Formato de saida"}

    def __setParamOUT__(self):
        self.descriptionOUT["Mensagem"] = {"Type":None, "Description":"saida"}
        
    def __execOperation__(self):     
               
        self.console(u"iniciando operação de interpolação")

        tabela_data = self.paramentrosIN_carregados['table_data']
        atributo_interpolacao = self.paramentrosIN_carregados['atributo']
        format_image_data = self.paramentrosIN_carregados['format_image_data']
        
        self.console(u"Preparando interpolacao:")
              
        self.WriteVRTfiles(tabela_data.data, atributo_interpolacao)     
        self.WriteCSVfiles(tabela_data.data, atributo_interpolacao)
        
        path = tabela_data.data['data_path']
        keys = tabela_data.keys()
        
        self.console(u"Preparacao completa, interpolando:")
        
        print(keys)
        
        if len(keys) > 0:
            for key in keys: 
                if (key!="data_path"):  
                         
                    self.console(u"criando tabela de interpolação, key: " + key)
                    informacao = self.CreateInterpolationTable(path, key, atributo_interpolacao, format_image_data)
                    
                    interpolation_table = TableData("iformacao de interpolacao")
                    interpolation_table.data = informacao
                    
                    interpolador = InterpoladorIvD("interpolando ECMWF")
                    interpolador.data = interpolation_table
                
                    self.console (interpolador.data)
        else:
            informacao = self.CreateInterpolationTable(path, None, atributo_interpolacao, format_image_data)
            interpolation_table = TableData("iformacao de interpolacao")
            interpolation_table.data = informacao
            interpolador = InterpoladorIvD("interpolando ECMWF")
            interpolador.data = interpolation_table
            self.console (interpolador.data)
        
            
        self.console (u"Interpolacao completa")
        return (u"Interpolacao completa")
        
    def WriteCSVfiles(self, table, atribute):
        
            print("-Criando arquivos CSV para alimentar intorpolador")
        
            path = table['data_path']
            keys = table.keys()
        
            print keys
        
        #if len(keys 0):
        #    for key in keys:
        #        if (key!="data_path"):   
        #            file_path = str(path).replace('.shp', ('_' + str(key) + "_" + atribute + '.csv'))
         #           with open(file_path,'w') as csv:
         #               csv.write("Easting,Northing,Value\n")
         #               
         #               for tupla in table[key]:
         #                   print(tupla['geometry']['coordinates'])
         #                   cx = tupla['geometry']['coordinates'][0]
         #                   cy = tupla['geometry']['coordinates'][1]
         #                   value = tupla['properties'][atribute]
         #                   line = str(cx) + ',' + str(cy) + ',' + str(value) + '\n'
         #                   csv.write(line)
         
         
        #else:
            file_path = str(path).replace('.shp', ("_" + atribute + '.csv'))
            with open(file_path,'w') as csv:
                csv.write("Easting,Northing,Value\n")
                        
                for tupla in table["table"]["table_data"]:
                    print tupla
                    print(tupla['geometry']['coordinates'])
                    cx = tupla['geometry']['coordinates'][0]
                    cy = tupla['geometry']['coordinates'][1]
                    value = tupla['properties'][atribute]
                    line = str(cx) + ',' + str(cy) + ',' + str(value) + '\n'
                    csv.write(line) 
                    
            print('-Arquivos CSV criados')

    def WriteVRTfiles(self, table, atribute):
        
        print("-Criando arquivos VTR para alimentar intorpolador")
        
        print table
        
        path = table['data_path']
        keys = table.keys()
        
        #for key in keys:
            #if (key!="data_path"): 
                
                
                #file_csv_path = str(path).replace('.shp', ('_' + str(key) + "_" + atribute +'.csv'))  
                #cvs_name = file_csv_path.split("/")[-1].split(".")[0]
                #file_vtr_path = str(path).replace('.shp', ('_' + str(key) + "_" + atribute +'.vrt'))
                
                #root = etree.Element("OGRVRTDataSource")
                #csv_node = etree.Element("OGRVRTLayer", name=cvs_name)   
                #root.append(csv_node)
                                      
                #csv_node.append(etree.XML("<SrcDataSource>" +file_csv_path+"</SrcDataSource>"))
                #csv_node.append(etree.XML("<GeometryType>wkbPoint</GeometryType>"))
                #csv_node.append(etree.XML('<GeometryField encoding="PointFromColumns" x="Easting" y="Northing" z="Value"/>'))
                
                #tree = etree.ElementTree(root)
                #tree.write(file_vtr_path, pretty_print=True)
        
        
        file_csv_path = str(path).replace('.shp', ("_" + atribute +'.csv'))  
        cvs_name = file_csv_path.split("/")[-1].split(".")[0]
        file_vtr_path = str(path).replace('.shp', ("_" + atribute +'.vrt'))
                
        root = etree.Element("OGRVRTDataSource")
        csv_node = etree.Element("OGRVRTLayer", name=cvs_name)   
        root.append(csv_node)
                                      
        csv_node.append(etree.XML("<SrcDataSource>" +file_csv_path+"</SrcDataSource>"))
        csv_node.append(etree.XML("<GeometryType>wkbPoint</GeometryType>"))
        csv_node.append(etree.XML('<GeometryField encoding="PointFromColumns" x="Easting" y="Northing" z="Value"/>'))
                
        tree = etree.ElementTree(root)
        tree.write(file_vtr_path, pretty_print=True)
                    
        print('-Arquivos CSV criados')
    
    def CreateInterpolationTable(self, path, tupla=None, atribute=None,  format_image_data=None):
        
        if tupla is None:
            file_vtr_path = str(path).replace('.shp', ("_" + atribute + '.vrt'))
            file_tif_path = str(path).replace('.shp', ("_" + atribute + '.tif'))
        else:            
            file_vtr_path = str(path).replace('.shp', ('_' + str(tupla) + "_" + atribute + '.vrt'))
            file_tif_path = str(path).replace('.shp', ('_' + str(tupla) + "_" + atribute + '.tif'))
            
        cvs_name = file_vtr_path.split("/")[-1].split(".")[0]
        format_image_data["fileIn"] = file_vtr_path
        format_image_data["fileOut"] = file_tif_path
        format_image_data["name_file"] = cvs_name
        
        return format_image_data
    
class InterpoladorIvD(ABData):
    '''
    classdocs
    '''

    def __init__(self, nome=None):
        self.__data = None
        self.data_name = [nome, 'interpolacao'] 
        self.data_type = "operation"
    
    @property    
    def data(self):
        
        tabela = self.__data.data
        
        #print (["xmin",  tabela['xmin']])
        
        xmin = tabela['xmin']
        xmax = tabela['xmax']
        ymin = tabela['ymin']
        ymax = tabela['ymax']
        ny = tabela['ny']
        nx = tabela['nx']
        fileIn = tabela['fileIn']
        #fileOut = str(fileIn).replace(".vrt", "interpolado.tiff")
        fileOut = tabela['fileOut']
        name_file = tabela['name_file']
        
        
        try:
            self.call_interpolador(xmin, xmax, ymin, ymax, nx, ny, name_file, fileIn, fileOut)
            
            return fileOut
        
        except Exception:
            print 'erro ao chamar subprocesso gdal_grid'
            return Exception()
        
    @data.setter
    def data(self, data):
        self.__data = data
           
    def call_interpolador(self, xmin, xmax, ymin, ymax, nx, ny, name_file, fileIn, fileOut):

        import subprocess
        
        subprocess.call (['gdal_grid', '-a', 'invdist:max_points=12', '-txe', 
                              str(xmin), str(xmax), '-tye', str(ymin), str(ymax), '-outsize', 
                              str(nx), str(ny), '-of', 'GTiff', '-ot', 'Float64', '-l', name_file, fileIn, fileOut]) 

            

------------------  InterpoladorIDW.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 8, 2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans.AbstractData import FILE_DATA, TABLE_DATA
from Modelo.beans.TableData import TableData
import subprocess
from Modelo.beans.FileData import FileData

class IDW(AbstractFunction):
    '''
        Essa função realiza a interpolação IDW (inverso da distancia) de arquivos CSV configurados por arquivos VRT
        ela necessita do GDAL Core instalado pra funcionar, e o path do GDAL Core tem que estar
        setado na variavel de ambiente path do windows
    '''
    
    def __setParamIN__(self):
        u'''
            Parametros de arquivos de dados (csv, vrt e imagem de saida)
        '''
        self.descriptionIN["csv"] = {"Required":True, "Type":FILE_DATA, "Description":"nome do arquivo CSV"}
        self.descriptionIN["vrt"] = {"Required":True, "Type":FILE_DATA, "Description":"caminho completo do arquivo VRT"}
        self.descriptionIN["img_out"] = {"Required":True, "Type":FILE_DATA, "Description":"Parametros de referencia para a imagem de saida"}
        
        '''
            Parametros de configuração do algorítimo
        '''
        conf_algoritimo = dict()
        conf_algoritimo["power"] = {"Required":False, "Type":None, "Description":"Weighting power (default 2.0)"}
        conf_algoritimo["smoothing"] = {"Required":False, "Type":None, "Description":"Smoothing parameter (default 0.0)"}
        conf_algoritimo["radius"] = {"Required":False, "Type":None, "Description":"The first radius (X axis if rotation angle is 0) of search ellipse. Set this parameter to zero to use whole point array. Default is 0.0"}
        conf_algoritimo["radius2"] = {"Required":False, "Type":None, "Description":"The second radius (Y axis if rotation angle is 0) of search ellipse. Set this parameter to zero to use whole point array. Default is 0.0."}
        conf_algoritimo["angle"] = {"Required":False, "Type":None, "Description":"Angle of search ellipse rotation in degrees (counter clockwise, default 0.0)"}
        conf_algoritimo["max_points"] = {"Required":False, "Type":None, "Description":"Maximum number of data points to use. Do not search for more points than this number. This is only used if search ellipse is set (both radii are non-zero). Zero means that all found points should be used. Default is 0"}
        conf_algoritimo["min_points"] = {"Required":False, "Type":None, "Description":"Minimum number of data points to use. If less amount of points found the grid node considered empty and will be filled with NODATA marker. This is only used if search ellipse is set (both radii are non-zero). Default is 0"}
        conf_algoritimo["nodata"] = {"Required":False, "Type":None, "Description":"NODATA marker to fill empty points (default 0.0)"}
        
        self.descriptionIN["conf_algoritimo"] = {"Required":False, "Type":TABLE_DATA, "Table_Description":conf_algoritimo,"Description":"tabela de parametros para configuração do algoritimo"}
        
        u'''
            Parametros de configuração da imagem de saida
        '''
        conf_img_out = dict()
        conf_img_out["xmin"] = {"Required":True, "Type":None, "Description":u"posição inicial x"}
        conf_img_out["xmax"] = {"Required":True, "Type":None, "Description":u"posição final x"}
        conf_img_out["ymin"] = {"Required":True, "Type":None, "Description":u"posição inicial y"}
        conf_img_out["ymax"] = {"Required":True, "Type":None, "Description":u"posição final y"}
        conf_img_out["ny"] = {"Required":True, "Type":None, "Description":"Numero de linhas da imagem"}
        conf_img_out["nx"] = {"Required":True, "Type":None, "Description":"Numero de colunas da imagem"}
        
        self.descriptionIN["img_out_config"] =  {"Required":True, "Type":TABLE_DATA, "Table_Description":conf_img_out, "Description":"configuração da imgagem de saida"}
        
    def __setParamOUT__(self):
        self.descriptionOUT["imagem_interpolada"] = "imagem de saida interpolada"  
        
    def __execOperation__(self):
        print "-----------------------------------------------------------------------------------"
        csv = self.paramentrosIN_carregados["csv"]
        vrt = self.paramentrosIN_carregados["vrt"]
        img_out = self.paramentrosIN_carregados["img_out"]
        img_out_config = self.paramentrosIN_carregados["img_out_config"]
        print "-----------------------------------------------------------------------------------"
        
        '''
            Monta string de de parametros para configurar o algoritimo IDW
        '''
        str_algoritimo_conf = ""
        print "-----------------------------------------------------------------------------------"
        print self.paramentrosIN_carregados["conf_algoritimo"]
        
        if self.paramentrosIN_carregados.has_key("conf_algoritimo") :
            
            conf_algoritimo = self.paramentrosIN_carregados["conf_algoritimo"]
            
            for key in conf_algoritimo.keys() :
                if (float(conf_algoritimo[key])!=float(0)):
                    str_algoritimo_conf += ":"
                    str_algoritimo_conf += (key + "=" + str(conf_algoritimo[key]))
                    
            str_algoritimo_conf += ':nodata=0'       
                
            print "configuracao do algoritimo" + str_algoritimo_conf
        
        
        '''
            Chama interpolador GDAl IDW
            http://www.gisinternals.com/query.html?content=filelist&file=release-1800-x64-gdal-mapserver.zip
        '''

        
        string_execucao = ['gdal_grid',  
                              
                              '-a', 'invdistnn' + str_algoritimo_conf,
                              '-txe', str(img_out_config["xmin"]), str(img_out_config["xmax"]), 
                              '-tye', str(img_out_config["ymin"]), str(img_out_config["ymax"]), 
                              '-outsize', str(img_out_config["nx"]), str(img_out_config["ny"]), 
                              '-of', 'GTiff', 
                              '-ot', 'Float32',
                              '-a_srs', 'EPSG:4326',
                              '-l', csv.file_name, vrt.file_full_path, img_out.file_full_path]
        
        #if str_algoritimo_conf != "":
            #string_execucao.append('-a')
            #string_execucao.append(str_algoritimo_conf)
        
            
        try:
            print ("string de execucao: ", str(string_execucao))
            subprocess.call (string_execucao, creationflags=subprocess.SW_HIDE, shell=True) 
  
            
        except Exception:  
            print 'erro ao chamar subprocesso gdal_grid, verifiquei se a GDAL core está instalada e a variavel de ambiente está setada'
            
            
        saida = img_out
        
        return saida

if __name__ == '__main__':   
    
    from Modelo.beans import SerialFile
    from Modelo.Funcoes.RasterTools import RasterToCSVeVRT
    
    '''
        CSV e VRT
    '''
    #img_teste_path = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\ECMWF\\Teste_raster_csv\\Imagens"
    #img_teste = SerialFile(root_path=img_teste_path)
    #img_teste.loadListByRoot()
    
    #paramIN = dict()
    #paramIN["images"] = img_teste
    #paramIN["out_folder"] = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\ECMWF\\Teste_raster_csv\\Saida\\"
    
    #csv_vrt_files = RasterToCSVeVRT().executar(paramIN)
    
    '''
        Imagem de referencia
    '''
    from Modelo.beans import RasterFile
    
    img_referencia_path = "C:\\Gafanhoto WorkSpace\\DataTestes\\raster\\Fazer\\20110101.tif"
    img_referencia = RasterFile(file_full_path = img_referencia_path)
    
    info_img_referencia = img_referencia.getRasterInformation()
    
    '''
        Conf algoritimo 
    '''
    conf_alg = TableData()
    #conf_alg["max_points"] = "12"
    #conf_alg["radius"] = "0"
    
    '''
        Imagem de saida
    '''
    img_out = RasterFile(file_full_path = "C:\\Gafanhoto WorkSpace\\DataTestes\\out\\Primeira tentativa\\evpt_20110101.tif")
    
    '''
        Unindo e executando
    '''
    paramIN = dict()
    #paramIN["csv"] = csv_vrt_files["CSVs"][0]
    #paramIN["vrt"] = csv_vrt_files["VRTs"][0]
    paramIN["csv"] = FileData(file_full_path="C:\\Gafanhoto WorkSpace\\DataTestes\\out\\Primeira tentativa\\evpt_20110101.csv")
    paramIN["vrt"] = FileData(file_full_path="C:\\Gafanhoto WorkSpace\\DataTestes\\out\\Primeira tentativa\\evpt_20110101.vrt")
    paramIN["img_out"] = img_out
    paramIN["conf_algoritimo"] = conf_alg
    paramIN["img_out_config"] = info_img_referencia
    
    imagem_interpolada = IDW().executar(paramIN)

------------------  Ks.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Nov 18, 2015

@author: rennan.paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA
import threading
import numpy
from Modelo.beans.RasterData import RasterFile

class Ks(AbstractFunction):
    
    def __setParamIN__(self):
        
        self.descriptionIN["RAW"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagem RAW"}
        self.descriptionIN["TAW"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens TAW"}
        self.descriptionIN["Dr"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagem Dr"}
        self.descriptionIN["Ks"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagem Ks"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["Ks"] = {"Type":SERIAL_FILE_DATA, "Description":"Série de imagen Ks"}
    
    def __execOperation__(self):
        
        serie_raw = self.paramentrosIN_carregados["RAW"].loadListByRoot()
        serie_taw = self.paramentrosIN_carregados["TAW"].loadListByRoot()
        serie_dr = self.paramentrosIN_carregados["Dr"].loadListByRoot()
        
        serie_ks = self.paramentrosIN_carregados["Ks"]
        
        factor_raw = float(serie_raw.mutiply_factor)
        factor_taw = float(serie_taw.mutiply_factor)
        factor_dr = float(serie_dr.mutiply_factor)
        factor_ks = float(serie_ks.mutiply_factor)
        
        n_taw = len(serie_taw)
        
        taw_ = serie_taw[0].loadRasterData()
        n_linhas = len(taw_)
        n_colunas = len(taw_[0])
        
        for i in range(n_taw):
            
            if threading.currentThread().stopped()  : return 
            self.setProgresso(i, n_taw)
            
            taw = serie_taw[i]
            data_taw = serie_taw.getDate_time(file=taw)
            taw_ = numpy.array(taw.loadRasterData()).astype(dtype="float32")
            taw_ *= factor_taw
            
            raw_ = self.LoadImgByDate(serie_raw, data_taw, factor_raw)
            dr_ = self.LoadImgByDate(serie_dr, data_taw, factor_dr)
            
            ''' ----------------------------------------------- '''
            
            ks_ = numpy.zeros((n_linhas, n_colunas))
            #ks_ +=1
            
            ''' ----------------------------------------------- '''
            
            a = (taw_ - (- dr_)) 
            b = (taw_ - raw_)
            c = a / b
            
            for i in range(len(ks_)) :

                ks_[i][-dr_[i] >= raw_[i]] = c[i][-dr_[i] >= raw_[i]]
                ks_[i][-dr_[i] < raw_[i]] = 1
                ks_[i][ks_[i] == -float('Inf')] = 2
                ks_[i][taw_[i] == float('NaN')] = 2
                ks_[i][taw_[i] == 127] = 2
                ks_[i][raw_[i] == 0] = 2

                
            
            ''' ------------------------------------------------ '''
            
            ks_ = numpy.round(ks_, 2)  
            ks_ *= factor_ks
            ks_ = self.compactar(ks_)
            
            ks_ = 1 - ks_ # invertendo o Ks pra dar certo na formulas
            
            #print data_taw
            #for i in range(n_linhas):
                #for ii in range(n_colunas):
                    #if taw_[i][ii] != 0.0 and taw_[i][ii] != 127.0 and ks_[i][ii] != 1 and ks_[i][ii] != 0:
                        #print a[i][ii], b[i][ii], c[i][ii]
                        #print taw_[i][ii], raw_[i][ii], dr_[i][ii], ks_[i][ii]
                        #print "----------------------------------"
            
            
            ks = RasterFile(file_path=serie_ks.root_path, ext="tif")
            ks = serie_ks.setDate_time(data_taw, file=ks)       
            ks.data = ks_
            ks.metadata = taw.metadata
            ks.metadata.update(nodata=200)
            ks.saveRasterData()
            ks.data = None
            serie_ks.append(ks)
            
        return serie_ks
            
    def LoadImgByDate(self, serie, date, factor):          
            img = self.procura_img_por_data(serie, date)
            img_ = numpy.array(img.loadRasterData()).astype(dtype="float32")
            img_ *= factor  
            return img_

------------------  LegendCreator.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on 23/01/2016

@author: Paloschi
'''
from Modelo.beans.SerialFileData import SerialTemporalFiles
from datetime import datetime as dt
import datetime
from datetime import timedelta
from matplotlib.dates import seconds

path = "D:\\1 - Mestrado (segundo semestre)\\1-Dissertacao\\DVD Apendice A\\Imagens\\2-Kc"
prefixo = ""
sufixo = ""
mascara = "%Y-%m-%d"
duracao = 50

serie_img = SerialTemporalFiles(root_path = path)
serie_img.sufixo = sufixo
serie_img.prefixo = prefixo
serie_img.date_mask = mascara

tempo = datetime.timedelta(milliseconds = 0)
duracao = datetime.timedelta(milliseconds = duracao)

#print "---------------------"
#print "tempo", tempo
#print "duração", duracao
#print "---------------------"

serie_img.loadListByRoot()

for i in range(len(serie_img)):
    tempo_somado = tempo + duracao
    data = serie_img.getDate_time(i)
    print i + 1
    print tempo, "-->", tempo_somado
    print dt.strftime(data,"%d/%m/%Y")
    tempo = tempo_somado
    print ""
    


------------------  MainWindow.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MainWindow.ui'
#
# Created: Mon Apr 13 10:03:42 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class TreeWidgetItem(QtGui.QTreeWidgetItem):
    def mouseMoveEvent(self, e):
        
        #if e.buttons() != QtCore.Qt.RightButton:
            #return

        # write the relative cursor position to mime data
        mimeData = QtCore.QMimeData()
        # simple string with 'x,y'
        mimeData.setText('%d,%d' % (e.x(), e.y()))

        # let's make it fancy. we'll show a "ghost" of the button as we drag
        # grab the button to a pixmap
        pixmap = QtGui.QPixmap.grabWidget(self)

        # below makes the pixmap half transparent
        painter = QtGui.QPainter(pixmap)
        painter.setCompositionMode(painter.CompositionMode_DestinationIn)
        painter.fillRect(pixmap.rect(), QtGui.QColor(0, 0, 0, 127))
        painter.end()

        # make a QDrag
        drag = QtGui.QDrag(self)
        # put our MimeData
        drag.setMimeData(mimeData)
        # set its Pixmap
        drag.setPixmap(pixmap)
        # shift the Pixmap so that it coincides with the cursor position
        drag.setHotSpot(e.pos())

        # start the drag operation
        # exec_ will return the accepted action from dropEvent
        if drag.exec_(QtCore.Qt.CopyAction | QtCore.Qt.MoveAction) == QtCore.Qt.MoveAction:
            print 'moved'
        else:
            print 'copied'

class Ui_MainWindow(QtGui.QMainWindow):
    
    def __init__(self):

        QtGui.QMainWindow.__init__(self)
        self.setupUi(self)
        
    def dragEnterEvent(self, e):
        e.accept()    
        
    def initUI(self):
        self.setAcceptDrops(True)
        
    def setupUi(self, MainWindow):
        self.setAcceptDrops(True)
        MainWindow.setObjectName(_fromUtf8("MainWindow"))
        MainWindow.resize(777, 474)
        #MainWindow.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        ## uniform one for the horizontal headers.

        self.centralwidget = QtGui.QWidget(MainWindow)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.treeWidget_2 = QtGui.QTreeWidget(self.centralwidget)
        self.treeWidget_2.setAcceptDrops(True)
        self.treeWidget_2.setObjectName(_fromUtf8("treeWidget_2"))
        item_0 = TreeWidgetItem(self.treeWidget_2)
        item_0.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsDragEnabled)
        item_0 = TreeWidgetItem(self.treeWidget_2)
        item_1 = TreeWidgetItem(item_0)
        item_1.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsDragEnabled)
       
        self.menuFun_o_es = QtGui.QMenu(self.menubar)
        self.menuFun_o_es.setObjectName(_fromUtf8("menuFun_o_es"))
        
        self.horizontalLayout.addWidget(self.treeWidget_2)
        self.treeWidget = QtGui.QTreeWidget(self.centralwidget)
        self.treeWidget.setAcceptDrops(True)
        self.treeWidget.setObjectName(_fromUtf8("treeWidget"))
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsDragEnabled)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_0 = TreeWidgetItem(self.treeWidget)
        item_1 = TreeWidgetItem(item_0)
        self.horizontalLayout.addWidget(self.treeWidget)
        self.treeWidget_3 = QtGui.QTreeWidget(self.centralwidget)
        self.treeWidget_3.setAcceptDrops(True)
        self.treeWidget_3.setObjectName(_fromUtf8("treeWidget_3"))
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsDragEnabled)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_0 = TreeWidgetItem(self.treeWidget_3)
        item_1 = TreeWidgetItem(item_0)
        self.horizontalLayout.addWidget(self.treeWidget_3)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.treeWidget_3.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtGui.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 777, 21))
        self.menubar.setObjectName(_fromUtf8("menubar"))
        self.menuBH = QtGui.QMenu(self.menubar)
        self.menuBH.setObjectName(_fromUtf8("menuBH"))
        self.menuProdutividade = QtGui.QMenu(self.menubar)
        self.menuProdutividade.setObjectName(_fromUtf8("menuProdutividade"))
        self.menuCarregar_Dado = QtGui.QMenu(self.menuProdutividade)
        self.menuCarregar_Dado.setObjectName(_fromUtf8("menuCarregar_Dado"))
        self.menuEstatisticas = QtGui.QMenu(self.menubar)
        self.menuEstatisticas.setObjectName(_fromUtf8("menuEstatisticas"))
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtGui.QStatusBar(MainWindow)
        self.statusbar.setObjectName(_fromUtf8("statusbar"))
        MainWindow.setStatusBar(self.statusbar)
        self.actionETc = QtGui.QAction(MainWindow)
        self.actionETc.setObjectName(_fromUtf8("actionETc"))
        self.actionTAW = QtGui.QAction(MainWindow)
        self.actionTAW.setObjectName(_fromUtf8("actionTAW"))
        self.actionEsgotamento_BHFAO = QtGui.QAction(MainWindow)
        self.actionEsgotamento_BHFAO.setObjectName(_fromUtf8("actionEsgotamento_BHFAO"))
        self.actionPPB = QtGui.QAction(MainWindow)
        self.actionPPB.setObjectName(_fromUtf8("actionPPB"))
        self.actionCarregar_lista_de_dados = QtGui.QAction(MainWindow)
        self.actionCarregar_lista_de_dados.setObjectName(_fromUtf8("actionCarregar_lista_de_dados"))
        self.actionCriar_dado_tabelado = QtGui.QAction(MainWindow)
        self.actionCriar_dado_tabelado.setObjectName(_fromUtf8("actionCriar_dado_tabelado"))
        self.actionYaFao = QtGui.QAction(MainWindow)
        self.actionYaFao.setObjectName(_fromUtf8("actionYaFao"))
        self.actionListar_Fun_oes = QtGui.QAction(MainWindow)
        self.actionListar_Fun_oes.setObjectName(_fromUtf8("actionListar_Fun_oes"))
        self.actionRodar = QtGui.QAction(MainWindow)
        self.actionRodar.setObjectName(_fromUtf8("actionRodar"))
        self.menuBH.addAction(self.actionETc)
        self.menuBH.addAction(self.actionTAW)
        self.menuBH.addAction(self.actionEsgotamento_BHFAO)
        self.menuCarregar_Dado.addAction(self.actionPPB)
        self.menuCarregar_Dado.addAction(self.actionCarregar_lista_de_dados)
        self.menuCarregar_Dado.addAction(self.actionCriar_dado_tabelado)
        self.menuProdutividade.addAction(self.menuCarregar_Dado.menuAction())
        self.menuProdutividade.addAction(self.actionYaFao)
        
        self.menuFun_o_es.addAction(self.actionListar_Fun_oes)
        self.menuEstatisticas.addAction(self.actionRodar)
        self.menubar.addAction(self.menuFun_o_es.menuAction())        
        self.menubar.addAction(self.menuEstatisticas.menuAction())
        self.menubar.addAction(self.menuBH.menuAction())
        
        self.menubar.addAction(self.menuProdutividade.menuAction())


        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        MainWindow.setWindowTitle(_translate("MainWindow", "Gafanhoto", None))
        self.treeWidget_2.headerItem().setText(0, _translate("MainWindow", "Funções", None))
        __sortingEnabled = self.treeWidget_2.isSortingEnabled()
        self.treeWidget_2.setSortingEnabled(False)
        self.treeWidget_2.topLevelItem(0).setText(0, _translate("MainWindow", "Item", None))
        self.treeWidget_2.topLevelItem(1).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_2.topLevelItem(1).child(0).setText(0, _translate("MainWindow", "New Subitem", None))
        self.treeWidget_2.setSortingEnabled(__sortingEnabled)
        self.treeWidget.headerItem().setText(0, _translate("MainWindow", "Modelo XYZ", None))
        __sortingEnabled = self.treeWidget.isSortingEnabled()
        self.treeWidget.setSortingEnabled(False)
        self.treeWidget.topLevelItem(0).setText(0, _translate("MainWindow", "Item", None))
        self.treeWidget.topLevelItem(1).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(2).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(3).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(4).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(5).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(6).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(7).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(8).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(9).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(10).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(11).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(12).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(13).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(14).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(15).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget.topLevelItem(15).child(0).setText(0, _translate("MainWindow", "New Subitem", None))
        self.treeWidget.setSortingEnabled(__sortingEnabled)
        self.treeWidget_3.headerItem().setText(0, _translate("MainWindow", "Dados", None))
        __sortingEnabled = self.treeWidget_3.isSortingEnabled()
        self.treeWidget_3.setSortingEnabled(False)
        self.treeWidget_3.topLevelItem(0).setText(0, _translate("MainWindow", "Item", None))
        self.treeWidget_3.topLevelItem(1).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(2).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(3).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(4).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(5).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(6).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(7).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(8).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(9).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(10).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(11).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(12).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(13).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(14).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(15).setText(0, _translate("MainWindow", "New Item", None))
        self.treeWidget_3.topLevelItem(15).child(0).setText(0, _translate("MainWindow", "New Subitem", None))
        self.treeWidget_3.setSortingEnabled(__sortingEnabled)
        self.memenuBHetTitle(_translate("MainWindow", "File", None))
        self.memenuProdutividadeetTitle(_translate("MainWindow", "Dados", None))
        self.menuCarregar_Dado.setTitle(_translate("MainWindow", "Carregar dado", None))
        self.menuFun_o_es.setTitle(_translate("MainWindow", "Funções", None))
        self.menumenuEstatisticasTitle(_translate("MainWindow", "Modelo", None))
        self.actiactionETcText(_translate("MainWindow", "Carregar Modelo", None))
        self.actiactionTAWText(_translate("MainWindow", "Salvar Modelo (Ctrl + S)", None))
        self.actiBHFAOText(_translate("MainWindow", "Salvar Como", None))
        self.actiactionPPBText(_translate("MainWindow", "Carregar dado Simples", None))
        self.actionCarregar_lista_de_dados.setText(_translate("MainWindow", "Carregar lista de dados", None))
        self.actionCriar_dado_tabelado.setText(_translate("MainWindow", "Criar dado tabelado", None))
        self.actiactionYaFaoText(_translate("MainWindow", "Mostrar dados do modelo", None))
        self.actionListar_Fun_oes.setText(_translate("MainWindow", "Listar Funções", None))
        self.actionRodar.setText(_translate("MainWindow", "Executar", None))
        
 
        self.treeWidget_3.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeWidget_3.customContextMenuRequested.connect(self.openMenu)
        #headers.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
        #headers.customContextMenuRequested.connect(self.contextMenuEvent)
    
    def openMenu(self, position):
      
        indexes = self.treeWidget_3.selectedIndexes()
        if len(indexes) > 0:
            level = 0
            index = indexes[0]
            while index.parent().isValid():
                index = index.parent()
                level += 1
         
        menu = QtGui.QMenu()
        if level == 0:
            menu.addAction("Adicionar dado", self.new_data)
            menu.addAction("Adicionar dado serial", self.new_serialdata)
            menu.addAction("Adicionar dado tabelado", self.new_tabledata)
            menu.addAction("Remover dado", self.remove_data)
            menu.addAction("Copiar dado", self.copy_data)
        elif level == 1:
            menu.addAction(self.tr("Edit object/container"))
        elif level == 2:
            menu.addAction(self.tr("Edit object"))
         
        menu.exec_(self.treeWidget_3.viewport().mapToGlobal(position)) 
        
    def new_data(self, parent=None):
        print("Adicionando dado simples")
    
    def new_serialdata(self, parent=None):
        print("Adicionando dado serial")
    
    def new_tabledata(self, parent=None):
        print("Adicionando dado tabelado")
    
    def remove_data(self, parent=None):

        root = self.treeWidget_3.invisibleRootItem()
        for item in self.treeWidget_3.selectedItems():
            (item.parent() or root).removeChild(item)
    
    def copy_data(self, parent=None):
        pass
        
    def create_popup_menu(self, parent=None):
        self.popup_menu = QtGui.QMenu(parent)
        self.popup_menu.addAction("New", self.new_cluster)
        self.popup_menu.addAction("Rename", self.rename_cluster)
        self.popup_menu.addSeparator()
        self.popup_menu.addAction("Delete", self.delete_cluster)
            
    def contextMenuEvent(self, event):
         
        menu = QtGui.QMenu(self)
        
        quitAction = menu.addAction("Quit")
        
        index = self.indexAt(event.pos())
        
        print (index.collum())
        
        action = menu.exec_(self.menuDamenuProdutividadeGlobal(event.pos()))
        
        if action == quitAction:
            QtGui.qApp.quit()
            
    def dropEvent(self, e):
        # get the relative position from the mime data
        mime = e.mimeData().text()
        x, y = map(int, mime.split(','))

        if e.keyboardModifiers() & QtCore.Qt.ShiftModifier:
            # copy
            # so create a new button
            button = TreeWidgetItem('Button', self)
            # move it to the position adjusted with the cursor position at drag
            button.move(e.pos()-QtCore.QPoint(x, y))
            # show it
            button.show()
            # store it
            #self.buttons.append(button)
            # set the drop action as Copy
            e.setDropAction(QtCore.Qt.CopyAction)
        else:
            # move
            # so move the dragged button (i.e. event.source())
            e.source().move(e.pos()-QtCore.QPoint(x, y))
            # set the drop action as Move
            e.setDropAction(QtCore.Qt.MoveAction)
        # tell the QDrag we accepted it
        e.accept()
        
if __name__ == '__main__':
    import sys
    app = QtGui.QApplication(sys.argv)
    #controller = InterpoladorECMWF_Demo_Controller.InterpoladorECMWF_Demo_Controller()

    ex = Ui_MainWindow()
    #controller.form = ex
    
    ex.show()
    sys.exit()


------------------  PPR.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Nov 19, 2015

@author: rennan.paloschi
'''

from Modelo.Funcoes import AbstractFunction
import numpy as np
from Modelo.beans import RasterFile, SERIAL_FILE_DATA
from Modelo.beans.SerialFileData import  SerialTemporalFiles
import gdal
progress = gdal.TermProgress_nocb
import time
import threading

class PPR(AbstractFunction):
    
    def __setParamIN__(self):
        self.descriptionIN["T"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de temperatura média"}
        self.descriptionIN["Cc"] = {"Required":True, "Type":None, "Description":"ìndice de colheita, valor double"}
        self.descriptionIN["PPR"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Configuração de imagens produtividade potencial bruta"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["PPR"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens produtividade potencial bruta"}
    
    def __execOperation__(self):
        
        serie_T = self.paramentrosIN_carregados["T"].loadListByRoot()
        serie_PPR = self.paramentrosIN_carregados["PPR"]
        self.Cc = self.paramentrosIN_carregados["Cc"]
        
        matriz = serie_T[0]
        matriz_ = matriz.loadRasterData()
        info = matriz.getRasterInformation()
        nullValue = info["NoData"]
        
        img_lat = self.img_lat_long(info, matriz_, nullValue)
        lat_rad = np.radians(img_lat)
        
        a = float(180)/np.pi
        
        ii=1
        
        for T in serie_T:
            
            if threading.currentThread().stopped()  : return 

            
            start = time.time()
            T_ = np.array(T.loadRasterData()).astype(dtype="float32")
            data_T = serie_T.getDate_time(file=T)
            dj = data_T.timetuple().tm_yday # Dia Juliano
            
            #print dj
            
            declinacao_solar = 23.45 * np.sin(np.radians((float(360)/float(365)) * (float(dj)-float(80))))
            declinacao_solar_r = np.radians(declinacao_solar)
            
            angulo_solar = np.arccos(np.radians(-np.tan(lat_rad) * np.tan(declinacao_solar_r))) * a

            "DR = Distancia relativa sol-terra"
            agulo_solar_r = np.radians(angulo_solar)
            if declinacao_solar != 0:
                DR = 1 + 0.0033 * np.cos(np.radians(360/(365*declinacao_solar)))
            else :
                DR = 1
            
            radiacao_topo_atmosfera = 37.6 * DR * ((np.pi/180) * angulo_solar * np.sin(declinacao_solar_r) * np.sin(lat_rad) + np.cos(declinacao_solar_r) * np.cos(lat_rad) * np.sin(agulo_solar_r))
            #radiacao_topo_atmosfera = radiacao_topo_atmosfera * 23.92344
            
            ctn = 0.583 + 0.014 * T_ + 0.0013 * (T_**2) - 0.000037 * (T_**3)
            ctc = -0.0425 + 0.035 * T_ + 0.00325 * (T_**2) - 0.0000925 * (T_**3)
            
            n_t = range(len(T_))
            
            for i in n_t: 
                
                index = [(T_[i]<16.5) & (T_[i]>37)]
                
                ctn[i][index] = -0.0425 + 0.035 * T_[i][index] + 0.00325 * (T_[i][index]**2) - 0.0000925 * (T_[i][index]**3)
                ctc[i][index] = -1.085 + 0.07 * T_[i][index] + 0.0065 * (T_[i][index]**2) - 0.000185 * (T_[i][index]**3)
                
            
            PPBn = (31.7+0.219*radiacao_topo_atmosfera) * ctn * 0.6
            
            PPBc = (107.2+0.219*radiacao_topo_atmosfera) * ctc * 0.6
            
            PPBp = PPBn + PPBc
            
            PPR_ = 0.265455 * self.Cc * PPBp

            PPR = RasterFile(file_path=serie_PPR.root_path, ext="tif")
            PPR = serie_PPR.setDate_time(data_T, file=PPR)       
            PPR.metadata = T.metadata
            PPR.data = PPR_
            PPR.saveRasterData()
            PPR.data = None
            serie_PPR.append(PPR)
            
            ii +=1
            end = time.time()
            
            self.console("tempo restante(m):" + str( np.round(((end - start)  * (len(serie_T)-ii)) /60, 2)))
            self.setProgresso(ii, len(serie_T))
            
        return serie_PPR
            
            
    def img_lat_long(self, info, matriz_, nullValue):
        
        n_linhas = len(matriz_)
        n_colunas = len(matriz_[0])
        
        img_lat = np.zeros((n_linhas, n_colunas)).astype(dtype="float32")
        #img_long = np.zeros((n_linhas, n_colunas)).astype(dtype="float32")
        
        x_pixelSize, y_pixelSize = self.pixel_size(info)
        
        init_y_position = float(info["ymax"]) - (y_pixelSize/2)
        #init_x_position = float(info["xmin"]) + (x_pixelSize/2)
        
        for i_linha in range(0, n_linhas):
            
            self.setProgresso(i_linha, n_linhas)
            progress(self.progresso/100) 
            cy = init_y_position - (y_pixelSize * i_linha)
            img_lat[i_linha][:] = cy
        
        return img_lat#, img_long       
                      
    def pixel_size(self, info):
        
        xmin = float(info["xmin"])
        xmax = float(info["xmax"])
        nx = float(info["nx"])
        x_pixelSize = (xmax - xmin) / nx
        
        ymin = float(info["ymin"])
        ymax = float(info["ymax"])
        ny = float(info["ny"])
        y_pixelSize = (ymax - ymin) / ny  
        
        return x_pixelSize, y_pixelSize
                    
    def testar(self):
        
        self.paramentrosIN_carregados = dict()
        self.paramentrosIN_carregados["images"] = SerialTemporalFiles(root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Tratamento de dados\\ECMWF\\8-Diario\\tav")
        self.paramentrosIN_carregados["images"].prefixo = "tav_"  
        self.paramentrosIN_carregados["images"].date_mask = "%Y%m%d" 

        self.paramentrosIN_carregados["PPR"] = SerialTemporalFiles(root_path = "C:\\Gafanhoto WorkSpace\\Soja11_12\\Indices_BH\\PPR")
        self.paramentrosIN_carregados["PPR"].prefixo = "ppr_"  
        self.paramentrosIN_carregados["PPR"].date_mask = "%Y-%m-%d" 
                
        self.Cc = 0.355994271009505
         
        self.__execOperation__()
        
    
if __name__ == '__main__':
    ppr = PPR()
    ppr.testar()

------------------  pyexe.py  ------------------
'''
Created on Jun 12, 2015
precisa colocar o argumento py2exe
@author: Paloschi
'''
import matplotlib
matplotlib.use("Agg") # overrule configuration

print(matplotlib.get_configdir())

from distutils.core import setup
import py2exe
Mydata_files = [('images', ['images/icons/icon_trator.png'])]

setup(
    windows=["CyMP.py"],
    data_files= (matplotlib.get_py2exe_datafiles()),
    options = {
            
            "py2exe":{
                      #"dll_excludes" : [],

            "dll_excludes" : ["MSVCP90.dll", "HID.DLL", "api-ms-win-core-processthreads-l1-1-2.dll", 
                              "api-ms-win-core-delayload-l1-1-1.dll", "api-ms-win-core-errorhandling-l1-1-1.dll",
                              "api-ms-win-core-sysinfo-l1-2-1.dll", "api-ms-win-core-heap-l2-1-0.dll", "api-ms-win-core-profile-l1-1-0.dll", 
                              "api-ms-win-core-libraryloader-l1-2-0.dll", "api-ms-win-core-string-obsolete-l1-1-0.dll", 
                              "api-ms-win-security-activedirectoryclient-l1-1-0.dll", "api-ms-win-core-rtlsupport-l1-2-0.dll"],      
            #"dll_include" : [ "api-ms-win-core-processthreads-l1-1-2.dll"],
            
            'packages':['fiona',"rasterio","PyQt4.QtCore","PyQt4.QtGui", ],
            'excludes': ['_gtkagg', '_tkagg', "mswsock.dll", "powrprof.dll"],
            "includes" : ["sip", "matplotlib.backends.backend_tkagg", "FileDialog", "lxml._elementpath"],

        }
    },
    #console = [{'script': 'Gafanhoto.py'}]
)

#setup(console=['MainWindow_2.py'])

------------------  pyexpat.py  ------------------

def __load():
    import imp, os, sys
    try:
        dirname = os.path.dirname(__loader__.archive)
    except NameError:
        dirname = sys.prefix
    path = os.path.join(dirname, 'pyexpat.pyd')
    #print "py2exe extension module", __name__, "->", path
    mod = imp.load_dynamic(__name__, path)
##    mod.frozen = 1
__load()
del __load


------------------  RasterCut.py  ------------------
'''
Created on Sep 17, 2015

@author: rennan.paloschi
'''

from Modelo.Funcoes import AbstractFunction
from Modelo.beans import FILE_DATA, TABLE_DATA

class RasterCuterTool(AbstractFunction):
    '''
    Corta um raster
    '''

    def __init__(self, params):
        '''
        Constructor
        '''
    
    def __setParamIN__(self):
        self.descriptionIN["image"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem a ser cortada"}
        self.descriptionIN["out_full_path"] = {"Required":True, "Type":None, "Description":"Endere�o completo para saida da imagem"}
        
        cut_description = dict()
        cut_description["xmin"] = {"Required":True, "Type":None, "Description":u"posi��o inicial x"}
        cut_description["xmax"] = {"Required":True, "Type":None, "Description":u"posi��o final x"}
        cut_description["ymin"] = {"Required":True, "Type":None, "Description":u"posi��o inicial y"}
        cut_description["ymax"] = {"Required":True, "Type":None, "Description":u"posi��o final y"}
        
        self.descriptionIN["img_out_config"] =  {"Required":True, "Type":TABLE_DATA, "Table_Description":cut_description, "Description":"configura��o do corte"}
        
    def __setParamOUT__(self):
        self.descriptionOUT["CSVs"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"lista de arquivos CSV"}
        self.descriptionOUT["VRTs"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"lista de arquivos vrt"}    
        
        

------------------  RasterData.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Aug 4, 2015

@author: Paloschi
'''
from Modelo.beans import FileData
from Modelo.beans.TableData import TableData

try:
    import rasterio
except:
    print u"ERRO - não foi possível carregar a biblioteca rasterIO, tente configurar as variáveis de ambiente"
import subprocess

class RasterFile(FileData):
    '''
    essa classe representa o tipo de dado Raster (tif, img etc)
    '''
    metadata = None
    caption_nx_ny_name = 'Size is ' 
    caption_xmin_ymin = 'Upper Left'
    caption_xmax_xmin = 'Lower Right'
    caption_NoDataValue = 'NoData Value='
        
    def loadRasterData(self, isCube = False):
        
        if self.data != None : return self.data
        
        try :
        
            with rasterio.open(self.file_full_path) as raster:
                
                self.metadata = raster.meta
                if (not isCube) : 
                    return raster.read_band(1)
                else :
                    cubo = list()
                    i_band = 1
                    while True :
                        try:
                            cubo.append(raster.read_band(i_band))
                            i_band+=1
                        except :
                            break
                    print ("imagem lida, numero de bandas:", i_band-1)
                    return cubo
                
                return self
        
        except :
            
            print "Falha ao tentar abrir imagem", self.file_full_path   
            return None
        
    def saveRasterData(self, band_matrix=None, metadata=None, file_path=None, ext=None):
        '''
            #Salva imagem em uma determinada pasta
        '''
        
        if file_path != None : self.file_path = file_path
        if ext != None : self.file_ext = ext
        if band_matrix != None : self.data = band_matrix
        if metadata != None : self.metadata = metadata
        
        try: 

            '''
                Listas de Drivers GDAL: http://www.gdal.org/formats_list.html
            '''
            #print ("salvando imagem  " + self.file_full_path)
            
            if self.file_ext == "tif" : self.metadata.update(driver="GTiff") 
            elif self.file_ext == "img" : self.metadata.update(driver="HFA") 
            self.metadata.update(dtype=self.data.dtype, compress='lzw')
        

            
            #print(metadata)
            #print(len(self.data), len(self.data[0]))
            
            
            #import os

            #os.chdir(self.file_path)

            #for nome in os.listdir('.'):
                #novo_nome = nome.replace(".tif_EbM", "")
                #os.rename(nome, novo_nome)
                #print nome
                
            #print self.file_full_path
            
            with rasterio.open(path = str(self.file_full_path), mode = 'w', **self.metadata) as dst:
                try:
                    dst.write(self.data, 1)
                except ValueError, e: 
                    print str(e)
                    print "ERRO - Erro ao tentar salvar a imagem: ", self.file_full_path
                    print "MOTIVO - índices inconsistentes, erro ao escrever banda"
            
        except ValueError: 
            print u"ERRO - Erro ao tentar criar imagem "+ self.file_name +", verificar a existência do diretório informado ou se a imagem esta aberta em outro software"
            
    def getLoadJustMetaData(self):
        
        try :
            with rasterio.open(self.file_full_path) as raster:
                
                self.metadata = raster.meta
        
        except :
            print "Falha ao tentar abrir imagem", self.file_full_path   
            return None
            
    def getRasterInformation(self):
           
        data = TableData()
        
        print("Obtendo informacao da imagem")
               
        info = subprocess.check_output(['gdalinfo', '-nogcp','-nomd', '-norat', '-noct', str(self.file_full_path)])
        
        # recupera numero de linhas e colunas
        
        index_init = info.index(self.caption_nx_ny_name)
        text_rest = info[index_init:]
        index_end = text_rest.index('\n') + index_init
        
        info_s = info[index_init + len(self.caption_nx_ny_name):index_end]
        info_s = info_s.replace('\r', '').split(', ')
        
        data['nx'] = info_s[0]
        data['ny'] = info_s[1]
        
        # recupera numero inicio do mapa xmax e ymax
        index_init = info.index(self.caption_xmin_ymin)
        text_rest = info[index_init:]
        index_end = text_rest.index('\n') + index_init
        
        info_s = info[index_init + len(self.caption_xmin_ymin):index_end]
        info_s = info_s.replace('\r', '').replace('(','').replace(')','').split(' ')
        
        for atr in info_s:
            if atr == '':
                info_s.remove(atr)
        
        data['xmin'] = info_s[0].replace(' ', '').replace(',', '')
        data['ymin'] = info_s[1].replace(' ', '').replace(',', '')
        
        # recupera numero inicio do mapa xmin e ymin
        index_init = info.index(self.caption_xmax_xmin)
        text_rest = info[index_init:]
        index_end = text_rest.index('\n') + index_init
        
        info_s = info[index_init + len(self.caption_xmax_xmin):index_end]
        info_s = info_s.replace('\r', '').replace('(','').replace(')','').split(' ')
        
        for atr in info_s:
            if atr == '':
                info_s.remove(atr)
        
        data['xmax'] = info_s[0].replace(' ', '').replace(',', '')
        data['ymax'] = info_s[1].replace(' ', '').replace(',', '')
        
        #Recupera NoDataValue
        try: 
            index_init = info.index(self.caption_NoDataValue)
        
            text_rest = info[index_init:]
            index_end = text_rest.index('\n') + index_init
            
            info_s = info[index_init + len(self.caption_NoDataValue):index_end]
            
            data['NoData'] = info_s.replace('\r', '')
        except : 
            data['NoData'] = None
            
        print("Informacoes da imagem lidas")
       
        return data 

------------------  RasterToCSVeVRT.py  ------------------
# -*- coding: utf-8 -*-

'''
Created on Jan 21, 2015
@author: Paloschi
'''

from Modelo.beans import SerialFile, TableData, FileData, SERIAL_FILE_DATA 
import gdal
import Modelo
progress = gdal.TermProgress_nocb
from Modelo.Funcoes import AbstractFunction
from lxml import etree
import threading

class RasterToCSVeVRT(AbstractFunction):
    '''
    Operacao que transforma imagens em arquivos CSV
    '''
    def __setParamIN__(self):
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"lista de imagens para transformar"}
        self.descriptionIN["out_folder"] = {"Required":True, "Type":None, "Description":"Pasta de saida para os arquivos CSV"}
        
    def __setParamOUT__(self):
        self.descriptionOUT["CSVs"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"lista de arquivos CSV"}
        self.descriptionOUT["VRTs"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"lista de arquivos vrt"}
        
    def __execOperation__(self):
        
        imagensIN = self.paramentrosIN_carregados["images"]
        outFolder = self.paramentrosIN_carregados["out_folder"]
        
        imagensIN.loadListByRoot()
        
        nullValue = float(-128)
        listaCSV = SerialFile()
        listaVRT = SerialFile()
        
        print "numero de imagens" + str(imagensIN)
        
        for img in imagensIN :
            
            matriz = img.loadRasterData()
            nullValue = matriz[0][0]
            nome_img = img.file_name
            info = img.getRasterInformation()
            
            print (info)
    
            xmin = float(info["xmin"])
            xmax = float(info["xmax"])
            nx = float(info["nx"])
            x_pixelSize = (xmax - xmin) / nx
        
            ymin = float(info["ymin"])
            ymax = float(info["ymax"])
            ny = float(info["ny"])
            y_pixelSize = (ymax - ymin) / ny    
            
            print("-Criando arquivos CSV para alimentar intorpolador")
        
            progress(0.0)
        
            n_linhas = len(matriz)
            n_colunas = len(matriz[0]) 
            
            csv_file = FileData(file_path=outFolder, file_name = nome_img, ext = "csv")
            file_csv_path = csv_file.file_full_path
            
            #print(file_csv_path)
            
            init_y_position = ymax - (y_pixelSize/2)
            init_x_position = xmin + (x_pixelSize/2)
            
            with open(file_csv_path,'w') as csv:
                csv.write("Easting,Northing,Value\n")
                for i_linha in range(0, n_linhas):
                    progress(i_linha/float(n_linhas-1))
                        
                    self.progresso = (i_linha/float(n_linhas) * 100)
                        
                    cy = init_y_position - (y_pixelSize * i_linha)
                    cy = str(cy)
                    for i_coluna in range(0, n_colunas):
                        
                        value = matriz[i_linha][i_coluna]
                            
                        if threading.current_thread().stopped() : return None
                            
                        if value != nullValue:                 
                            cx = init_x_position + (x_pixelSize * i_coluna)
                                
                            line = str(cx) + ',' + cy + ',' + str(value) + '\n'
                            csv.write(line)
            
            
            listaCSV.append(csv_file)
            
            vrt_file = csv_file
            vrt_file.file_ext = "vrt"
                
            root = etree.Element("OGRVRTDataSource")
            csv_node = etree.Element("OGRVRTLayer", name=csv_file.file_name)   
            root.append(csv_node)
                                      
            csv_node.append(etree.XML("<SrcDataSource>" +file_csv_path+"</SrcDataSource>"))
            csv_node.append(etree.XML("<GeometryType>wkbPoint</GeometryType>"))
            csv_node.append(etree.XML('<GeometryField encoding="PointFromColumns" x="Easting" y="Northing" z="Value"/>'))
                
            tree = etree.ElementTree(root)
            tree.write(vrt_file.file_full_path, pretty_print=True)
            
            listaVRT.append(vrt_file)
                     
        print('-Arquivos CSV criados')

        saida = TableData()
        saida["CSVs"] = listaCSV
        saida["VRTs"] = listaVRT
        
        return saida

if __name__ == '__main__':   
    
    img_teste_path = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\ECMWF\\Teste_raster_csv\\Imagens"
    img_teste = SerialFile(root_path=img_teste_path)
    img_teste.loadListByRoot()
    
    paramIN = dict()
    paramIN["images"] = img_teste
    paramIN["out_folder"] = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\ECMWF\\Teste_raster_csv\\Saida\\"
    
    f = RasterToCSVeVRT()
    
    f.executar(paramIN)
    

------------------  RenomearArquivos.py  ------------------
'''
Created on 01/09/2015

@author: Rennan
'''

import os

os.chdir("D://1 - Mestrado (segundo semestre)//projetos///Estimativa de Semeadura e colheita//Imagens//Recortadas Talhoes de soja 11-12//IintervaloPersonalizado(35-60)//Flat//Soltas")

nomes_substituir = list()
for nome in os.listdir('.'):
    #novo_nome = nome.replace(".tif_EbM", "")
    #os.rename(nome, novo_nome)
    nomes_substituir.append(nome)

os.chdir("D://1 - Mestrado (segundo semestre)//projetos///Estimativa de Semeadura e colheita//Imagens//Recortadas Talhoes de soja 11-12//IintervaloPersonalizado(35-60)//Flat+Savitzky//soltas")

nomes_substituir.reverse()

for nome in os.listdir('.'):
    #print nome
    #print nomes_substituir.pop()
    os.rename(nome, nomes_substituir.pop())
    
print 'OK'

------------------  SerialFileData.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 16, 2015

@author: Paloschi
'''

from AbstractData import ABData, SERIAL_FILE_DATA
from Modelo.beans import RasterFile
import os
import gdal
import rasterio
import sys
import datetime

progress = gdal.TermProgress_nocb

class SerialFile(ABData, list):
    '''
        Por default le somente tif e img
        A menos que uma classe especifica precise de outros arquivos
        entao deve-se modificar os filtros
    '''
    
    __root_path = None
    root_filter = ("tif", "tiff", "img")
    metadata = None  
    out_datatype = None  

    def __init__(self, **params):
        super(SerialFile, self).__init__(SERIAL_FILE_DATA)
        
        if params.get("root_filter") != None : self.root_filter = params.get("root_filter")
        if params.get("root_path") != None : self.root_path = params.get("root_path")
    
    @property
    def root_path(self):
        return self.__root_path
    
    @root_path.setter
    def root_path(self, root_path):
        self.__root_path = os.path.normpath(root_path)  
        
    def loadListByRoot(self, rootDir=None, filtro=None):
        '''
            Abre uma lista de mapas localizados em uma determinada pasta
        ''' 
        
        if rootDir != None : self.root_path = rootDir
        if filtro != None : self.root_filter = filtro
        
        print("endereco das imagens: ", self.root_path)
        
        caminhos = [os.path.join(self.root_path, nome) for nome in os.listdir(self.root_path)]
        arquivos = [arq for arq in caminhos if os.path.isfile(arq)]
        
        
        for f in arquivos:
            f = RasterFile(file_full_path = f)  
            if(self.root_filter==None):
                self.append(f)
            else:
                if( f.file_ext in self.root_filter):
                    self.append(f)
                        
        return self 
        
    def loadListRasterData(self):
        '''
            Carreca os dados matriciais e forma uma matriz de 3 dimenções
            As configurações de metadado raster que serão consideradas, serão do primeiro raster lido
        '''
        
        if len(self) == 0 : self.loadListByRoot()
        n_files = len(self)
        
        sys.stdout.write( "Carregando arquivos (" + str(n_files) + " arquivos): ")
        
        
        files = list()    
        n_iteracoes = 0
        progress(0.0)
        
        for f in self:
            file = f.loadRasterData()
            if (file==None):
                print "Não foi possivel carregar a imagem", f.file_full_path
                return None
            else:
                files.append(file)
                n_iteracoes+=1
                progress( n_iteracoes / float(n_files))

        if len(self)!=0:
            progress( float(1)) 
            self.metadata = self[0].metadata
            return files
        else:
            print "nenhuma imagem caregada"
            return None
        
    def saveListByRoot(self, root_path=None, ext=None, sufixo=None):
        
        '''
            Salva lista de dados presentes em uma determinada pasta
            
            Se não tiver extenção declarada, será gravado na primeira extençao da primeira imagem
        '''
        
        if len(self) == 0:
            print "não há nenhuma imagem a ser salva"
            
        if root_path != None : self.root_path = root_path
        
        
        n_images =  len(self)
        
        sys.stdout.write( "Salvando arquivos (" + str(n_images) + " arquivos): ")
        progress(0.0)
        
        for i in range(0, n_images): 
            
            image = self[i]
            
            if sufixo != None : image.file_name = image.file_name + sufixo
            if ext != None : image.file_ext = ext
            if root_path != None : image.file_path = root_path
            
            image.saveRasterData(image.data, metadata= self.metadata)
            progress( i+1 / float(n_images)) 

    def saveListLike1Image(self, name=None, images_bands_matrix=None, root_path=None, ext=None):
 
        if images_bands_matrix != None : 
            self.metadata.update(dtype=images_bands_matrix.dtype) 
            n_images =  len(images_bands_matrix)

        else:
            images_bands_matrix = self.loadListByRoot()
            n_images =  len(self)
            
        if root_path != None : self.root_path = root_path
        if ext == None : ext = self[0].file_ext
        if name != None : self.name = name
        
        self[0].loadRasterData()
        
        self.metadata = self[0].metadata
        
        if ext == "tif" : self.metadata.update(driver="GTiff") 
        elif ext == "img" : self.metadata.update(driver="HFA") 
        
        
        
        self.metadata.update(count=n_images)
        
        self.metadata.update(compress='lzw')
        
        print self.metadata
        
        path = self.root_path + "\\" + name + "." + ext
        
        sys.stdout.write( "Salvando bandas em unico arquivo (" + str(n_images) + " bandas): ")
        progress(0.0)  
               
        with rasterio.open(path = path, mode = 'w', **self.metadata) as dst:
            
            for i in range(0, n_images):
                #print(i)
                band = self[i].loadRasterData()
                dst.write_band(i+1, band)
                progress( float(i) / float(n_images)) 
             
class SerialTemporalFiles(SerialFile):
    
    prefixo = ""
    sufixo = ""
    date_mask = ""
    mutiply_factor = 1
    
    
    
    def getDate_time(self, i=None, file=None):
        '''
            Essa função foi criada para facilitar a obtenção da data do arquivo como objeto date
        '''
        
        
        if file==None : file = self[i]
        
        only_date = file.file_name

        if self.prefixo!=None : 
            only_date = only_date.replace(self.prefixo,"")
        if self.sufixo!=None : only_date = only_date.replace(self.sufixo, "")  
        date = datetime.datetime.strptime(only_date, self.date_mask) 
        
        return date

    def setDate_time(self, date, i=None, file=None):
        '''
            Essa função foi criada para facilitar a criação do nome baseado em data
        '''
        if i is not None:
            file = self[i]
        only_date = date.strftime(self.date_mask)   
        name = self.prefixo + only_date + self.sufixo
        file.file_name = name
        return file
    
        

    

------------------  SerialFiles2Cube.py  ------------------
'''
Created on 04/12/2015

@author: Paloschi
'''
from Modelo.beans.SerialFileData import SerialFile

nome_cubo = "Cubo_dr_soja_2011_12"

if __name__ == '__main__':
    
    imagens = SerialFile(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\4-Dr")
    imagens.saveListLike1Image(nome_cubo)
    

------------------  Soma.py  ------------------
'''
Created on 04/12/2015

@author: Paloschi
'''
from Modelo.beans.SerialFileData import SerialFile
from Modelo.beans import RasterData
import numpy

nome_cubo = "Cubo_dr_soja_2011_12"

if __name__ == '__main__':
    
    imagens = SerialFile(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\7-Ya2")
    imagens.loadListByRoot()
    
    img_ = numpy.array(imagens[0].loadRasterData()).astype(dtype="uint32")
    print "tamanho:", len(imagens)
    
    for i in range(len(imagens)-1):
        img_ += imagens[i+1].loadRasterData()
        print i
        
    img_total = RasterData.RasterFile()
    img_total.file_full_path = "C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\7-Ya2\\soma.tif"
    img_total.saveRasterData(img_, imagens[0].metadata)
        
        
    

------------------  soma_bandas.py  ------------------
'''
Created on 10/01/2016

@author: Paloschi
'''

from Modelo.beans import RasterFile
root = "D:\\1 - Mestrado (segundo semestre)\\Dissertacao\\Estudo de caso\\Cubos\\"
path = root + "Cubo_Ya_invertido.tif"
import numpy as np

raster = RasterFile(file_full_path = path)
data_raster = raster.loadRasterData(True)



nodata = raster.metadata["nodata"]

metadata = raster.metadata
metadata["count"] = 1

print raster.metadata

soma = imagem_kc_ = np.zeros((len(data_raster[1]), len(data_raster[1][0]))).astype(dtype="float32")

for band in data_raster:
    soma += band

saida = RasterFile(file_full_path= path)
saida.file_name = "ya_invertido_soma"
saida.metadata = raster.metadata
saida.data = soma

saida.saveRasterData()
    


------------------  SplitTable.py  ------------------
'''
Created on Mar 3, 2015

@author: Paloschi
'''
from Modelo.beans import ABData

class SplitTable(ABData):
    '''
    separa uma tabela baseado em uma lista de atributos
    '''
    
    def __init__(self, nome=None):
        self.__data = None
        self.data_name = nome
        self.data_type = "operation"
    
    @property    
    def data(self):
        dados = self.__data.data
        dados_tabela = dados['table'].data # se tiver mais que uma tabela, so faz a primeira
        tabela = dados_tabela['table_data']
        atributos = dados['atributos']
        data = dict()
        data['data_path'] = dados_tabela['data_path']
        
        if atributos == None:
            data["unicMap"] = tabela
            return data
        
        print("Dividindo tabela de dados em grupos...")  
        
        for tupla in tabela:
            id = str()
            
            for atributo in atributos:
                id += str(tupla['properties'][atributo]) 
            
            try:
                data[id].append(tupla)
            
            except:
                tuplas = list()
                tuplas.append(tupla)
                data[id] = tuplas
        
        print ("Seperacao em gupos Completada")
        
        return data
        

    @data.setter
    def data(self, data):
        self.__data = data

------------------  StatisticalStractor.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Apr 8, 2015

@author: Paloschi
'''
                                  
from numpy.core.numeric import array
import numpy as np
from Modelo.beans import SerialFile, TableData, SERIAL_FILE_DATA, RasterFile
from Modelo.Funcoes import AbstractFunction
import gdal
progress = gdal.TermProgress_nocb
import threading

class SpectreStatisticalStractor(AbstractFunction):
    '''
    Essa função extrai estatisticas do perfil temporal de cada pixel gerando uma imagem separada pra cada pixel
    
    '''

    def __setParamIN__(self):
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para procurar as datas"}
        self.descriptionIN["null_value"] = {"Required":False, "Type":None, "Description":"valor nulo a ser ignorado"}
        self.descriptionIN["statistics"] = {"Required":True, "Type":None, "Description":"lista de estatisticas a serem feitas, nesta versão são suportados: Media (media), Coeficiente de variação (cv) e desvio padrão (sd)"}
     
    def __setParamOUT__(self):
        self.descriptionOUT["imagens de saida"] = "imagens com as estatisticas" 
        
    def __execOperation__(self):
        
        self.print_text(u"Iniciando função")


        images_super = self.paramentrosIN_carregados["images"]
        self.console(u"Número de imagens para ler: " + str(len(images_super)))
        nullValue = self.paramentrosIN_carregados["null_value"]
        statistics = self.paramentrosIN_carregados["statistics"]
        
        #self.print_text("Estatisticas a fazer: ", statistics)
        
        doMedia = "media" in statistics 
        doCV = "cv" in statistics
        doSD = "sd" in statistics
        doSoma = "soma" in statistics
        doMin = "min" in statistics
        doMax = "max" in statistics
        doMediana = "mediana" in statistics
        doAmplitude = "amplitude" in statistics
        
        images = images_super.loadListRasterData()
        
        #self.print_text("Numero de imagens lidas: " + str(len(images)))
        
        n_linhas = len(images[0])
        n_colunas = len(images[0][0])
        
        for img in images:
            if len(img) != n_linhas or len(img[0]) != n_colunas:
                raise IndexError("Erro - As imagens precisam ter o mesmo número de linhas e colunas")
                
                
        #self.print_text("numero de colunas e linhas: " + str(n_linhas) + " : " + str(n_colunas))
        
        #imagem_referencia = [[0 for x in range(n_colunas)] for x in range(n_linhas)]  
        imagem_referencia = np.zeros((n_linhas, n_colunas))
        
        if doMedia : imagem_media = array(imagem_referencia).astype(dtype="float32")
        if doCV : imagem_cv = array(imagem_referencia).astype(dtype="float32")
        if doSD : imagem_sd = array(imagem_referencia)#.astype(dtype="int16")
        if doSoma : imagem_soma = array(imagem_referencia).astype(dtype="float32")
        if doMin : imagem_min = array(imagem_referencia).astype(dtype="float32")
        if doMax : imagem_max = array(imagem_referencia).astype(dtype="float32")
        if doMediana : imagem_mediana = array(imagem_referencia)#.astype(dtype="int16")
        if doAmplitude : imagem_amplitude = array(imagem_referencia).astype(dtype="float32")
        
        

        self.print_text(u"Processando:")
        
        
        #progress( 0.0)
        
        for i_linha in range(0, n_linhas):
            
            #status = i_linha+1/float(n_linhas)
            #progress(float(i_linha/float(n_linhas)))
            self.progresso = (float(i_linha/float(n_linhas)))*100

            for i_coluna in range(0, n_colunas):
                    line = list()
                    
                
                    if threading.currentThread().stopped() : return 

                #if nullValue != None and float(nullValue) == images[1][i_linha][i_coluna] :
                    #pass
                
                #else:              
                    for img in images:
                        line.append(img[i_linha][i_coluna])
                    
                    mean = None
                    sd = None
                    
                    if doCV : 

                        mean = np.nanmean(line)
                        sd = np.nanstd(line) 
                        
                        divisor = mean * 100
                        if divisor != 0 : cv = sd / mean * 100 
                        else : cv = 0
                        
                        imagem_cv[i_linha][i_coluna] = cv
        
                        
                    
                    if doMedia : 
                        if mean == None : mean = np.nanmean(line) # calcula a média
                        imagem_media[i_linha][i_coluna] = mean
                    
                    
                    if doSD : 
                        if sd == None : sd = np.nanstd(line)  # calcula o desvio padrão
                        imagem_sd[i_linha][i_coluna] = sd
                        
                    if doSoma : 
                        soma = np.nansum(line)
                        imagem_soma[i_linha][i_coluna] = soma
                    
                    minimo = None 
                    if doMin : 
                        minimo = np.nanmin(line)
                        imagem_min[i_linha][i_coluna] = minimo
                    
                    maximo = None
                    if doMax : 
                        maximo = np.nanmax(line)
                        imagem_max[i_linha][i_coluna] = maximo
                    
                    if doMediana :
                        mediana = np.nanmedian(line)
                        imagem_mediana[i_linha][i_coluna] = mediana
                    
                    if doAmplitude :
                        if minimo == None : minimo = np.nanmin(line)
                        if maximo == None : maximo = np.nanmax(line)
                        amplitude = maximo - minimo
                        imagem_amplitude[i_linha][i_coluna] = amplitude
        
        self.print_text(u"Arrumando imagens de saida")
        
        saida = SerialFile ()
        saida.metadata = self.paramentrosIN_carregados["images"][0].metadata
        
        if doMedia: 
            imagem_media = RasterFile(data = imagem_media)
            imagem_media.metadata = saida.metadata
            imagem_media.file_name = "imagem_media"
            saida.append(imagem_media) 
        if doCV:
            imagem_cv = RasterFile(data = imagem_cv)
            imagem_cv.metadata = saida.metadata
            imagem_cv.file_name = "imagem_coeficiente_variacao"
            saida.append(imagem_cv)
        if doSD : 
            imagem_sd = RasterFile(data = imagem_sd)
            imagem_sd.metadata = saida.metadata
            imagem_sd.file_name = "imagem_desvio_padrao"
            saida.append(imagem_sd)
        if doSoma : 
            imagem_soma = RasterFile(data = imagem_soma)
            imagem_soma.metadata = saida.metadata
            imagem_soma.file_name = "imagem_soma"
            saida.append(imagem_soma)
        if doMin : 
            imagem_min = RasterFile(data = imagem_min)
            imagem_min.metadata = saida.metadata
            imagem_min.file_name = "imagem_minimo"
            saida.append(imagem_min)
        if doMax : 
            imagem_max = RasterFile(data = imagem_max)
            imagem_max.metadata = saida.metadata
            imagem_max.file_name = "imagem_maximo"
            saida.append(imagem_max)
        if doMediana : 
            imagem_mediana = RasterFile(data = imagem_mediana)
            imagem_mediana.metadata = saida.metadata
            imagem_mediana.file_name = "imagem_mediana"
            saida.append(imagem_mediana)
        if doAmplitude : 
            imagem_amplitude = RasterFile(data = imagem_amplitude)
            imagem_amplitude.metadata = saida.metadata
            imagem_amplitude.file_name = "imagem_amplitude"
            saida.append(imagem_amplitude)
            
        self.print_text(u"imagens prontas para gravar, statistical stractor completo")

        return saida
    
if __name__ == '__main__':   
    
    ss = SpectreStatisticalStractor()
    
    root_ = "C:\\Users\\Paloschi\\Desktop\\data\\Rasters\\TesteFiltro\\entrada\\"
    images = SerialFile(root_path  =  root_)
    images.loadListByRoot(filtro = "tif")
    
    parametrosIN = TableData()
    
    parametrosIN["images"] = images
    parametrosIN["null_value"] = 0
    
    statistics = list()
    statistics.append("media")
    statistics.append("cv")
    
    parametrosIN["statistics"] = statistics

    ss.data = parametrosIN
    resultados = ss.data
    
    imagens = resultados


    
    imagens.saveListByRoot (root_path="C:\\Users\\Paloschi\\Desktop\\data\\Testes\\saida", ext="tif")
    #cv.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")
    #sd.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")

    





------------------  StatisticalStractorMT.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Apr 8, 2015

@author: Paloschi
'''
                                  
from numpy.core.numeric import array
import numpy as np
from Modelo.beans import SerialFile, TableData, SERIAL_FILE_DATA, RasterFile
from Modelo.Funcoes import AbstractFunction
import gdal
from Modelo import GeneralTools
import images

progress = gdal.TermProgress_nocb
import Modelo.GeneralTools
import multiprocessing
import threading
from multiprocessing import Pool
from multiprocessing import Process
    

def processa_linha (linha_img, do):
        
        tamanho = len(linha)   
        status = float(i_linha)

        for i_coluna in range(0, n_colunas):
            line = list()

            if nullValue != None and float(nullValue) == images[1][i_linha][i_coluna] :
                pass
                    
            else:              
                for img in images:
                    
                    line.append(img[0][i_coluna])
                    
                    mean = None
                    if do["Media"] : 
                        mean = np.mean(line) # calcula a média
                        imagem_media[i_linha][i_coluna] = mean
                    sd = None
                    if do["SD"] : 
                        sd = np.nanstd(line) # calcula o desvio padrão
                        imagem_sd[i_linha][i_coluna] = sd
                    if do["CV"] : 
                        if mean == None : mean = np.mean(line)
                        if sd == None : sd = np.nanstd(line) 
                        divisor = mean * 100
                        if divisor != 0 : cv = sd / mean * 100 
                        else : cv = 0
                        imagem_cv[i_linha][i_coluna] = cv
                    if do["Soma"] : 
                        soma = np.sum(line)
                        imagem_soma[i_linha][i_coluna] = soma
                    min = None 
                    if do["Min"] : 
                        min = np.min(line)
                        imagem_min[i_linha][i_coluna] = min
                    max = None
                    if do["Max"] : 
                        max = np.max(line)
                        imagem_max[i_linha][i_coluna] = max
                    if do["Mediana"] :
                        mediana = np.median(line)
                        imagem_mediana[i_linha][i_coluna] = mediana
                    if do["Amplitude"] :
                        if min == None : min = np.min(line)
                        if max == None : max = np.max(line)
                        amplitude = max - min
                        imagem_amplitude[i_linha][i_coluna] = amplitude
        
        threads_ready +=1
        
        print ("Tread Pronta", threads_ready)

class SpectreStatisticalStractor_MT(AbstractFunction):
    '''
    Essa função extrai estatisticas do perfil temporal de cada pixel gerando uma imagem separada pra cada pixel
    
    '''

    def __setParamIN__(self):
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para procurar as datas"}
        self.descriptionIN["statistics"] = {"Required":True, "Type":None, "Description":"lista de estatisticas a serem feitas, nesta versão são suportados: Media (media), Coeficiente de variação (cv) e desvio padrão (sd)"}
     
    def __setParamOUT__(self):
        self.descriptionOUT["imagens de saida"] = "imagens com as estatisticas" 
        
    def __execOperation__(self):
        
        global nullValue, imagem_media, imagem_sd, imagem_cv, imagem_soma, imagem_min, imagem_max
        global imagem_mediana, imagem_amplitude, images, n_linhas, n_colunas, threads_ready, n_threadings
        
        print("executando operação")
        
        images_super = self.paramentrosIN_carregados["images"]
        print("Numero de imagens para ler: " + str(len(images_super)))
        nullValue = np.double(images_super[0].getRasterInformation()["NoData"])
        statistics = self.paramentrosIN_carregados["statistics"]
        
        print("Estatisticas a fazer: ", statistics)
        
        do = dict()
        
        do["Media"] = "media" in statistics 
        do["CV"] = "cv" in statistics
        do["SD"] = "sd" in statistics
        do["Soma"] = "soma" in statistics
        do["Min"] = "min" in statistics
        do["Max"] = "max" in statistics
        do["Mediana"] = "mediana" in statistics
        do["Amplitude"] = "amplitude" in statistics
        
        images = images_super.loadListRasterData()
        
        print("Numero de imagens lidas: " + str(len(images)))
        
        n_linhas = len(images[0])
        n_colunas = len(images[0][0])
        
        for img in images:
            if len(img) != n_linhas or len(img[0]) != n_colunas:
                raise IndexError("Erro - As imagens precisam ter o mesmo número de linhas e colunas")
                   
        print("numero de colunas e linhas: " + str(n_linhas) + " : " + str(n_colunas))
        
        #imagem_referencia = [[0 for x in range(n_colunas)] for x in range(n_linhas)]  
        imagem_referencia = np.zeros((n_linhas, n_colunas))
        
        imagem_out = dict
        
        if do["Media"] : imagem_out["media"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["CV"] : imagem_out["cv"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["SD"] : imagem_out["sd"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["Soma"] : imagem_out["soma"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["Min"] : imagem_out["min"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["Max"] : imagem_out["max"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["Mediana"] : imagem_out["mediana"] = array(imagem_referencia)#.astype(dtype="int16")
        if do["Amplitude"] : imagem_out["amplitude"] = array(imagem_referencia)#.astype(dtype="int16")

        print("processando:") 
        
        numero_de_nucleos = GeneralTools.available_cpu_count()
        n_threadings = int(numero_de_nucleos-2)
        print ("Numero de threads", n_threadings)
        threads_ready = 0
        
        pool = Pool()
        #pool = multiprocessing.Pool(processes=n_threadings)

        for i in range(0, n_threadings):
            #t = threading.Thread(target=thread_process, args=(n_linhas/n_threadings*i, n_linhas/n_threadings*(i+1)))
            #t.start()
            linha_inicial = n_linhas/n_threadings*i
            linha_final = n_linhas/n_threadings*(i+1)
            p = Process(target= thread_process, args=(linha_inicial, linha_final))
            p.start()
            
            #pool.map(thread_process(n_linhas/n_threadings*i, n_linhas/n_threadings*(i+1)))
            #pool.close()
           
        
                    
        
        while (threads_ready < n_threadings):
            pass
       
        print("Arrumando imagens de saida")
        
        saida = SerialFile ()
        saida.metadata = self.paramentrosIN_carregados["images"][0].metadata
        
        if do["Media"]: 
            imagem_media = RasterFile(data = imagem_media)
            imagem_media.metadata = saida.metadata
            imagem_media.file_name = "imagem_media"
            saida.append(imagem_media) 
        if do["CV"]:
            imagem_cv = RasterFile(data = imagem_cv)
            imagem_cv.metadata = saida.metadata
            imagem_cv.file_name = "imagem_coeficiente_variacao"
            saida.append(imagem_cv)
        if do["SD"] : 
            imagem_sd = RasterFile(data = imagem_sd)
            imagem_sd.metadata = saida.metadata
            imagem_sd.file_name = "imagem_desvio_padrao"
            saida.append(imagem_sd)
        if do["Soma"] : 
            imagem_soma = RasterFile(data = imagem_soma)
            imagem_soma.metadata = saida.metadata
            imagem_soma.file_name = "imagem_soma"
            saida.append(imagem_soma)
        if do["Min"] : 
            imagem_min = RasterFile(data = imagem_min)
            imagem_min.metadata = saida.metadata
            imagem_min.file_name = "imagem_minimo"
            saida.append(imagem_min)
        if do["Max"] : 
            imagem_max = RasterFile(data = imagem_max)
            imagem_max.metadata = saida.metadata
            imagem_max.file_name = "imagem_maximo"
            saida.append(imagem_max)
        if do["Mediana"] : 
            imagem_mediana = RasterFile(data = imagem_mediana)
            imagem_mediana.metadata = saida.metadata
            imagem_mediana.file_name = "imagem_mediana"
            saida.append(imagem_mediana)
        if do["Amplitude"] : 
            imagem_amplitude = RasterFile(data = imagem_amplitude)
            imagem_amplitude.metadata = saida.metadata
            imagem_amplitude.file_name = "imagem_amplitude"
            saida.append(imagem_amplitude)
            
        print("imagens prontas para gravar, statistical stractor completo")

        return saida
    
if __name__ == '__main__':   
    
    ss = SpectreStatisticalStractor_MT()
    
    root_ = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\pesada"
    images = SerialFile(root_path  =  root_)
    images.loadListByRoot(filtro = "tif")
    
    
    linha = list()
    for img in images :
        linha.append(img.loadRasterData()[0][:])
    
    print (len(linha), "----------------------------------")
    print (len(linha[0]), "----------------------------------")

    parametrosIN = TableData()
    
    parametrosIN["images"] = images
    
    statistics = list()
    statistics.append("media")
    statistics.append("cv")
    
    parametrosIN["statistics"] = statistics

    ss.data = parametrosIN
    resultados = ss.data
    
    imagens = resultados
    
    print imagens
    
    imagens.saveListByRoot (root_path="C:\\GafanhotoWorkspace", ext="tif")
    #cv.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")
    #sd.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")

    





------------------  StatisticalStractorMT_PorLinha.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Apr 8, 2015

@author: Paloschi
'''
                                  
from numpy.core.numeric import array
import numpy as np
from Modelo.beans import SerialFile, TableData, SERIAL_FILE_DATA, RasterFile
from Modelo.Funcoes import AbstractFunction
import gdal
from Modelo import GeneralTools
import images
from multiprocessing import Pool
import multiprocessing as mp

progress = gdal.TermProgress_nocb

# Define an output queue
output = mp.Queue()

def processa_linha (linha_img, do, i_linha, output):
    output.put(i_linha)
    #return i_linha
    

class SpectreStatisticalStractor_MT(AbstractFunction):
    '''
    Essa função extrai estatisticas do perfil temporal de cada pixel gerando uma imagem separada pra cada pixel
    
    '''



    def __setParamIN__(self):
        self.descriptionIN["images"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens para procurar as datas"}
        self.descriptionIN["statistics"] = {"Required":True, "Type":None, "Description":"lista de estatisticas a serem feitas, nesta versão são suportados: Media (media), Coeficiente de variação (cv) e desvio padrão (sd)"}
     
    def __setParamOUT__(self):
        self.descriptionOUT["imagens de saida"] = "imagens com as estatisticas" 
        
    def __execOperation__(self):
        
        
        ''' -------------------- Parametros iniciais ---------------------------- '''
        
        print("executando operação")
        images_super = self.paramentrosIN_carregados["images"]
        print("Numero de imagens para ler: " + str(len(images_super)))
        statistics = self.paramentrosIN_carregados["statistics"]
        print("Estatisticas a fazer: ", statistics)
        
        do = dict()
        
        do["Media"] = "media" in statistics 
        do["CV"] = "cv" in statistics
        do["SD"] = "sd" in statistics
        do["Soma"] = "soma" in statistics
        do["Min"] = "min" in statistics
        do["Max"] = "max" in statistics
        do["Mediana"] = "mediana" in statistics
        do["Amplitude"] = "amplitude" in statistics
                
        numero_de_nucleos = GeneralTools.available_cpu_count()
        n_threadings = int(numero_de_nucleos-2)
        print ("Numero de threads", n_threadings)
        
        ''' ------------------- Descrição das imagens ----------------------- '''
        
        imagem_referencia = images[0].loadRasterData()
        n_imagens = len(images)
        n_linhas = len(imagem_referencia)
        n_colunas = len(imagem_referencia[0])
        
        ''' --------------------------------------------------------'''
        
        for i_linhas in range(0, n_linhas):       
            linhas = list()      
            for i_thread in range (0, n_threadings) :
                pool = Pool(processes=n_threadings)
                linha = list()
                for img in images : linha.append(img.loadRasterData()[i_thread + i_linhas][:])
                linhas.append(linha)
                
            print len(linhas)
            
            processes = [mp.Process(target=processa_linha, args=(linhas[x], do, i_linhas + x, output)) for x in range(n_threadings)]
            
            # Run processes
            for p in processes:
                p.start()
            # Exit the completed processes
            for p in processes:
                p.join()
                
            results = [output.get() for p in processes]
            
            print(results)
                
            i_linhas+=n_threadings
            
        
        
    
if __name__ == '__main__':   
    
    
    
    ss = SpectreStatisticalStractor_MT()
    
    root_ = "C:\\Users\\rennan.paloschi\\Desktop\\Dados_Gerais\\raster\\pesada"
    images = SerialFile(root_path  =  root_)
    images.loadListByRoot(filtro = "tif")
    
    
    linha = list()
    for img in images :
        linha.append(img.loadRasterData()[0][:])
    
    print (len(linha), "----------------------------------")
    print (len(linha[0]), "----------------------------------")

    parametrosIN = TableData()
    
    parametrosIN["images"] = images
    
    statistics = list()
    statistics.append("media")
    statistics.append("cv")
    
    parametrosIN["statistics"] = statistics

    ss.data = parametrosIN
    resultados = ss.data
    
    imagens = resultados
    
    print imagens
    
    imagens.saveListByRoot (root_path="C:\\GafanhotoWorkspace", ext="tif")
    #cv.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")
    #sd.saveImage("C:\\Users\\Paloschi\\Desktop\\data\\Ajuste extrator de estatisticas\\saida\\", ext=".tif")

    





------------------  TableData.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 16, 2015

@author: Paloschi
'''

from AbstractData import ABData, TABLE_DATA

class TableData(ABData, dict):
    '''
    Classe criada pra guardar diversos tipos de valores, é só pra dar uma organizad 
    '''

    def __init__(self, name=None):
        super(self.__class__, self).__init__(TABLE_DATA)
        self.name = name


------------------  TAW.py  ------------------
# -*- coding: utf-8 -*-
'''
Created on Jul 22, 2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA, FILE_DATA
import gdal
from Modelo.beans.RasterData import RasterFile
progress = gdal.TermProgress_nocb
import numpy
import threading

class TAW(AbstractFunction):
    '''
        Essa função calcula a TAW
    '''
    def __setParamIN__(self):
        
        self.descriptionIN["CAD"] = {"Required":True, "Type":FILE_DATA, "Description":"Imagem de capacidade de armazenamento de agua no solo CAD"}
        self.descriptionIN["Zr"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Série de imagens de Zr distribuido"}
        self.descriptionIN["TAW"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"Configuração para a saída da série de imagens TAW"}
    
    def __setParamOUT__(self):
        self.descriptionOUT["TAW"] = {"Type":SERIAL_FILE_DATA, "Description":"Série de imagens TAW"}
    
    def __execOperation__(self):

        self.console("Carregando imagens.")
        
        serie_Zr = self.paramentrosIN_carregados["Zr"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_TAW = self.paramentrosIN_carregados["TAW"]
        CAD_ = self.paramentrosIN_carregados["CAD"].loadRasterData() # pucha lista
        
        Zr_factor = float(serie_Zr.mutiply_factor)
        TAW_factor = float(serie_TAW.mutiply_factor)
        
        n_zr = len(serie_Zr)
        
        self.console(str(n_zr) + " imagens de Zr encontradas.")
        self.console(u"Gerando série de imagens TAW..")

        '''
            O laço a seguir percorre todas as imagens de Zr presentes
            O calculo da TAW é Zr = CAD * Zr
        '''

        for i in range(n_zr):
            
            if threading.currentThread().stopped()  : return 
            self.setProgresso(i, n_zr)

            zr = serie_Zr[i]
            data_zr = serie_Zr.getDate_time(file=zr)
            zr_ = numpy.array(zr.loadRasterData()).astype(dtype="float32")
            zr_ = zr_ * Zr_factor
            
            taw_ = zr_ * CAD_       
            taw_ *= TAW_factor
            
            taw = RasterFile(file_path=serie_TAW.root_path, ext="tif")
            taw = serie_TAW.setDate_time(data_zr, file=taw)       
            taw.data = taw_
            taw.metadata = zr.metadata
            taw.saveRasterData()
            
            taw.data = None
            serie_TAW.append(taw)
        
        return serie_TAW




------------------  TelaPrincipal.py  ------------------
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MainWindow_2.ui'
#
# Created: Tue Jun 09 11:16:29 2015
#      by: PyQt4 UI code generator 4.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

from DlgEstimativaDatasCultura import Ui_DlgEstimativaDatasAgricolas
from DlgFiltroSavitzGolay import Ui_DlgSavitzGolay
from DlgEstatisticasEspectrais import Ui_DlgEstatisticasEspectrais
from DlgInvdistnnShapeEcmwf2Raster import UI_DlgInterpoladorShapeEcmwf
from DlgInvdistnnRaster2Raster import Ui_InvdistnnRaster2Raster
from DlgDistribuidorDeIndice import Ui_DistribuidorDeIndice
from DlgDecendial2Diario import Ui_Decendial2Diario
import ConfigParser
from Visao import DlgETc, DlgTAW, DlgDr, DlgKs, DlgPPR, DlgYaFao

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig=None):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig=None):
        return QtGui.QApplication.translate(context, text)

class Ui_MainWindow(QtGui.QMainWindow):
    
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        self.setupUi(self)

    def popupYaFao(self):
        popup = DlgYaFao.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()  

    def popupPPB(self):
        popup = DlgPPR.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()   

    def popupKs(self):
        popup = DlgKs.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()   

    def popupDr(self):
        popup = DlgDr.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()   

    def popupTAW(self):
        popup = DlgTAW.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()   
        
    def popupETc(self):
        popup = DlgETc.Ui_Dialog(self)
        popup.setupUi(popup)
        popup.show()        
        
    def popupDecendial_2_diario(self):
        popup = Ui_Decendial2Diario(self)
        popup.setupUi(popup)
        popup.show()

    def popupEstimativa_de_datas_de_colheita(self):
        
        popup = Ui_DlgEstimativaDatasAgricolas(self)
        popup.setupUi(popup)
        
        popup.show()
        
    def popupDestribuidor_de_indice(self):
        
        popup = Ui_DistribuidorDeIndice(self)
        popup.setupUi(popup)
        
        popup.show()
 
    def popupFiltro_Savitz_Golay(self):
        
        popup = Ui_DlgSavitzGolay(self)
        popup.setupUi(popup)
        
        popup.show()
        
    def popupEstatistiscas_Espectrais(self):

        popup = Ui_DlgEstatisticasEspectrais(self)
        popup.setupUi(popup)
        
        popup.show()
        
    def popupInterpolador_ECMWF(self):

        popup = UI_DlgInterpoladorShapeEcmwf()
        popup.setupUi(popup)
        popup.show()
                  
    def popupInterpoladorRaster2Raster(self):

        popup = Ui_InvdistnnRaster2Raster()
        popup.setupUi(popup)
        popup.show()
                  
 
                           
    def setupUi(self, MainWindow):
        
        MainWindow.setObjectName(_fromUtf8("MainWindow"))
        MainWindow.resize(751, 240)
        MainWindow.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
        MainWindow.setAcceptDrops(True)
        
        MainWindow.setIconSize(QtCore.QSize(200, 200))
        
        self.centralwidget = QtGui.QWidget(MainWindow)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        MainWindow.setCentralWidget(self.centralwidget)
        
        self.menubar = QtGui.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 751, 21))
        self.menubar.setObjectName(_fromUtf8("menubar"))
        
        self.menuBH = QtGui.QMenu(self.menubar)
        self.menuBH.setObjectName(_fromUtf8("menuBH"))
        
        self.menuProdutividade = QtGui.QMenu(self.menubar)
        self.menuProdutividade.setObjectName(_fromUtf8("menuProdutividade"))
        
        self.menuCarregar_Dado = QtGui.QMenu(self.menuProdutividade)
        self.menuCarregar_Dado.setObjectName(_fromUtf8("menuCarregar_Dado"))
        
        self.menuFun_o_es = QtGui.QMenu(self.menubar)
        self.menuFun_o_es.setObjectName(_fromUtf8("menuFun_o_es"))
        
        self.menuInterpoladores = QtGui.QMenu(self.menubar)
        self.menuInterpoladores.setObjectName(_fromUtf8("menuInterpoladores"))
        
        self.menuEstatisticas = QtGui.QMenu(self.menubar)
        self.menuEstatisticas.setObjectName(_fromUtf8("menuEstatisticas"))
        
        MainWindow.setMenuBar(self.menubar)
        
        self.statusbar = QtGui.QStatusBar(MainWindow)
        self.statusbar.setObjectName(_fromUtf8("statusbar"))
        MainWindow.setStatusBar(self.statusbar)
        
        self.actionETc = QtGui.QAction(MainWindow)
        self.actionETc.setObjectName(_fromUtf8("actionETc"))
        
        self.actionTAW = QtGui.QAction(MainWindow)
        self.actionTAW.setObjectName(_fromUtf8("actionTAW"))
        
        self.actionEsgotamento_BHFAO = QtGui.QAction(MainWindow)
        self.actionEsgotamento_BHFAO.setObjectName(_fromUtf8("actionEsgotamento_BHFAO"))
        
        self.actionKs = QtGui.QAction(MainWindow)
        self.actionKs.setObjectName(_fromUtf8("actionKs"))
        
        self.actionPPB = QtGui.QAction(MainWindow)
        self.actionPPB.setObjectName(_fromUtf8("actionPPB"))
        
        self.actionCarregar_lista_de_dados = QtGui.QAction(MainWindow)
        self.actionCarregar_lista_de_dados.setObjectName(_fromUtf8("actionCarregar_lista_de_dados"))
        
        self.actionCriar_dado_tabelado = QtGui.QAction(MainWindow)
        self.actionCriar_dado_tabelado.setObjectName(_fromUtf8("actionCriar_dado_tabelado"))
        
        self.actionYaFao = QtGui.QAction(MainWindow)
        self.actionYaFao.setObjectName(_fromUtf8("actionYaFao"))
        
       #self.actionListar_Fun_oes = QtGui.QAction(MainWindow)
        #self.actionListar_Fun_oes.setObjectName(_fromUtf8("actionListar_Fun_oes"))
        
        self.actionRodar = QtGui.QAction(MainWindow)
        self.actionRodar.setObjectName(_fromUtf8("actionRodar"))
        
        self.actionInterpolador = QtGui.QAction(MainWindow)
        self.actionInterpolador.setObjectName(_fromUtf8("actionInterpolador"))

        self.actionInterpoladorRaster2Raster = QtGui.QAction(MainWindow)
        self.actionInterpoladorRaster2Raster.setObjectName(_fromUtf8("actionInterpoladorRaster2Raster"))
        
        self.actionEstimativa_de_datas_de_colheita = QtGui.QAction(MainWindow)
        self.actionEstimativa_de_datas_de_colheita.setObjectName(_fromUtf8("actionEstimativa_de_datas_de_colheita"))

        self.actionDecendial_2_diario = QtGui.QAction(MainWindow)
        self.actionDecendial_2_diario.setObjectName(_fromUtf8("actionDecendial_2_diario"))
               
        self.actionFiltro_Savitz_Golay = QtGui.QAction(MainWindow)
        self.actionFiltro_Savitz_Golay.setObjectName(_fromUtf8("actionFiltro_Savitz_Golay"))
        
        self.actionEstatisticasEspectrais = QtGui.QAction(MainWindow)
        self.actionEstatisticasEspectrais.setObjectName(_fromUtf8("actionEstatisticasEspectrais"))

        self.actionDistribuidorDeIndice = QtGui.QAction(MainWindow)
        self.actionDistribuidorDeIndice.setObjectName(_fromUtf8("actionDistribuidorDeIndice"))
        
        self.menuBH.addAction(self.actionETc)
        self.menuBH.addAction(self.actionTAW)
        self.menuBH.addAction(self.actionEsgotamento_BHFAO)
        self.menuBH.addAction(self.actionKs)
        
        #self.menuCarregar_Dado.addAction(self.actionPPB)
        #self.menuCarregar_Dado.addAction(self.actionCarregar_lista_de_dados)
        #self.menuCarregar_Dado.addAction(self.actionCriar_dado_tabelado)
        
        self.menuProdutividade.addAction(self.actionPPB)
        self.menuProdutividade.addAction(self.actionYaFao)
        
        self.menuInterpoladores.addAction(self.actionInterpolador)
        self.menuInterpoladores.addAction(self.actionInterpoladorRaster2Raster)
        
        #self.menuFun_o_es.addAction(self.actionListar_Fun_oes)
        self.menuFun_o_es.addAction(self.menuInterpoladores.menuAction())
        self.menuFun_o_es.addAction(self.actionEstimativa_de_datas_de_colheita)
        self.menuFun_o_es.addAction(self.actionFiltro_Savitz_Golay)
        self.menuFun_o_es.addAction(self.actionDistribuidorDeIndice)
        self.menuFun_o_es.addAction(self.actionDecendial_2_diario)
        
        #self.menuEstatisticas.addAction(self.actionRodar)
        self.menuEstatisticas.addAction(self.actionEstatisticasEspectrais)
        
        self.menubar.addAction(self.menuFun_o_es.menuAction())
        self.menubar.addAction(self.menuBH.menuAction())
        self.menubar.addAction(self.menuProdutividade.menuAction())
        self.menubar.addAction(self.menuEstatisticas.menuAction())
        
        self.label = QtGui.QLabel(MainWindow)
        self.label.setGeometry(QtCore.QRect(26, 44, 600, 75))
        self.label.setObjectName(_fromUtf8("label"))

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        
        #import inspect
        
        #path_ = inspect.getfile(self.__class__)
        #path_ = str(path_).replace("Visao\TelaPrincipal.py", "")
        
        self.logo_lea = QtGui.QPushButton(MainWindow)
        self.logo_lea.setGeometry(QtCore.QRect(26, 130, 200, 82))
        self.icon_lea = QtGui.QIcon("images\logo_lea.jpg")
        self.icon_lea.pixmap(QtCore.QSize(200, 200))
        self.logo_lea.setIcon(self.icon_lea)
        self.logo_lea.setIconSize(QtCore.QSize(200, 100))

        self.logo_lea = QtGui.QPushButton(MainWindow)
        self.logo_lea.setGeometry(QtCore.QRect(250, 130, 120, 82))
        self.icon_lea = QtGui.QIcon("images\logoPgeagrid2.png")
        self.icon_lea.pixmap(QtCore.QSize(200, 200))
        self.logo_lea.setIcon(self.icon_lea)
        self.logo_lea.setIconSize(QtCore.QSize(145, 80))        

        self.logo_lea = QtGui.QPushButton(MainWindow)
        self.logo_lea.setGeometry(QtCore.QRect(394, 130, 82, 82))
        self.icon_lea = QtGui.QIcon("images\logo_campus_cvel.jpg")
        self.icon_lea.pixmap(QtCore.QSize(200, 200))
        self.logo_lea.setIcon(self.icon_lea)
        self.logo_lea.setIconSize(QtCore.QSize(120, 82))       

        self.logo_lea = QtGui.QPushButton(MainWindow)
        self.logo_lea.setGeometry(QtCore.QRect(500, 130, 110, 82))
        self.icon_lea = QtGui.QIcon("images\capes-logo-CAPES.jpg")
        self.icon_lea.pixmap(QtCore.QSize(200, 200))
        self.logo_lea.setIcon(self.icon_lea)
        self.logo_lea.setIconSize(QtCore.QSize(120, 82))       
                
        #MainWindow.add(self.logo_lea)

    def retranslateUi(self, MainWindow):
        
        config = ConfigParser.RawConfigParser()
        config.read('workspace.properties')
        version=config.get('Version', 'version')
        
        texto = "Software de Estimativa de Produtividade\n"
        
        texto += "Desenvolvido pelo Laboratório de Estatística Aplicada (LEA) - UNIOESTE - 2016\n"
        texto += "Desenvolvedor: Rennan Andres Paloschi - rennan_paloschi@yahoo.com\n"
        texto += "Orientação: Jerry Adriani Johann\n"
        texto += "Co-orientação: Adair Santa Catarina"
        
        self.label.setText(_translate("Dialog", texto, None))
            
        MainWindow.setWindowTitle(_translate("MainWindow", "Crop-yield Modeling Platform - CyMP " + version, None))
        self.menuBH.setTitle(_translate("MainWindow", "Balanço Hídrico", None))
        self.menuProdutividade.setTitle(_translate("MainWindow", "Estimativa de produtividade (FAO)", None))
        self.menuInterpoladores.setTitle(_translate("MainWindow", "Interpoladores", None))
        self.menuCarregar_Dado.setTitle(_translate("MainWindow", "Carregar dado", None))
        self.menuFun_o_es.setTitle(_translate("MainWindow", "Tratamento de dados", None))
        self.menuEstatisticas.setTitle(_translate("MainWindow", "Estatísticas", None))
        self.actionETc.setText(_translate("MainWindow", "Evapotranspiração (ETc - ETa)", None))
        self.actionTAW.setText(_translate("MainWindow", "Capacidade Hídrica (TAW/RAW)", None))
        self.actionEsgotamento_BHFAO.setText(_translate("MainWindow", "Calcular Esgotamento BHFAO (Dr)", None))
        self.actionKs.setText(_translate("MainWindow", "Fator de estresse hídrico da cultura (Ks)", None))
        
        self.actionPPB.setText(_translate("MainWindow", "Produtividade Potencial Bruta (PPB)", None))
        self.actionCarregar_lista_de_dados.setText(_translate("MainWindow", "Carregar lista de dados", None))
        self.actionCriar_dado_tabelado.setText(_translate("MainWindow", "Criar dado tabelado", None))
        self.actionYaFao.setText(_translate("MainWindow", "Produtividade atingível (Ya)", None))
        #self.actionListar_Fun_oes.setText(_translate("MainWindow", "Listar Funções", None))
        self.actionRodar.setText(_translate("MainWindow", "Executar", None))
        self.actionInterpolador.setText(_translate("MainWindow", "Interpolador shape ECMWF para raster", None))
        #self.actionInterpolador.setText(_translate("MainWindow", "Interpolador shape ECMWF para raster (em manutenção)", None))
        #self.actionInterpolador.setEnabled(False)
        self.actionInterpoladorRaster2Raster.setText(_translate("MainWindow", "Interpolador raster pra raster", None))
        self.actionEstimativa_de_datas_de_colheita.setText(_translate("MainWindow", "Estimativa de datas da cultura", None))
        self.actionDistribuidorDeIndice.setText(_translate("MainWindow", "Distribuidor de índice", None))
        self.actionDecendial_2_diario.setText(_translate("MainWindow", "Decendial para diário", None))
        
        self.actionFiltro_Savitz_Golay.setText(_translate("MainWindow", "Filtro Savitzky-golay", None))
        self.actionEstatisticasEspectrais.setText(_translate("MainWindow", "Estatísticas Descritivas (Perfil)", None))

        self.actionEstimativa_de_datas_de_colheita.triggered.connect(self.popupEstimativa_de_datas_de_colheita)
        self.actionFiltro_Savitz_Golay.triggered.connect(self.popupFiltro_Savitz_Golay)
        self.actionEstatisticasEspectrais.triggered.connect(self.popupEstatistiscas_Espectrais)
        self.actionInterpolador.triggered.connect(self.popupInterpolador_ECMWF)
        self.actionInterpoladorRaster2Raster.triggered.connect(self.popupInterpoladorRaster2Raster)
        self.actionDistribuidorDeIndice.triggered.connect(self.popupDestribuidor_de_indice)
        self.actionDecendial_2_diario.triggered.connect(self.popupDecendial_2_diario)
        self.actionETc.triggered.connect(self.popupETc)
        self.actionTAW.triggered.connect(self.popupTAW)
        self.actionEsgotamento_BHFAO.triggered.connect(self.popupDr)
        self.actionKs.triggered.connect(self.popupKs)
        self.actionPPB.triggered.connect(self.popupPPB)
        self.actionYaFao.triggered.connect(self.popupYaFao)


------------------  VectorData.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on Aug 4, 2015

@author: Paloschi
'''

from Modelo.beans import FileData
from Modelo.beans.TableData import TableData
try:
    import fiona
except:
    print u"ERRO - não foi possível carregar a biblioteca fiona, tente configurar as variáveis de ambiente"
try:
    import gdal
except:
    print u"ERRO - não foi possível carregar a biblioteca gdal, tente configurar as variáveis de ambiente"
       
progress = gdal.TermProgress_nocb



class VectorFile(FileData):
    '''
    essa classe representa um arquivo do tipo vetorial (shp)
    '''


    def readVectorData(self):
        
        print("Lendo Shape...")
        
        data_values = list()
        data = TableData()
        
        progress( 0.0 )
        
        i = float(0) 
        with fiona.open(self.file_full_path, 'r') as shape:
            total = len(shape)  
            data['properties'] = shape.schema.copy()['properties']
            for polygon in shape:
                data_values.append(polygon)
                i +=1
                progress( i / total)
            
        data['table_data'] = data_values
        
        print('Leitura completada')  
         
        return data    
    

        

        

------------------  Ya.py  ------------------
﻿# -*- coding: utf-8 -*-
'''
Created on 04/12/2015

@author: Paloschi
'''
from Modelo.Funcoes import AbstractFunction
from Modelo.beans import SERIAL_FILE_DATA, FILE_DATA, SerialTemporalFiles
import gdal
from Modelo.beans.RasterData import RasterFile
progress = gdal.TermProgress_nocb
import numpy
import threading
from Modelo.beans import RasterFile, SERIAL_FILE_DATA

class Ya(AbstractFunction):
    '''
        Essa função calcula a TAW
    '''
    def __setParamIN__(self):
        
        self.descriptionIN["ETa"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"..."}
        self.descriptionIN["ETc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"..."}
        self.descriptionIN["Ky"] = {"Required":True, "Type":None, "Description":"..."}
        self.descriptionIN["Yx"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"..."}
        self.descriptionIN["Ya"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"..."}
        self.descriptionIN["Kc"] = {"Required":True, "Type":SERIAL_FILE_DATA, "Description":"..."}
    
    def __setParamOUT__(self):
        self.descriptionOUT["Ya"] = {"Type":SERIAL_FILE_DATA, "Description":"..."}
    
    def __execOperation__(self):

        self.console("Carregando imagens.")
        
        serie_eta = self.paramentrosIN_carregados["ETa"].loadListByRoot() # pucha e já carrega a lista caso não tenha sido carregada
        serie_etc = self.paramentrosIN_carregados["ETc"].loadListByRoot()
        serie_yx = self.paramentrosIN_carregados["Yx"].loadListByRoot() # pucha lista
        serie_Kc = self.paramentrosIN_carregados["Kc"].loadListByRoot() # pucha lista
        serie_ya = self.paramentrosIN_carregados["Ya"]
        
        ky = self.paramentrosIN_carregados["Ky"]
        
        factor_eta = float(serie_eta.mutiply_factor)
        factor_etc = float(serie_etc.mutiply_factor)
        factor_yx = float(serie_yx.mutiply_factor)
        factor_ya = float(serie_ya.mutiply_factor)
        
        n_img = len(serie_Kc)
        
        self.console("As imagens de Kc serão usadas como referencia")
        self.console(str(n_img) + " imagens de Kc encontradas.")
        
        self.console(u"Gerando série de imagens de Ya..")

        for i in range(n_img):
            
            if threading.currentThread().stopped()  : return 
            self.setProgresso(i, n_img)

            kc = serie_Kc[i]
            data_ref = serie_Kc.getDate_time(file=kc)
            kc_ = kc.loadRasterData()
            
            eta_ = self.LoadImgByDate(serie_eta, data_ref, factor_eta)
            etc_ = self.LoadImgByDate(serie_etc, data_ref, factor_etc)
            yx_ = self.LoadImgByDate(serie_yx, data_ref, factor_yx)
            
            
            p1= ky * (1-eta_/etc_)
            ya_ = (1-p1) * yx_
            
            for i in range(len(ya_)): 
                ya_[i][kc_[i]==0] = 0
                
            ya_ = numpy.round(ya_, 3)   
            ya_ *= factor_ya
            
            #ya_ = self.compactar(ya_)   
            
            ya = RasterFile(file_path=serie_ya.root_path, ext="tif")
            ya = serie_ya.setDate_time(data_ref, file=ya)       
            ya.data = ya_
            ya.metadata = kc.metadata
            ya.metadata.update(nodata=0)
            ya.saveRasterData()
            
            ya.data = ya_
            
            serie_ya.append(ya)
        
        return serie_ya
    
    def LoadImgByDate(self, serie, date, factor):          
            img = self.procura_img_por_data(serie, date)
            img_ = numpy.array(img.loadRasterData()).astype(dtype="float32")
            img_ *= factor  
            return img_
        
    def testar(self):

        self.paramentrosIN_carregados = dict()
        self.paramentrosIN_carregados["ETa"] = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\6-Eta")
        self.paramentrosIN_carregados["ETa"].prefixo = "eta_"
        self.paramentrosIN_carregados["ETa"].date_mask = "%Y-%m-%d"
        self.paramentrosIN_carregados["ETa"].multply_factor = 0.01
        
        self.paramentrosIN_carregados["ETc"] = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\3-ETc")
        self.paramentrosIN_carregados["ETc"].prefixo = "etc_"
        self.paramentrosIN_carregados["ETc"].date_mask = "%Y-%m-%d"
        self.paramentrosIN_carregados["ETc"].multply_factor = 0.01
        
        self.paramentrosIN_carregados["Ky"] = 0.8
        
        self.paramentrosIN_carregados["Yx"] = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\5-PPR(Yx)")
        self.paramentrosIN_carregados["Yx"].prefixo = "ppr_"
        self.paramentrosIN_carregados["Yx"].date_mask = "%Y-%m-%d"
        self.paramentrosIN_carregados["Yx"].multply_factor = 1
        
        self.paramentrosIN_carregados["Ya"] = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\7-Ya")
        self.paramentrosIN_carregados["Ya"].prefixo = "Ya_"
        self.paramentrosIN_carregados["Ya"].date_mask = "%Y-%m-%d"
        self.paramentrosIN_carregados["Ya"].multply_factor = 100
        
        self.paramentrosIN_carregados["Kc"] = SerialTemporalFiles(root_path="C:\\Users\\Paloschi\\Desktop\\Tudo_Necessario\\2-Kc")
        self.paramentrosIN_carregados["Kc"].date_mask = "%Y-%m-%d"
         
        self.__execOperation__()
        
        
if __name__ == '__main__':
    ppr = Ya()
    ppr.testar()

------------------  __init__.py  ------------------
from StatisticalStractor import SpectreStatisticalStractor